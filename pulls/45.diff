diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 4324043..0f41f62 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -66,6 +66,7 @@
     private ForegroundServiceStarter foregroundServiceStarter;
     private int mConnectionState = STATE_DISCONNECTED;
     private BluetoothDevice device;
+    int mStartMode;
 
     private Context mContext = null;
 
@@ -75,13 +76,8 @@
     private static final int STATE_CONNECTED = BluetoothProfile.STATE_CONNECTED;
 
     public final static String ACTION_DATA_AVAILABLE = "com.example.bluetooth.le.ACTION_DATA_AVAILABLE";
-    public final static UUID xDripDataService = UUID.fromString(HM10Attributes.HM_10_SERVICE);
-    public final static UUID xDripDataCharacteristic = UUID.fromString(HM10Attributes.HM_RX_TX);
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        throw new UnsupportedOperationException("Not yet implemented");
-    }
+    public final static UUID DexDripDataService = UUID.fromString(HM10Attributes.HM_10_SERVICE);
+    public final static UUID DexDripDataCharacteristic = UUID.fromString(HM10Attributes.HM_RX_TX);
 
     @Override
     public void onCreate() {
@@ -90,49 +86,25 @@ public void onCreate() {
         mContext = getApplicationContext();
         dexCollectionService = this;
         listenForChangeInSettings();
+        this.startService(new Intent(this, SyncService.class));
         Log.w(TAG, "STARTING SERVICE");
     }
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
-            setFailoverTimer();
-        } else {
-            return START_NOT_STICKY;
-        }
         attemptConnection();
         return START_STICKY;
     }
 
     @Override
     public void onDestroy() {
-        super.onDestroy();
+        setRetryTimer();
         close();
         foregroundServiceStarter.stop();
-        setRetryTimer();
         Log.w(TAG, "SERVICE STOPPED");
     }
 
-    public void setRetryTimer() {
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
-            long retry_in = (1000 * 60 * 2);
-            Log.d(TAG, "Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
-            Calendar calendar = Calendar.getInstance();
-            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
-        }
-    }
-
-    public void setFailoverTimer() { //Sometimes it gets stuck in limbo on 4.4, this should make it try again
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
-            long retry_in = (1000 * 60 * 5);
-            Log.d(TAG, "Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
-            Calendar calendar = Calendar.getInstance();
-            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
-        }
-    }
-
+    //TODO: Move this somewhere more reusable
     public void listenForChangeInSettings() {
         SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() {
             public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
@@ -149,7 +121,7 @@ public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
                     }
                 }
                 if(key.compareTo("dex_collection_method") == 0) {
-                    CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
+                    CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter();
                     collectionServiceStarter.start(getApplicationContext());
                 }
             }
@@ -159,37 +131,54 @@ public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
     }
 
     public void attemptConnection() {
-        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-        if (mBluetoothManager != null) {
-            mBluetoothAdapter = mBluetoothManager.getAdapter();
-            if (mBluetoothAdapter != null) {
-                if (device != null) {
-                    mConnectionState = STATE_DISCONNECTED;
-                    for (BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
-                        if (bluetoothDevice.getAddress().compareTo(device.getAddress()) == 0) {
-                            mConnectionState = STATE_CONNECTED;
-                        }
+        if (device != null) {
+            mConnectionState = mBluetoothManager.getConnectionState(device, BluetoothProfile.GATT);
+        }
+        Log.w(TAG, "Connection state: " + mConnectionState);
+        if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
+            ActiveBluetoothDevice btDevice = new Select().from(ActiveBluetoothDevice.class)
+                    .orderBy("_ID desc")
+                    .executeSingle();
+            if (btDevice != null) {
+                mDeviceName = btDevice.name;
+                mDeviceAddress = btDevice.address;
+
+                if (mBluetoothManager == null) {
+                    mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+                    if (mBluetoothManager == null) {
+                        Log.w(TAG, "Unable to initialize BluetoothManager.");
                     }
                 }
-
-                Log.w(TAG, "Connection state: " + mConnectionState);
-                if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
-                    ActiveBluetoothDevice btDevice = ActiveBluetoothDevice.first();
-                    if (btDevice != null) {
-                        mDeviceName = btDevice.name;
-                        mDeviceAddress = btDevice.address;
-                        if (mBluetoothAdapter.isEnabled() && mBluetoothAdapter.getRemoteDevice(mDeviceAddress) != null) {
-                            connect(mDeviceAddress);
-                            return;
-                        }
+                if (mBluetoothManager != null) {
+                    mBluetoothAdapter = mBluetoothManager.getAdapter();
+                    if (mBluetoothAdapter == null) {
+                        Log.w(TAG, "Unable to obtain a BluetoothAdapter.");
+                        setRetryTimer();
+                    }
+                    is_connected = connect(mDeviceAddress);
+                    if (is_connected) {
+                        Log.w(TAG, "connected to device");
+                    } else {
+                        Log.w(TAG, "Unable to connect to device");
+                        setRetryTimer();
                     }
-                } else if (mConnectionState == STATE_CONNECTED) { //WOOO, we are good to go, nothing to do here!
-                    Log.w(TAG, "Looks like we are already connected, going to read!");
-                    return;
+
+                } else {
+                    Log.w(TAG, "Still no bluetooth Manager");
+                    setRetryTimer();
                 }
+            } else {
+                Log.w(TAG, "No bluetooth device to try to connect to");
+                setRetryTimer();
             }
         }
-        setRetryTimer();
+    }
+
+    public void setRetryTimer() {
+        Calendar calendar = Calendar.getInstance();
+        AlarmManager alarm = (AlarmManager)getSystemService(ALARM_SERVICE);
+        alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + (1000 * 60 * 2), PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+        Log.w(TAG, "Retry set for" +  (((calendar.getTimeInMillis() + (1000 * 60 * 2)) - (int) (new Date().getTime())) / (60000)) + "mins from now!");
     }
 
     private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
@@ -197,12 +186,12 @@ public void attemptConnection() {
         public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
             if (newState == BluetoothProfile.STATE_CONNECTED) {
                 mConnectionState = STATE_CONNECTED;
-                ActiveBluetoothDevice.connected();
                 Log.w(TAG, "Connected to GATT server.");
-                mBluetoothGatt.discoverServices();
+                Log.w(TAG, "Attempting to start service discovery: " +
+                        mBluetoothGatt.discoverServices());
+
             } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                 mConnectionState = STATE_DISCONNECTED;
-                ActiveBluetoothDevice.disconnected();
                 Log.w(TAG, "Disconnected from GATT server.");
                 setRetryTimer();
             }
@@ -211,73 +200,157 @@ public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState
         @Override
         public void onServicesDiscovered(BluetoothGatt gatt, int status) {
             if (status == BluetoothGatt.GATT_SUCCESS) {
-                BluetoothGattService gattService = mBluetoothGatt.getService(xDripDataService);
-                if (gattService != null) {
-                    BluetoothGattCharacteristic gattCharacteristic = gattService.getCharacteristic(xDripDataCharacteristic);
-                    if (gattCharacteristic != null ) {
-                        final int charaProp = gattCharacteristic.getProperties();
-
-                        if ((charaProp | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {
-                            mBluetoothGatt.setCharacteristicNotification(gattCharacteristic, true);
-                        } else {
-                            Log.e(TAG, "characteristic " + gattCharacteristic.getUuid() + " doesn't have notify properties");
-                        }
-                    } else {
-                        Log.e(TAG, "characteristic " + xDripDataCharacteristic + " not found");
+                for (BluetoothGattService gattService : mBluetoothGatt.getServices()) {
+                    Log.w(TAG, "Service Found");
+                    for (BluetoothGattCharacteristic gattCharacteristic : gattService.getCharacteristics()) {
+                        Log.w(TAG, "Characteristic Found");
+                        setCharacteristicNotification(gattCharacteristic, true);
                     }
-                } else {
-                    Log.e(TAG, "service " + xDripDataCharacteristic + " not found");
                 }
+                Log.w(TAG, "onServicesDiscovered received success: " + status);
+            } else {
+                Log.w(TAG, "onServicesDiscovered received: " + status);
+            }
+        }
+
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt,
+                                         BluetoothGattCharacteristic characteristic,
+                                         int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
             }
         }
 
         @Override
-        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
-            final byte[] data = characteristic.getValue();
-            if (data != null && data.length > 0) { setSerialDataToTransmitterRawData(data, data.length); }
+        public void onCharacteristicChanged(BluetoothGatt gatt,
+                                            BluetoothGattCharacteristic characteristic) {
+            broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
+        }
+};
+
+    private void broadcastUpdate(final String action) {
+    }
+
+    private void broadcastUpdate(final String action,
+                                 final BluetoothGattCharacteristic characteristic) {
+
+        final byte[] data = characteristic.getValue();
+
+        if (data != null && data.length > 0) {
+            setSerialDataToTransmitterRawData(data, data.length);
+        }
+    }
+
+    public class LocalBinder extends Binder {
+        DexCollectionService getService() {
+            return DexCollectionService.this;
+        }
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return mBinder;
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        close();
+        return super.onUnbind(intent);
+    }
+
+    private final IBinder mBinder = new LocalBinder();
+    public boolean initialize() {
+        if (mBluetoothManager == null) {
+            mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+            if (mBluetoothManager == null) {
+                Log.w(TAG, "Unable to initialize BluetoothManager.");
+                return false;
+            }
+        }
+
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        if (mBluetoothAdapter == null) {
+            Log.w(TAG, "Unable to obtain a BluetoothAdapter.");
+            return false;
         }
-    };
+        return true;
+    }
 
     public boolean connect(final String address) {
-        Log.w(TAG, "going to connect to device at address" + address);
+        Log.w(TAG, "CONNECTING TO DEVICE");
+        Log.w(TAG, address);
         if (mBluetoothAdapter == null || address == null) {
             Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
-            setRetryTimer();
             return false;
         }
-        if (mBluetoothGatt != null) {
-            Log.w(TAG, "BGatt isnt null, Closing.");
-            mBluetoothGatt.close();
-            mBluetoothGatt = null;
+        if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress)
+                && mBluetoothGatt != null) {
+            Log.w(TAG, "Trying to use an existing mBluetoothGatt for connection.");
+            if (mBluetoothGatt.connect()) {
+                mConnectionState = STATE_CONNECTING;
+                return true;
+            } else {
+                return false;
+            }
         }
         device = mBluetoothAdapter.getRemoteDevice(address);
         if (device == null) {
             Log.w(TAG, "Device not found.  Unable to connect.");
-            setRetryTimer();
             return false;
         }
+        mBluetoothGatt = device.connectGatt(this, true, mGattCallback);
         Log.w(TAG, "Trying to create a new connection.");
-        mBluetoothGatt = device.connectGatt(getApplicationContext(), true, mGattCallback);
+        mBluetoothDeviceAddress = address;
         mConnectionState = STATE_CONNECTING;
         return true;
     }
 
     public void disconnect() {
-        if ( mBluetoothGatt == null) { return; }
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized");
+            return;
+        }
         mBluetoothGatt.disconnect();
-        Log.d(TAG, "Gatt Disconnect");
     }
+
     public void close() {
+        disconnect();
         if (mBluetoothGatt == null) {
             return;
         }
         mBluetoothGatt.close();
-        setRetryTimer();
         mBluetoothGatt = null;
         mConnectionState = STATE_DISCONNECTED;
     }
 
+    public void readCharacteristic(BluetoothGattCharacteristic characteristic) {
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized");
+            return;
+        }
+        mBluetoothGatt.readCharacteristic(characteristic);
+    }
+
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic,
+                                              boolean enabled) {
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized");
+            return;
+        }
+        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
+        Log.w(TAG, "UUID FOUND: " + characteristic.getUuid());
+        if (DexDripDataCharacteristic.equals(characteristic.getUuid())) {
+            Log.w(TAG, "UUID MATCH FOUND!!! " + characteristic.getUuid());
+            BluetoothGattDescriptor descriptor = characteristic.getDescriptor(
+                    UUID.fromString(HM10Attributes.CLIENT_CHARACTERISTIC_CONFIG));
+            descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+            mBluetoothGatt.writeDescriptor(descriptor);
+        }
+    }
+
     public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
+
         Log.w(TAG, "received some data!");
         Long timestamp = new Date().getTime();
         TransmitterData transmitterData = TransmitterData.create(buffer, len, timestamp);
@@ -287,7 +360,7 @@ public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
                 sensor.latest_battery_level = transmitterData.sensor_battery_level;
                 sensor.save();
 
-                BgReading.create(transmitterData.raw_data, this, timestamp);
+                BgReading bgReading = BgReading.create(transmitterData.raw_data, this, timestamp);
             } else {
                 Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
             }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
index 2e7a5f5..2d7b9e3 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
@@ -136,9 +136,9 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                 } else {
                     throw new Exception("Unexpected baseURI");
                 }
-
                 String postURL = baseURL + "entries";
                 Log.i(TAG, "postURL: " + postURL);
+                Log.i(TAG, "secret: " + secret);
 
                 HttpParams params = new BasicHttpParams();
                 HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);
@@ -175,12 +175,16 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                     JSONObject json = new JSONObject();
 
                     try {
-                        if (apiVersion >= 1)
+                        if (apiVersion >= 1) {
+                            Log.v(TAG, "populating V1 entry");
                             populateV1APIBGEntry(json, record);
-                        else
+                        } else {
+                            Log.v(TAG, "populating Legacy entry");
                             populateLegacyAPIEntry(json, record);
+                        }
                     } catch (Exception e) {
                         Log.w(TAG, "Unable to populate entry");
+                        Log.v(TAG, e.getMessage());
                         continue;
                     }
 
@@ -198,6 +202,7 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                         httpclient.execute(post, responseHandler);
                     } catch (Exception e) {
                         Log.w(TAG, "Unable to populate entry");
+                        Log.v(TAG, e.getMessage());
                     }
                 }
 
@@ -209,6 +214,7 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                             populateV1APIMeterReadingEntry(json, record);
                         } catch (Exception e) {
                             Log.w(TAG, "Unable to populate entry");
+                            Log.v(TAG, e.getMessage());
                             continue;
                         }
 
@@ -225,6 +231,7 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                             httpclient.execute(post, responseHandler);
                         } catch (Exception e) {
                             Log.w(TAG, "Unable to post data");
+                            Log.v(TAG, e.getMessage());
                         }
                     }
                 }
@@ -238,6 +245,7 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                             populateV1APICalibrationEntry(json, calRecord);
                         } catch (Exception e) {
                             Log.w(TAG, "Unable to populate entry");
+                            Log.v(TAG, e.getMessage());
                             continue;
                         }
 
@@ -254,6 +262,7 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
                             httpclient.execute(post, responseHandler);
                         } catch (Exception e) {
                             Log.w(TAG, "Unable to post data");
+                            Log.v(TAG, e.getMessage());
                         }
                     }
                 }
@@ -263,28 +272,28 @@ private void doRESTUploadTo(String baseURI, List<BgReading> glucoseDataSets, Lis
 
             } catch (Exception e) {
                 Log.w(TAG, "Unable to post data");
+                Log.v(TAG, e.getMessage());
             }
         }
 
         private void populateV1APIBGEntry(JSONObject json, BgReading record) throws Exception {
             SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss a");
             format.setTimeZone(TimeZone.getDefault());
-            json.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+            json.put("device", "dexcom");
             json.put("date", record.timestamp);
             json.put("dateString", format.format(record.timestamp));
             json.put("sgv", (int)record.calculated_value);
             json.put("direction", record.slopeName());
             json.put("type", "sgv");
-            json.put("filtered", record.filtered_data * 1000);
-            json.put("unfiltered", record.age_adjusted_raw_value * 1000);
-            json.put("rssi", 100);
-            json.put("noise", Integer.valueOf(record.noiseValue()));
+            json.put("filtered", record.age_adjusted_raw_value); //TODO: change to actual filtered when I start storing it
+            json.put("unfiltered", record.age_adjusted_raw_value);
+            json.put("rssi", "100");
         }
 
         private void populateLegacyAPIEntry(JSONObject json, BgReading record) throws Exception {
             SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss a");
             format.setTimeZone(TimeZone.getDefault());
-            json.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+            json.put("device", "dexcom");
             json.put("date", record.timestamp);
             json.put("dateString", format.format(record.timestamp));
             json.put("sgv", (int)record.calculated_value);
@@ -294,7 +303,7 @@ private void populateLegacyAPIEntry(JSONObject json, BgReading record) throws Ex
         private void populateV1APIMeterReadingEntry(JSONObject json, Calibration record) throws Exception {
             SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss a");
             format.setTimeZone(TimeZone.getDefault());
-            json.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+            json.put("device", "dexcom");
             json.put("type", "mbg");
             json.put("date", record.timestamp);
             json.put("dateString", format.format(record.timestamp));
@@ -305,13 +314,13 @@ private void populateV1APICalibrationEntry(JSONObject json, Calibration record)
             SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss a");
             format.setTimeZone(TimeZone.getDefault());
 
-            json.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+            json.put("device", "dexcom");
             json.put("type", "cal");
             json.put("date", record.timestamp);
             json.put("dateString", format.format(record.timestamp));
-            json.put("slope", (long)(record.slope * 1000));
-            json.put("intercept", (long) ((record.intercept * -1000) / (record.slope * 1000)));
-            json.put("scale", 1);
+            json.put("slope", (int)(record.slope * 1000));
+            json.put("intercept", (int) record.intercept);
+            json.put("scale", 1000);
         }
 
         // TODO: this is a quick port from original code and needs to be refactored before release
@@ -363,16 +372,15 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
                     for (BgReading record : glucoseDataSets) {
                         // make db object
                         BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+                        testData.put("device", "dexcom");
                         testData.put("date", record.timestamp);
                         testData.put("dateString", format.format(record.timestamp));
-                        testData.put("sgv", Math.round(record.calculated_value));
+                        testData.put("sgv", (int)record.calculated_value);
                         testData.put("direction", record.slopeName());
                         testData.put("type", "sgv");
-                        testData.put("filtered", record.filtered_data * 1000);
-                        testData.put("unfiltered", record.age_adjusted_raw_value * 1000 );
-                        testData.put("rssi", 100);
-                        testData.put("noise", Integer.valueOf(record.noiseValue()));
+                        testData.put("filtered", record.age_adjusted_raw_value); //TODO: change to actual filtered when I start storing it
+                        testData.put("unfiltered", record.age_adjusted_raw_value);
+                        testData.put("rssi", "100");
                         dexcomData.update(testData, testData, true, false, WriteConcern.UNACKNOWLEDGED);
                     }
 
@@ -380,7 +388,7 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
                     for (Calibration meterRecord : meterRecords) {
                         // make db object
                         BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+                        testData.put("device", "dexcom");
                         testData.put("type", "mbg");
                         testData.put("date", meterRecord.timestamp);
                         testData.put("dateString", format.format(meterRecord.timestamp));
@@ -391,12 +399,12 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
                     for (Calibration calRecord : calRecords) {
                         // make db object
                         BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
+                        testData.put("device", "dexcom");
                         testData.put("date", calRecord.timestamp);
                         testData.put("dateString", format.format(calRecord.timestamp));
-                        testData.put("slope", (long)(calRecord.slope * 1000));
-                        testData.put("intercept", (long) ((calRecord.intercept * -1000) / (calRecord.slope * 1000)));
-                        testData.put("scale", 1);
+                        testData.put("slope", (int)(calRecord.slope * 1000));
+                        testData.put("intercept", (int) calRecord.intercept);
+                        testData.put("scale", 1000);
                         testData.put("type", "cal");
                         dexcomData.update(testData, testData, true, false, WriteConcern.UNACKNOWLEDGED);
                     }

diff --git a/app/app.iml b/app/app.iml
index f266c9d..5b22985 100644
--- a/app/app.iml
+++ b/app/app.iml
@@ -86,23 +86,25 @@
     </content>
     <orderEntry type="jdk" jdkName="Android API 22 Platform" jdkType="Android SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" name="ActiveAndroid" level="project" />
-    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />
-    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />
-    <orderEntry type="library" exported="" name="crashlytics-2.2.3" level="project" />
-    <orderEntry type="library" exported="" name="answers-1.1.2" level="project" />
-    <orderEntry type="library" exported="" name="retrofit-1.9.0" level="project" />
+    <orderEntry type="library" exported="" name="gson-2.3.1" level="project" />
     <orderEntry type="library" exported="" name="acra-4.5.0" level="project" />
-    <orderEntry type="library" exported="" name="rxjava-1.0.0" level="project" />
     <orderEntry type="library" exported="" name="support-annotations-22.1.1" level="project" />
-    <orderEntry type="library" exported="" name="beta-1.1.2" level="project" />
-    <orderEntry type="library" exported="" name="gson-2.3.1" level="project" />
-    <orderEntry type="library" exported="" name="appcompat-v7-22.1.1" level="project" />
-    <orderEntry type="library" exported="" name="mongo-java-driver-2.10.1" level="project" />
+    <orderEntry type="library" exported="" name="support-v4-22.1.1" level="project" />
     <orderEntry type="library" exported="" name="usb-serial-for-android-v010" level="project" />
-    <orderEntry type="library" exported="" name="pebblekit-2.6.0" level="project" />
+    <orderEntry type="library" exported="" name="snackbar-2.10.8" level="project" />
+    <orderEntry type="library" exported="" name="recyclerview-v7-22.0.0" level="project" />
+    <orderEntry type="library" exported="" name="retrofit-1.9.0" level="project" />
     <orderEntry type="library" exported="" name="fabric-1.3.0" level="project" />
+    <orderEntry type="library" exported="" name="appcompat-v7-22.1.1" level="project" />
+    <orderEntry type="library" exported="" name="crashlytics-2.2.3" level="project" />
+    <orderEntry type="library" exported="" name="rxjava-1.0.0" level="project" />
+    <orderEntry type="library" exported="" name="beta-1.1.2" level="project" />
+    <orderEntry type="library" exported="" name="pebblekit-2.6.0" level="project" />
+    <orderEntry type="library" exported="" name="ActiveAndroid" level="project" />
     <orderEntry type="library" exported="" name="hellocharts-library-1.1" level="project" />
-    <orderEntry type="library" exported="" name="support-v4-22.1.1" level="project" />
+    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />
+    <orderEntry type="library" exported="" name="mongo-java-driver-2.10.1" level="project" />
+    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />
+    <orderEntry type="library" exported="" name="answers-1.1.2" level="project" />
   </component>
 </module>
\ No newline at end of file
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
index 6953428..c6a4277 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
@@ -19,6 +19,7 @@
 import android.support.v4.widget.DrawerLayout;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.view.View;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -27,6 +28,7 @@
 import com.eveningoutpost.dexdrip.Models.AlertType;
 import com.eveningoutpost.dexdrip.Models.BgReading;
 import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.Services.DexCollectionService;
 import com.eveningoutpost.dexdrip.Services.WixelReader;
 import com.eveningoutpost.dexdrip.UtilityModels.BgGraphBuilder;
 import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
@@ -67,18 +69,24 @@
     public boolean updatingPreviewViewport = false;
     public boolean updatingChartViewport = false;
     boolean isBTWixel;
+    boolean isDexbridgeWixel;
     boolean isBTShare;
     boolean isWifiWixel;
 
     public BgGraphBuilder bgGraphBuilder;
     BroadcastReceiver _broadcastReceiver;
     BroadcastReceiver newDataReceiver;
+    BroadcastReceiver newSavedBgReceiver;
+    private static Context mContext;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        mContext = getApplicationContext();
         CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
         collectionServiceStarter.start(getApplicationContext());
+        PreferenceManager.setDefaultValues(this, R.xml.pref_general, false);
+        PreferenceManager.setDefaultValues(this, R.xml.pref_data_sync, false);
         PreferenceManager.setDefaultValues(this, R.xml.pref_notifications, false);
         PreferenceManager.setDefaultValues(this, R.xml.pref_data_source, false);
         prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
@@ -116,8 +124,17 @@ public void onReceive(Context ctx, Intent intent) {
                 updateCurrentBgInfo();
             }
         };
+        newSavedBgReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context ctx, Intent intent) {
+                if (intent.getAction().compareTo("com.eveningoutpost.dexdrip.DexCollectionService.SAVED_BG") == 0) {
+                        updateCurrentBgInfo();
+            }
+        }
+    };
         registerReceiver(_broadcastReceiver, new IntentFilter(Intent.ACTION_TIME_TICK));
         registerReceiver(newDataReceiver, new IntentFilter(Intents.ACTION_NEW_BG_ESTIMATE_NO_DATA));
+        registerReceiver(newSavedBgReceiver, new IntentFilter("com.eveningoutpost.dexdrip.DexCollectionService.SAVED_BG"));
         mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManager().findFragmentById(R.id.navigation_drawer);
         mNavigationDrawerFragment.setUp(R.id.navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), menu_name, this);
         holdViewport.set(0, 0, 0, 0);
@@ -125,6 +142,10 @@ public void onReceive(Context ctx, Intent intent) {
         updateCurrentBgInfo();
     }
 
+    public static Context getContext() {
+        return mContext;
+    }
+
     public void setupCharts() {
         bgGraphBuilder = new BgGraphBuilder(this);
         updateStuff = false;
@@ -196,12 +217,16 @@ public void onPause() {
         if(newDataReceiver != null) {
             unregisterReceiver(newDataReceiver);
         }
+        if(newSavedBgReceiver != null) {
+            unregisterReceiver(newSavedBgReceiver);
+        }
     }
 
     public void updateCurrentBgInfo() {
         final TextView notificationText = (TextView)findViewById(R.id.notices);
         notificationText.setText("");
         isBTWixel = CollectionServiceStarter.isBTWixel(getApplicationContext());
+        isDexbridgeWixel = CollectionServiceStarter.isDexbridgeWixel(getApplicationContext());
         isBTShare = CollectionServiceStarter.isBTShare(getApplicationContext());
         isWifiWixel = CollectionServiceStarter.isWifiWixel(getApplicationContext());
         if(isBTShare) {
@@ -228,7 +253,7 @@ public void updateCurrentBgInfo() {
                 }
             }
         }
-        if(isBTWixel) {
+        if(isBTWixel || isDexbridgeWixel) {
             if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
                 notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
             } else {
@@ -302,6 +327,21 @@ public void displayCurrentInfo() {
         DecimalFormat df = new DecimalFormat("#");
         df.setMaximumFractionDigits(0);
 
+        boolean isDexbridge = CollectionServiceStarter.isDexbridgeWixel(getApplicationContext());
+        byte bridgeBattery = DexCollectionService.getBridgeBattery();
+        final TextView dexbridgeBattery = (TextView)findViewById(R.id.textBridgeBattery);
+        if(isDexbridge) {
+            if(bridgeBattery == 0){
+                dexbridgeBattery.setText("Waiting for packet");
+            } else {
+                dexbridgeBattery.setText("Bridge Battery: " + bridgeBattery + "%");
+            }
+            if(bridgeBattery < 50) dexbridgeBattery.setTextColor(Color.YELLOW);
+            if(bridgeBattery < 25) dexbridgeBattery.setTextColor(Color.RED); else dexbridgeBattery.setTextColor(Color.GREEN);
+            dexbridgeBattery.setVisibility(View.VISIBLE);
+        } else {
+            dexbridgeBattery.setVisibility(View.INVISIBLE);
+        }
         final TextView currentBgValueText = (TextView)findViewById(R.id.currentBgValueRealTime);
         final TextView notificationText = (TextView)findViewById(R.id.notices);
         if ((currentBgValueText.getPaintFlags() & Paint.STRIKE_THRU_TEXT_FLAG) > 0) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 2c44d03..da60ea9 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -32,8 +32,9 @@
 
 @Table(name = "BgReadings", id = BaseColumns._ID)
 public class BgReading extends Model {
+    private static boolean predictBG;
     private final static String TAG = BgReading.class.getSimpleName();
-    private final static String TAG_ALERT = "AlertBg";
+    private final static String TAG_ALERT = TAG +" AlertBg";
     //TODO: Have these as adjustable settings!!
     public final static double BESTOFFSET = (60000 * 0); // Assume readings are about x minutes off from actual!
 
@@ -182,7 +183,7 @@ public static void create(SensorRecord[] sensorRecords, long addativeOffset, Con
     }
 
     public static void create(SensorRecord sensorRecord, long addativeOffset, Context context) {
-        Log.w(TAG, "gonna make some sensor records: " + sensorRecord.getUnfiltered());
+        Log.w(TAG, "create: gonna make some sensor records: " + sensorRecord.getUnfiltered());
         if(BgReading.is_new(sensorRecord, addativeOffset)) {
             BgReading bgReading = new BgReading();
             Sensor sensor = Sensor.currentSensor();
@@ -207,7 +208,7 @@ public static void create(SensorRecord sensorRecord, long addativeOffset, Contex
 
     public static void create(EGVRecord egvRecord, long addativeOffset, Context context) {
         BgReading bgReading = BgReading.getForTimestamp(egvRecord.getSystemTime().getTime() + addativeOffset);
-        Log.w(TAG, "Looking for BG reading to tag this thing to: " + egvRecord.getBGValue());
+        Log.w(TAG, "create: Looking for BG reading to tag this thing to: " + egvRecord.getBGValue());
         if(bgReading != null) {
             bgReading.calculated_value = egvRecord.getBGValue();
             if (egvRecord.getBGValue() <= 13) {
@@ -218,7 +219,7 @@ public static void create(EGVRecord egvRecord, long addativeOffset, Context cont
                 bgReading.raw_calculated = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
                 bgReading.noise = egvRecord.noiseValue();
             }
-            Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
+            Log.w(TAG, "create: NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
             bgReading.calculated_value_slope = bgReading.slopefromName(egvRecord.getTrend().friendlyTrendName());
             if(egvRecord.getTrend().friendlyTrendName().compareTo("NOT_COMPUTABLE") == 0 || egvRecord.getTrend().friendlyTrendName().compareTo("OUT_OF_RANGE") == 0) {
                 bgReading.hide_slope = true;
@@ -227,6 +228,7 @@ public static void create(EGVRecord egvRecord, long addativeOffset, Context cont
             bgReading.save();
             bgReading.find_new_curve();
             bgReading.find_new_raw_curve();
+            bgReading.perform_calculations();
             Notifications.getInstance(context).notificationSetter(context);
             BgSendQueue.addToQueue(bgReading, "create", context);
         }
@@ -244,11 +246,11 @@ public static BgReading getForTimestamp(double timestamp) {
                     .orderBy("timestamp desc")
                     .executeSingle();
             if(bgReading != null && Math.abs(bgReading.timestamp - timestamp) < (3*60*1000)) { //cool, so was it actually within 4 minutes of that bg reading?
-                Log.w(TAG, "Found a BG timestamp match");
+                Log.w(TAG, "getForTimestamp: Found a BG timestamp match");
                 return bgReading;
             }
         }
-        Log.w(TAG, "No luck finding a BG timestamp match");
+        Log.w(TAG, "getForTimestamp: No luck finding a BG timestamp match");
         return null;
     }
 
@@ -263,11 +265,11 @@ public static boolean is_new(SensorRecord sensorRecord, long addativeOffset) {
                     .orderBy("timestamp desc")
                     .executeSingle();
             if(bgReading != null && Math.abs(bgReading.timestamp - timestamp) < (3*60*1000)) { //cool, so was it actually within 4 minutes of that bg reading?
-                Log.w(TAG, "Old Reading");
+                Log.w(TAG, "isNew; Old Reading");
                 return false;
             }
         }
-        Log.w(TAG, "New Reading");
+        Log.w(TAG, "isNew: New Reading");
         return true;
     }
 
@@ -277,6 +279,7 @@ public static BgReading create(double raw_data, double filtered_data, Context co
         if (sensor != null) {
             Calibration calibration = Calibration.last();
             if (calibration == null) {
+                Log.d(TAG,"create: No calibration yet");
                 bgReading.sensor = sensor;
                 bgReading.sensor_uuid = sensor.uuid;
                 bgReading.raw_data = (raw_data / 1000);
@@ -292,7 +295,7 @@ public static BgReading create(double raw_data, double filtered_data, Context co
                 bgReading.save();
                 bgReading.perform_calculations();
             } else {
-
+                Log.d(TAG,"Calibrations, so doing everything");
                 bgReading.sensor = sensor;
                 bgReading.sensor_uuid = sensor.uuid;
                 bgReading.calibration = calibration;
@@ -323,6 +326,70 @@ public static BgReading create(double raw_data, double filtered_data, Context co
                 }
 
                 bgReading.calculated_value = Math.min(400, Math.max(40, bgReading.calculated_value));
+                Log.w(TAG, "create: NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
+
+                bgReading.save();
+                bgReading.perform_calculations();
+                Notifications.getInstance(context).notificationSetter(context);
+                BgSendQueue.addToQueue(bgReading, "create", context);
+            }
+        }
+        Log.w("BG GSON: ",bgReading.toS());
+
+        return bgReading;
+    }
+    public static BgReading create(double raw_data, Context context, Long timestamp) {
+        BgReading bgReading = new BgReading();
+        Sensor sensor = Sensor.currentSensor();
+        if (sensor != null) {
+            Calibration calibration = Calibration.last();
+            if (calibration == null) {
+                bgReading.sensor = sensor;
+                bgReading.sensor_uuid = sensor.uuid;
+                bgReading.raw_data = (raw_data / 1000);
+                bgReading.filtered_data = (raw_data / 1000);
+                bgReading.timestamp = timestamp;
+                bgReading.uuid = UUID.randomUUID().toString();
+                bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
+                bgReading.synced = false;
+                bgReading.calibration_flag = false;
+
+                bgReading.calculateAgeAdjustedRawValue();
+
+                bgReading.save();
+                bgReading.perform_calculations();
+            } else {
+
+                bgReading.sensor = sensor;
+                bgReading.sensor_uuid = sensor.uuid;
+                bgReading.calibration = calibration;
+                bgReading.calibration_uuid = calibration.uuid;
+                bgReading.raw_data = (raw_data/1000);
+                bgReading.filtered_data = (raw_data/1000);
+                bgReading.timestamp = timestamp;
+                bgReading.uuid = UUID.randomUUID().toString();
+                bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
+                bgReading.synced = false;
+
+                bgReading.calculateAgeAdjustedRawValue();
+
+                if(calibration.check_in) {
+                    double firstAdjSlope = calibration.first_slope + (calibration.first_decay * (Math.ceil(new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
+                    double calSlope = (calibration.first_scale / firstAdjSlope)*1000;
+                    double calIntercept = ((calibration.first_scale * calibration.first_intercept) / firstAdjSlope)*-1;
+                    bgReading.calculated_value = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
+
+                } else {
+                    BgReading lastBgReading = BgReading.last();
+                    if (lastBgReading != null && lastBgReading.calibration != null) {
+                        if (lastBgReading.calibration_flag == true && ((lastBgReading.timestamp + (60000 * 20)) > bgReading.timestamp) && ((lastBgReading.calibration.timestamp + (60000 * 20)) > bgReading.timestamp)) {
+                            lastBgReading.calibration.rawValueOverride(BgReading.weightedAverageRaw(lastBgReading.timestamp, bgReading.timestamp, lastBgReading.calibration.timestamp, lastBgReading.age_adjusted_raw_value, bgReading.age_adjusted_raw_value), context);
+                        }
+                    }
+                    bgReading.calculated_value = ((calibration.slope * bgReading.age_adjusted_raw_value) + calibration.intercept);
+                }
+
+                bgReading.calculated_value = Math.min(400, Math.max(40, bgReading.calculated_value));
                 Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
 
                 bgReading.save();
@@ -559,12 +626,12 @@ public void find_new_curve() {
             b = (-y1*(x2+x3)/((x1-x2)*(x1-x3))-y2*(x1+x3)/((x2-x1)*(x2-x3))-y3*(x1+x2)/((x3-x1)*(x3-x2)));
             c = (y1*x2*x3/((x1-x2)*(x1-x3))+y2*x1*x3/((x2-x1)*(x2-x3))+y3*x1*x2/((x3-x1)*(x3-x2)));
 
-            Log.w(TAG, "BG PARABOLIC RATES: "+a+"x^2 + "+b+"x + "+c);
+            Log.w(TAG, "find_new_curve: BG PARABOLIC RATES: "+a+"x^2 + "+b+"x + "+c);
 
             save();
         } else if (last_3.size() == 2) {
 
-            Log.w(TAG, "Not enough data to calculate parabolic rates - assume Linear");
+            Log.w(TAG, "find_new_curve: Not enough data to calculate parabolic rates - assume Linear");
                 BgReading latest = last_3.get(0);
                 BgReading second_latest = last_3.get(1);
 
@@ -584,7 +651,7 @@ public void find_new_curve() {
             Log.w(TAG, ""+latest.a+"x^2 + "+latest.b+"x + "+latest.c);
                 save();
             } else {
-            Log.w(TAG, "Not enough data to calculate parabolic rates - assume static data");
+            Log.w(TAG, "find_new_curve: Not enough data to calculate parabolic rates - assume static data");
             a = 0;
             b = 0;
             c = calculated_value;
@@ -598,7 +665,7 @@ public void calculateAgeAdjustedRawValue(){
         double adjust_for = (86400000 * 1.9) - time_since_sensor_started;
         if (adjust_for > 0) {
             age_adjusted_raw_value = (((.45) * (adjust_for / (86400000 * 1.9))) * raw_data) + raw_data;
-            Log.w("RAW VALUE ADJUSTMENT: ", "FROM:" + raw_data + " TO: " + age_adjusted_raw_value);
+            Log.w(TAG, "calculateAgeAdjustedRawValue: RAW VALUE ADJUSTMENT FROM:" + raw_data + " TO: " + age_adjusted_raw_value);
         } else {
             age_adjusted_raw_value = raw_data;
         }
@@ -621,7 +688,7 @@ public void find_new_raw_curve() {
             rb = (-y1*(x2+x3)/((x1-x2)*(x1-x3))-y2*(x1+x3)/((x2-x1)*(x2-x3))-y3*(x1+x2)/((x3-x1)*(x3-x2)));
             rc = (y1*x2*x3/((x1-x2)*(x1-x3))+y2*x1*x3/((x2-x1)*(x2-x3))+y3*x1*x2/((x3-x1)*(x3-x2)));
 
-            Log.w(TAG, "RAW PARABOLIC RATES: "+ra+"x^2 + "+rb+"x + "+rc);
+            Log.w(TAG, "find_new_raw_curve: RAW PARABOLIC RATES: "+ra+"x^2 + "+rb+"x + "+rc);
             save();
         } else if (last_3.size() == 2) {
             BgReading latest = last_3.get(0);
@@ -639,12 +706,12 @@ public void find_new_raw_curve() {
             ra = 0;
             rc = -1 * ((latest.rb * x1) - y1);
 
-            Log.w(TAG, "Not enough data to calculate parabolic rates - assume Linear data");
+            Log.w(TAG, "find_new_raw_curve: Not enough data to calculate parabolic rates - assume Linear data");
 
             Log.w(TAG, "RAW PARABOLIC RATES: "+ra+"x^2 + "+rb+"x + "+rc);
             save();
         } else {
-            Log.w(TAG, "Not enough data to calculate parabolic rates - assume static data");
+            Log.w(TAG, "find_new_raw_curve: Not enough data to calculate parabolic rates - assume static data");
             BgReading latest_entry = BgReading.lastNoSenssor();
             ra = 0;
             rb = 0;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
index 31af819..485f10c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
@@ -8,6 +8,8 @@
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
 
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.util.Date;
 import java.util.UUID;
 
@@ -17,16 +19,16 @@
 
 @Table(name = "TransmitterData", id = BaseColumns._ID)
 public class TransmitterData extends Model {
-    private final static String TAG = BgReading.class.getSimpleName();
+    private final static String TAG = TransmitterData.class.getSimpleName();
 
     @Column(name = "timestamp", index = true)
     public long timestamp;
 
     @Column(name = "raw_data")
     public double raw_data;
-//
-//    @Column(name = "filtered_data")
-//    public double filtered_data;
+
+    @Column(name = "filtered_data")
+    public double filtered_data;
 
     @Column(name = "sensor_battery_level")
     public int sensor_battery_level;
@@ -35,31 +37,58 @@
     public String uuid;
 
     public static TransmitterData create(byte[] buffer, int len, Long timestamp) {
-                StringBuilder data_string = new StringBuilder();
-        if (len < 6) { return null; };
-
-        for (int i = 0; i < len; ++i) {
-            data_string.append((char) buffer[i]);
-        }
-        String[] data = data_string.toString().split("\\s+");
-
-        randomDelay(100, 2000);
-        TransmitterData lastTransmitterData = TransmitterData.last();
-        if (lastTransmitterData != null && lastTransmitterData.raw_data == Integer.parseInt(data[0]) && Math.abs(lastTransmitterData.timestamp - timestamp) < (10000)) { //Stop allowing duplicate data, its bad!
+        if (len < 6) {
             return null;
         }
-
-        TransmitterData transmitterData = new TransmitterData();
-        if(data.length > 1) {
-            transmitterData.sensor_battery_level = Integer.parseInt(data[1]);
+        if (buffer[0] == 0x11 && buffer[1] == 0x00) {
+            //this is a dexbridge packet.  Process accordingly.
+            Log.w(TAG, "create Processing a Dexbridge packet");
+            ByteBuffer txData = ByteBuffer.allocate(len);
+            txData.order(ByteOrder.LITTLE_ENDIAN);
+            txData.put(buffer, 0, len);
+            TransmitterData transmitterData = new TransmitterData();
+            transmitterData.raw_data = txData.getInt(2);
+            transmitterData.filtered_data = txData.getInt(6);
+            transmitterData.sensor_battery_level = txData.get(10);
+            transmitterData.timestamp = timestamp;
+            transmitterData.uuid = UUID.randomUUID().toString();
+
+            transmitterData.save();
+            Log.w(TAG, "Created transmitterData record with Raw value of " + transmitterData.raw_data + " and Filtered value of " + transmitterData.filtered_data + " at " + transmitterData.timestamp);
+            return transmitterData;
+        } else {
+            //this is NOT a dexbridge packet.  Process accordingly.
+            Log.w(TAG, "create Processing a BTWixel or IPWixel packet");
+            StringBuilder data_string = new StringBuilder();
+            if (len < 6) {
+                return null;
+            }
+
+            for (int i = 0; i < len; ++i) {
+                data_string.append((char) buffer[i]);
+            }
+            String[] data = data_string.toString().split("\\s+");
+
+            randomDelay(100, 2000);
+            TransmitterData lastTransmitterData = TransmitterData.last();
+            if (lastTransmitterData != null && lastTransmitterData.raw_data == Integer.parseInt(data[0]) && Math.abs(lastTransmitterData.timestamp - timestamp) < (10000)) { //Stop allowing duplicate data, its bad!
+                return null;
+            }
+
+            TransmitterData transmitterData = new TransmitterData();
+            if (data.length > 1) {
+                transmitterData.sensor_battery_level = Integer.parseInt(data[1]);
+            }
+            if (Integer.parseInt(data[0]) < 1000) {
+                return null;
+            } // Sometimes the HM10 sends the battery level and readings in separate transmissions, filter out these incomplete packets!
+            transmitterData.raw_data = Integer.parseInt(data[0]);
+            transmitterData.timestamp = timestamp;
+            transmitterData.uuid = UUID.randomUUID().toString();
+
+            transmitterData.save();
+            return transmitterData;
         }
-        if (Integer.parseInt(data[0]) < 1000) { return null; } // Sometimes the HM10 sends the battery level and readings in separate transmissions, filter out these incomplete packets!
-        transmitterData.raw_data = Integer.parseInt(data[0]);
-        transmitterData.timestamp = timestamp;
-        transmitterData.uuid = UUID.randomUUID().toString();
-
-        transmitterData.save();
-        return transmitterData;
     }
 
     public static TransmitterData create(int raw_data ,int sensor_battery_level, long timestamp) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
index 105a071..d2c9477 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
@@ -79,7 +79,7 @@ public NavDrawerBuilder(Context aContext) {
             options.add("Stop Sensor");
         } else { options.add("Start Sensor"); }
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isBTShare(context)) {
+            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isDexbridgeWixel(context)|| CollectionServiceStarter.isBTShare(context)) {
                 options.add("Scan for BT");
             }
         }
@@ -136,7 +136,7 @@ public NavDrawerBuilder(Context aContext) {
             options.add(new Intent(context, StopSensor.class));
         } else { options.add(new Intent(context, StartNewSensor.class)); }
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isBTShare(context)) {
+            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isDexbridgeWixel(context)|| CollectionServiceStarter.isBTShare(context)) {
                 options.add(new Intent(context, BluetoothScan.class));
             }
         }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 5d42ba8..99d3297 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -38,7 +38,6 @@
 import android.preference.PreferenceManager;
 import android.util.Log;
 
-import com.activeandroid.query.Select;
 import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
 import com.eveningoutpost.dexdrip.Models.BgReading;
 import com.eveningoutpost.dexdrip.Sensor;
@@ -48,13 +47,18 @@
 import com.eveningoutpost.dexdrip.Models.TransmitterData;
 
 import java.nio.charset.Charset;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
+import java.util.LinkedList;
+import java.util.Queue;
 import java.util.UUID;
-
 import static com.activeandroid.ActiveAndroid.beginTransaction;
 import static com.activeandroid.ActiveAndroid.endTransaction;
 import static com.activeandroid.ActiveAndroid.setTransactionSuccessful;
+import com.activeandroid.query.Select;
 
 @TargetApi(Build.VERSION_CODES.KITKAT)
 public class DexCollectionService extends Service {
@@ -63,6 +67,7 @@
     private String mDeviceAddress;
     private boolean is_connected = false;
     SharedPreferences prefs;
+    private static byte bridgeBattery = 0;
 
     public DexCollectionService dexCollectionService;
 
@@ -73,9 +78,18 @@
     private ForegroundServiceStarter foregroundServiceStarter;
     private int mConnectionState = STATE_DISCONNECTED;
     private BluetoothDevice device;
+    private BluetoothGattCharacteristic mCharacteristic;
+    private BluetoothGattService mService;
+    //queues for GattDescriptor and GattCharacteristic to ensure we get all messages and can clear the the message once it is processed.
+    private Queue<BluetoothGattDescriptor> descriptorWriteQueue = new LinkedList<BluetoothGattDescriptor>();
+    private Queue<BluetoothGattCharacteristic> characteristicReadQueue = new LinkedList<BluetoothGattCharacteristic>();
+    //int mStartMode;
+    long lastPacketTime;
+    private static byte[] lastdata = null;
 
     private Context mContext = null;
 
+
     private static final int STATE_DISCONNECTED = BluetoothProfile.STATE_DISCONNECTED;
     private static final int STATE_DISCONNECTING = BluetoothProfile.STATE_DISCONNECTING;
     private static final int STATE_CONNECTING = BluetoothProfile.STATE_CONNECTING;
@@ -87,7 +101,8 @@
 
     @Override
     public IBinder onBind(Intent intent) {
-        throw new UnsupportedOperationException("Not yet implemented");
+        //throw new UnsupportedOperationException("Not yet implemented");
+        return null;
     }
 
     @Override
@@ -95,18 +110,21 @@ public void onCreate() {
         foregroundServiceStarter = new ForegroundServiceStarter(getApplicationContext(), this);
         foregroundServiceStarter.start();
         mContext = getApplicationContext();
+
         dexCollectionService = this;
         prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
         listenForChangeInSettings();
+        Log.w(TAG, "onCreate: STARTING SERVICE");
     }
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
-        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT){
+        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            Log.w(TAG,"onStartCommand: Unsupported Android Version");
             stopSelf();
             return START_NOT_STICKY;
         }
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext()) || CollectionServiceStarter.isDexbridgeWixel(getApplicationContext())) {
             setFailoverTimer();
         } else {
             stopSelf();
@@ -118,15 +136,17 @@ public int onStartCommand(Intent intent, int flags, int startId) {
 
     @Override
     public void onDestroy() {
+        Log.w(TAG, "onDestroy entered");
         super.onDestroy();
-        close();
+        //close();
         foregroundServiceStarter.stop();
         setRetryTimer();
         Log.w(TAG, "SERVICE STOPPED");
     }
+
     public SharedPreferences.OnSharedPreferenceChangeListener prefListener = new SharedPreferences.OnSharedPreferenceChangeListener() {
         public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
-            if(key.compareTo("run_service_in_foreground") == 0) {
+            if (key.compareTo("run_service_in_foreground") == 0) {
                 Log.e("FOREGROUND", "run_service_in_foreground changed!");
                 if (prefs.getBoolean("run_service_in_foreground", false)) {
                     foregroundServiceStarter = new ForegroundServiceStarter(getApplicationContext(), dexCollectionService);
@@ -140,34 +160,70 @@ public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
         }
     };
 
+    public static byte getBridgeBattery() {
+        return bridgeBattery;
+    }
+
+
+    public boolean isUnitsMmol() {
+        return (PreferenceManager.getDefaultSharedPreferences(this).getString("units", "mmol").compareTo("mmol") != 0);
+    }
+
+    public static String getBridgeBatteryAsString() {
+        return String.format("%d", bridgeBattery);
+    }
+
     public void listenForChangeInSettings() {
         prefs.registerOnSharedPreferenceChangeListener(prefListener);
     }
 
     public void setRetryTimer() {
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
-            long retry_in = (1000 * 60 * 2);
-            Log.d(TAG, "Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext()) || CollectionServiceStarter.isDexbridgeWixel(getApplicationContext())) {
+            long retry_in = (1000 * 62);
+            Log.d(TAG, "setRetryTimer: Restarting in: " + (retry_in / 1000) + " seconds");
             Calendar calendar = Calendar.getInstance();
             AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            alarm.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
         }
     }
 
     public void setFailoverTimer() { //Sometimes it gets stuck in limbo on 4.4, this should make it try again
-        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext()) || CollectionServiceStarter.isDexbridgeWixel(getApplicationContext())) {
             long retry_in = (1000 * 60 * 5);
-            Log.d(TAG, "Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+            Log.d(TAG, "setFailoverTimer: Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
             Calendar calendar = Calendar.getInstance();
             AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            alarm.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
         } else {
             stopSelf();
         }
     }
 
-
-
+    /*    public void listenForChangeInSettings() {
+            SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() {
+                public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
+                    if (key.compareTo("run_service_in_foreground") == 0) {
+                        if (prefs.getBoolean("run_service_in_foreground", false)) {
+                            foregroundServiceStarter = new ForegroundServiceStarter(getApplicationContext(), dexCollectionService);
+                            foregroundServiceStarter.start();
+                            Log.w(TAG, "listenForChangeInSettings: Moving to foreground");
+                            setRetryTimer();
+                        } else {
+                            dexCollectionService.stopForeground(true);
+                            Log.w(TAG, "listenForChangeInSettings: Removing from foreground");
+                            setRetryTimer();
+                        }
+                    }
+                    if (key.compareTo("dex_collection_method") == 0) {
+                        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
+                        collectionServiceStarter.start(getApplicationContext());
+                    }
+                }
+            };
+            prefs = PreferenceManager.getDefaultSharedPreferences(mContext);
+            prefs.registerOnSharedPreferenceChangeListener(listener);
+        }
+    */
     public void attemptConnection() {
         mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
         if (mBluetoothManager != null) {
@@ -182,7 +238,7 @@ public void attemptConnection() {
                     }
                 }
 
-                Log.w(TAG, "Connection state: " + mConnectionState);
+                Log.w(TAG, "attemptConnection: Connection state: " + mConnectionState);
                 if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
                     ActiveBluetoothDevice btDevice = ActiveBluetoothDevice.first();
                     if (btDevice != null) {
@@ -194,7 +250,7 @@ public void attemptConnection() {
                         }
                     }
                 } else if (mConnectionState == STATE_CONNECTED) { //WOOO, we are good to go, nothing to do here!
-                    Log.w(TAG, "Looks like we are already connected, going to read!");
+                    Log.w(TAG, "attemptConnection: Looks like we are already connected, going to read!");
                     return;
                 }
             }
@@ -208,12 +264,12 @@ public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState
             if (newState == BluetoothProfile.STATE_CONNECTED) {
                 mConnectionState = STATE_CONNECTED;
                 ActiveBluetoothDevice.connected();
-                Log.w(TAG, "Connected to GATT server.");
+                Log.w(TAG, "onConnectionStateChange: Connected to GATT server.");
                 mBluetoothGatt.discoverServices();
             } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                 mConnectionState = STATE_DISCONNECTED;
                 ActiveBluetoothDevice.disconnected();
-                Log.w(TAG, "Disconnected from GATT server.");
+                Log.w(TAG, "onConnectionStateChange: Disconnected from GATT server.");
                 setRetryTimer();
             }
         }
@@ -224,76 +280,189 @@ public void onServicesDiscovered(BluetoothGatt gatt, int status) {
                 BluetoothGattService gattService = mBluetoothGatt.getService(xDripDataService);
                 if (gattService != null) {
                     BluetoothGattCharacteristic gattCharacteristic = gattService.getCharacteristic(xDripDataCharacteristic);
-                    if (gattCharacteristic != null ) {
+                    if (gattCharacteristic != null) {
                         final int charaProp = gattCharacteristic.getProperties();
-
                         if ((charaProp | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {
-                            mBluetoothGatt.setCharacteristicNotification(gattCharacteristic, true);
+                            if ((charaProp | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {
+                                mBluetoothGatt.setCharacteristicNotification(gattCharacteristic, true);
+                            } else {
+                                Log.e(TAG, "onServicesDiscovered: characteristic " + gattCharacteristic.getUuid() + " doesn't have notify properties");
+                            }
                         } else {
-                            Log.e(TAG, "characteristic " + gattCharacteristic.getUuid() + " doesn't have notify properties");
+                            Log.e(TAG, "onServicesDiscovered: characteristic " + xDripDataCharacteristic + " not found");
                         }
                     } else {
-                        Log.e(TAG, "characteristic " + xDripDataCharacteristic + " not found");
+                        Log.e(TAG, "onServicesDiscovered: service " + xDripDataService + " not found");
+                        //Log.v(TAG, "onServicesDiscovered: Already have that service");
                     }
-                } else {
-                    Log.e(TAG, "service " + xDripDataCharacteristic + " not found");
+                    Log.w(TAG, "onServicesDiscovered received success: " + status);
                 }
+            } else {
+                Log.w(TAG, "onServicesDiscovered received: " + status);
             }
         }
 
         @Override
-        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
-            final byte[] data = characteristic.getValue();
-            if (data != null && data.length > 0) { setSerialDataToTransmitterRawData(data, data.length); }
+        public void onCharacteristicRead(BluetoothGatt gatt,
+                                         BluetoothGattCharacteristic characteristic,
+                                         int status) {
+            Log.w(TAG, "onCharacteristicRead entered.");
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
+            } else {
+                Log.w(TAG, "onCharacteristicRead error: " + status);
+            }
+            if (characteristicReadQueue.size() > 0)
+                mBluetoothGatt.readCharacteristic(characteristicReadQueue.element());
+            characteristicReadQueue.remove();
+            Log.w(TAG, "onCharacteristicRead exited.");
+        }
+
+        @Override
+        public void onCharacteristicChanged(BluetoothGatt gatt,
+                                            BluetoothGattCharacteristic characteristic) {
+            //final byte[] data;
+            Log.w(TAG, "onCharacteristicChanged entered");
+            mCharacteristic = characteristic;
+            //data = characteristic.getValue();
+            //if(lastdata == null) lastdata = characteristic.getValue();
+            //if(Arrays.equals(lastdata, data) && lastdata != null) {
+            //    Log.w(TAG, "onCharacteristicChanged: duplicate packet.  Ignoring");
+            //    return;
+            //}
+            Log.w(TAG, "onCharacteristicChanged: new packet.");
+            //lastdata = data.clone();;
+            characteristicReadQueue.add(characteristic);
+            broadcastUpdate(ACTION_DATA_AVAILABLE, characteristicReadQueue.poll());
+        }
+
+        @Override
+        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor,
+                                      int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                Log.d(TAG, "onDescriptorWrite: Wrote GATT Descriptor successfully.");
+            } else {
+                Log.d(TAG, "onDescriptorWrite: Error writing GATT Descriptor: " + status);
+            }
+            descriptorWriteQueue.remove();  //pop the item that we just finishing writing
+            if (descriptorWriteQueue.size() > 0) // if there is more to write, do it!
+                mBluetoothGatt.writeDescriptor(descriptorWriteQueue.element());
+             /* else if(characteristicReadQueue.size() > 0)
+              mBluetoothGatt.readCharacteristic(characteristicReadQueue.element());
+             */
         }
     };
 
+
+    private void broadcastUpdate(final String action,
+                                 final BluetoothGattCharacteristic characteristic) {
+        Log.w(TAG, "broadcastUpdate got action: " + action + ", characteristic: " + characteristic.toString());
+        final byte[] data = characteristic.getValue();
+        Calendar c = Calendar.getInstance();
+        long secondsNow = c.getTimeInMillis();
+        if (secondsNow - lastPacketTime > 60000) {
+            lastdata = null;
+        }
+        if (lastdata != null) {
+            if (data != null && data.length > 0 && !Arrays.equals(lastdata, data)) {
+                Log.v(TAG, "broadcastUpdate: new data.");
+                setSerialDataToTransmitterRawData(data, data.length);
+                lastdata = data;
+            } else if (Arrays.equals(lastdata, data)) {
+                Log.v(TAG, "broadcastUpdate: duplicate data, ignoring");
+                //return;
+            }
+        } else if (data != null && data.length > 0) {
+            setSerialDataToTransmitterRawData(data, data.length);
+            lastdata = data;
+        }
+    }
+
+    private boolean sendBtMessage(final ByteBuffer message) {
+        //check mBluetoothGatt is available
+        Log.w(TAG, "sendBtMessage: entered");
+        if (mBluetoothGatt == null) {
+            Log.e(TAG, "sendBtMessage: lost connection");
+            return false;
+        }
+
+        byte[] value = message.array();
+        Log.w(TAG, "sendBtMessage: sending message");
+        mCharacteristic.setValue(value);
+
+        return mBluetoothGatt.writeCharacteristic(mCharacteristic);
+    }
+
+    private Integer convertSrc(final String Src) {
+        Integer res = 0;
+        res |= getSrcValue(Src.charAt(0)) << 20;
+        res |= getSrcValue(Src.charAt(1)) << 15;
+        res |= getSrcValue(Src.charAt(2)) << 10;
+        res |= getSrcValue(Src.charAt(3)) << 5;
+        res |= getSrcValue(Src.charAt(4));
+        return res;
+    }
+
+    private int getSrcValue(char ch) {
+        int i;
+        char[] cTable = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'W', 'X', 'Y'};
+        for (i = 0; i < cTable.length; i++) {
+            if (cTable[i] == ch) break;
+        }
+        return i;
+    }
+
     public boolean connect(final String address) {
-        Log.w(TAG, "going to connect to device at address" + address);
+        Log.w(TAG, "connect: going to connect to device at address" + address);
         if (mBluetoothAdapter == null || address == null) {
-            Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
+            Log.w(TAG, "connect: BluetoothAdapter not initialized or unspecified address.");
             setRetryTimer();
             return false;
         }
         if (mBluetoothGatt != null) {
-            Log.w(TAG, "BGatt isnt null, Closing.");
+            Log.w(TAG, "connect: mBluetoothGatt isnt null, Closing.");
             mBluetoothGatt.close();
             mBluetoothGatt = null;
         }
         device = mBluetoothAdapter.getRemoteDevice(address);
-        if (device == null) {
-            Log.w(TAG, "Device not found.  Unable to connect.");
+/*        if (device == null) {
+            Log.w(TAG, "connect: Device not found.  Unable to connect.");
             setRetryTimer();
             return false;
-        }
-        Log.w(TAG, "Trying to create a new connection.");
+        } */
+        Log.w(TAG, "connect: Trying to create a new connection.");
         mBluetoothGatt = device.connectGatt(getApplicationContext(), true, mGattCallback);
         mConnectionState = STATE_CONNECTING;
         return true;
     }
 
-    public void disconnect() {
-        if ( mBluetoothGatt == null) { return; }
+/*    public void disconnect() {
+        if (mBluetoothGatt == null) {
+            return;
+        }
+        Log.d(TAG, "disconnect: Gatt Disconnect");
         mBluetoothGatt.disconnect();
-        Log.d(TAG, "Gatt Disconnect");
-    }
+    }*/
+
     public void close() {
+        Log.w(TAG, "close: Closing Connection");
+        //disconnect();
         if (mBluetoothGatt == null) {
             return;
         }
         mBluetoothGatt.close();
         setRetryTimer();
         mBluetoothGatt = null;
+        mCharacteristic = null;
         mConnectionState = STATE_DISCONNECTED;
     }
 
     public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
         try {
-            Log.w(TAG, "received some data: " + new String(buffer, 0, len, Charset.forName("ISO-8859-1")));
+            Log.w(TAG, "setSerialDataToTransmitterRawData: received some data: " + new String(buffer, 0, len, Charset.forName("ISO-8859-1")));
         } catch (Exception ex) {
-            Log.w(TAG, "received some data!");
+            Log.w(TAG, "setSerialDataToTransmitterRawData: received some data!");
         }
-
         PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
         PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                 "ReceivedReading");
@@ -302,25 +471,106 @@ public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
             beginTransaction();
             try {
                 long timestamp = new Date().getTime();
-                TransmitterData transmitterData = TransmitterData.create(buffer, len, timestamp);
-                if (transmitterData != null) {
-                    Sensor sensor = Sensor.currentSensor();
-                    if (sensor != null) {
-                        sensor.latest_battery_level = transmitterData.sensor_battery_level;
-                        sensor.save();
-
-                        BgReading.create(transmitterData.raw_data, transmitterData.raw_data, this, timestamp);
+                if (CollectionServiceStarter.isDexbridgeWixel(getApplicationContext())) {
+                    Log.w(TAG, "setSerialDataToTransmitterRawData: Dealing with Dexbridge packet!");
+                    int DexSrc;
+                    int TransmitterID;
+                    String TxId;
+                    Calendar c = Calendar.getInstance();
+                    long secondsNow = c.getTimeInMillis();
+                    ByteBuffer tmpBuffer = ByteBuffer.allocate(len);
+                    tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
+                    tmpBuffer.put(buffer, 0, len);
+                    ByteBuffer txidMessage = ByteBuffer.allocate(6);
+                    txidMessage.order(ByteOrder.LITTLE_ENDIAN);
+                    if (buffer[0] == 0x07 && buffer[1] == -15) {
+                        //We have a Beacon packet.  Get the TXID value and compare with dex_txid
+                        Log.w(TAG, "setSerialDataToTransmitterRawData: Received Beacon packet.");
+                        //DexSrc starts at Byte 2 of a Beacon packet.
+                        DexSrc = tmpBuffer.getInt(2);
+                        TxId = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString("dex_txid", "00000");
+                        TransmitterID = convertSrc(TxId);
+                        if (TxId.compareTo("00000") != 0 && Integer.compare(DexSrc, TransmitterID) != 0) {
+                            Log.w(TAG, "setSerialDataToTransmitterRawData: TXID wrong.  Expected " + TransmitterID + " but got " + DexSrc);
+                            txidMessage.put(0, (byte) 0x06);
+                            txidMessage.put(1, (byte) 0x01);
+                            txidMessage.putInt(2, TransmitterID);
+                            sendBtMessage(txidMessage);
+                        }
+                        return;
+                    }
+                    if (buffer[0] == 0x11 && buffer[1] == 0x00) {
+                        //we have a data packet.  Check to see if the TXID is what we are expecting.
+                        Log.w(TAG, "setSerialDataToTransmitterRawData: Received Data packet");
+                        //make sure we are not processing a packet we already have
+                        if (secondsNow - lastPacketTime < 60000) {
+                            Log.v(TAG, "setSerialDataToTransmitterRawData: Received Duplicate Packet.  Exiting.");
+                            return;
+                        } else {
+                            lastPacketTime = secondsNow;
+                        }
+                        if (len >= 0x11) {
+                            //DexSrc starts at Byte 12 of a data packet.
+                            DexSrc = tmpBuffer.getInt(12);
+                            TxId = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString("dex_txid", "00000");
+                            TransmitterID = convertSrc(TxId);
+                            if (Integer.compare(DexSrc, TransmitterID) != 0) {
+                                Log.w(TAG, "TXID wrong.  Expected " + TransmitterID + " but got " + DexSrc);
+                                txidMessage.put(0, (byte) 0x06);
+                                txidMessage.put(1, (byte) 0x01);
+                                txidMessage.putInt(2, TransmitterID);
+                                sendBtMessage(txidMessage);
+                            }
+                            bridgeBattery = ByteBuffer.wrap(buffer).get(11);
+                            //All is OK, so process it.
+                            //first, tell the wixel it is OK to sleep.
+                            Log.d(TAG, "setSerialDataToTransmitterRawData: Sending Data packet Ack, to put wixel to sleep");
+                            ByteBuffer ackMessage = ByteBuffer.allocate(2);
+                            ackMessage.put(0, (byte) 0x02);
+                            ackMessage.put(1, (byte) 0xF0);
+                            sendBtMessage(ackMessage);
+                            timestamp = new Date().getTime();
+                            Log.v(TAG, "setSerialDataToTransmitterRawData: Creating TransmitterData at " + timestamp);
+                            TransmitterData transmitterData = TransmitterData.create(buffer, len, timestamp);
+                            if (transmitterData != null) {
+                                Sensor sensor = Sensor.currentSensor();
+                                if (sensor != null) {
+                                    sensor.latest_battery_level = transmitterData.sensor_battery_level;
+                                    sensor.save();
+
+                                    BgReading.create(transmitterData.raw_data, transmitterData.filtered_data, this, timestamp);
+                                    Intent intent = new Intent("com.eveningoutpost.dexdrip.DexCollectionService.SAVED_BG");
+                                    sendBroadcast(intent);
+
+                                } else {
+                                    Log.w(TAG, "setSerialDataToTransmitterRawData: No Active Sensor, Data only stored in Transmitter Data");
+                                }
+                            }
+                        }
                     } else {
-                        Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
+                        TransmitterData transmitterData = TransmitterData.create(buffer, len, timestamp);
+                        //TransmitterData transmitterData = TransmitterData.create(buffer, len);
+                        if (transmitterData != null) {
+                            Sensor sensor = Sensor.currentSensor();
+                            if (sensor != null) {
+                                sensor.latest_battery_level = transmitterData.sensor_battery_level;
+                                sensor.save();
+
+                                BgReading bgReading = BgReading.create(transmitterData.raw_data, transmitterData.filtered_data, this, timestamp);
+                                Intent intent = new Intent("com.eveningoutpost.dexdrip.DexCollectionService.SAVED_BG");
+                                sendBroadcast(intent);
+                            } else {
+                                Log.w(TAG, "setSerialDataToTransmitterRawData: No Active Sensor, Data only stored in Transmitter Data");
+                            }
+                        }
                     }
                 }
                 setTransactionSuccessful();
-            } finally {
+            }finally{
                 endTransaction();
             }
         } finally {
             wakeLock.release();
         }
-
     }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
index 2c41323..3438025 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
@@ -297,6 +297,8 @@ public String unitized_string(double value) {
                 return df.format(value);
             } else {
                 df.setMaximumFractionDigits(1);
+                //next line ensures mmol/l value is XX.x always.  Required by PebbleSync, and probably not a bad idea.
+                df.setMinimumFractionDigits(1);
                 return df.format(mmolConvert(value));
             }
         } else if (value > 12) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
index 11824fd..63a022a 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
@@ -15,6 +15,7 @@
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
+import com.eveningoutpost.dexdrip.Home;
 import com.eveningoutpost.dexdrip.Models.BgReading;
 import com.eveningoutpost.dexdrip.ShareModels.ShareRest;
 import com.eveningoutpost.dexdrip.widgetUpdateService;
@@ -39,6 +40,10 @@
     @Column(name = "operation_type")
     public String operation_type;
 
+    private static Context mContext = Home.getContext();
+
+    private static PebbleSync pebbleSync;
+
     public static BgSendQueue nextBgJob() {
         return new Select()
                 .from(BgSendQueue.class)
@@ -114,7 +119,7 @@ public static void addToQueue(BgReading bgReading, String operation_type, Contex
             }
 
             if (prefs.getBoolean("broadcast_to_pebble", false)) {
-                PebbleSync pebbleSync = new PebbleSync();
+                PebbleSync pebbleSync = new PebbleSync(mContext);
                 pebbleSync.sendData(context, bgReading);
             }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
index 1e09358..c4ef168 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
@@ -30,6 +30,14 @@ public static boolean isBTWixel(Context context) {
         }
         return false;
     }
+    public static boolean isDexbridgeWixel(Context context) {
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String collection_method = prefs.getString("dex_collection_method", "DexbridgeWixel");
+        if(collection_method.compareTo("DexbridgeWixel") == 0) {
+            return true;
+        }
+        return false;
+    }
     public static boolean isBTShare(Context context) {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
         String collection_method = prefs.getString("dex_collection_method", "BluetoothWixel");
@@ -57,7 +65,7 @@ public void start(Context context) {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mContext);
         String collection_method = prefs.getString("dex_collection_method", "BluetoothWixel");
 
-        if(isBTWixel(context)) {
+        if(isBTWixel(context)||isDexbridgeWixel(context)) {
             Log.d("DexDrip", "Starting bt wixel collector");
             stopWifWixelThread();
             stopBtShareService();
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
index e829e7f..1805fe2 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
@@ -4,19 +4,23 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.BatteryManager;
+import android.preference.PreferenceManager;
 import android.util.Log;
 
 import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.Services.DexCollectionService;
 import com.getpebble.android.kit.PebbleKit;
 import com.getpebble.android.kit.util.PebbleDictionary;
 
 import java.util.Date;
+import java.util.TimeZone;
 import java.util.UUID;
 
 /**
  * Created by THE NIGHTSCOUT PROJECT CONTRIBUTORS (and adapted to fit the needs of this project)
  */
 public class PebbleSync {
+    private final static String TAG = PebbleSync.class.getSimpleName();
     //    CGM_ICON_KEY = 0x0,		// TUPLE_CSTRING, MAX 2 BYTES (10)
     //    CGM_BG_KEY = 0x1,		// TUPLE_CSTRING, MAX 4 BYTES (253 OR 22.2)
     //    CGM_TCGM_KEY = 0x2,		// TUPLE_INT, 4 BYTES (CGM TIME)
@@ -36,16 +40,48 @@
     private Context mContext;
     private BgGraphBuilder bgGraphBuilder;
     private BgReading mBgReading;
+    private static int lastTransactionId;
+    public PebbleSync(Context context){
+        this.mContext = context;
+        mBgReading = null;
+        init();
+    }
+    private void init() {
+        Log.i(TAG, "Initialising...");
+        Log.i(TAG, "configuring PebbleDataReceiver");
+
+        PebbleKit.registerReceivedDataHandler(mContext, new PebbleKit.PebbleDataReceiver(PEBBLEAPP_UUID) {
+            @Override
+            public void receiveData(final Context context, final int transactionId, final PebbleDictionary data) {
+                Log.d(TAG,"receiveData: transactionId is "+String.valueOf(transactionId));
+                if(lastTransactionId == 0 || transactionId != lastTransactionId) {
+                    lastTransactionId = transactionId;
+                    Log.d(TAG, "Received Query. data: " + data.size());
+                    PebbleKit.sendAckToPebble(context, transactionId);
+                    sendData(context, mBgReading);
+                }
+            }
+        });
+    }
 
     public PebbleDictionary buildDictionary() {
         PebbleDictionary dictionary = new PebbleDictionary();
+        TimeZone tz = TimeZone.getDefault();
+        Date now = new Date();
+        int offsetFromUTC = tz.getOffset(now.getTime());
+        Log.v(TAG, "buildDictionary: slopeOrdinal-" + slopeOrdinal() + " bgReading-" + bgReading() + " now-"+ (int) now.getTime()/1000 + " bgTime-" + (int) (mBgReading.timestamp / 1000) + " phoneTime-" + (int) (new Date().getTime() / 1000) + " bgDelta-" + bgDelta());
         dictionary.addString(ICON_KEY, slopeOrdinal());
         dictionary.addString(BG_KEY, bgReading());
-        dictionary.addUint32(RECORD_TIME_KEY, (int) (mBgReading.timestamp / 1000));
-        dictionary.addUint32(PHONE_TIME_KEY, (int) (new Date().getTime() / 1000));
+        dictionary.addUint32(RECORD_TIME_KEY, (int) (((mBgReading.timestamp + offsetFromUTC) / 1000)));
+        dictionary.addUint32(PHONE_TIME_KEY, (int) ((new Date().getTime() + offsetFromUTC) / 1000));
         dictionary.addString(BG_DELTA_KEY, bgDelta());
-        dictionary.addString(UPLOADER_BATTERY_KEY, phoneBattery());
-        dictionary.addString(NAME_KEY, "xDrip");
+        if(PreferenceManager.getDefaultSharedPreferences(mContext).getString("dex_collection_method", "DexbridgeWixel").compareTo("DexbridgeWixel")==0) {
+            dictionary.addString(UPLOADER_BATTERY_KEY, DexCollectionService.getBridgeBatteryAsString());
+            dictionary.addString(NAME_KEY, "Bridge");
+        } else {
+            dictionary.addString(UPLOADER_BATTERY_KEY, phoneBattery());
+            dictionary.addString(NAME_KEY, "Phone");
+        }
         return dictionary;
     }
 
@@ -61,11 +97,15 @@ public String bgReading() {
     }
 
     public String bgDelta() {
-        String deltaString = bgGraphBuilder.unitized_string((int)(mBgReading.calculated_value_slope * (5 * 60 * 1000)));
-        if(mBgReading.calculated_value_slope > 0.1) {
+        String deltaString;
+        if((PreferenceManager.getDefaultSharedPreferences(mContext).getString("units","mg/dl").compareTo("mg/dl") == 0)) {
+            deltaString = String.format("%.0f", mBgReading.calculated_value_slope * 360000);
+        } else {
+            deltaString = String.format("%.1f", (mBgReading.calculated_value_slope * 360000)*Constants.MGDL_TO_MMOLL);
+        }
+        Log.v(TAG,"bgDelta: "+ deltaString);
+        if(Float.valueOf(deltaString) > 0) {
             return ("+"+deltaString);
-        } else if(mBgReading.calculated_value_slope > -0.1 && mBgReading.calculated_value_slope < 0.1) {
-            return "0";
         } else {
             return deltaString;
         }
@@ -82,7 +122,7 @@ public String bgUnit() {
     public void sendDownload(PebbleDictionary dictionary) {
         if (PebbleKit.isWatchConnected(mContext)) {
             if (dictionary != null && mContext != null) {
-                Log.d("PEBBLE PUSHER", "Sending data to pebble");
+                Log.d(TAG, "sendDownload: Sending data to pebble");
                 PebbleKit.sendDataToPebble(mContext, PEBBLEAPP_UUID, dictionary);
             }
         }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/utils/Preferences.java b/app/src/main/java/com/eveningoutpost/dexdrip/utils/Preferences.java
index ca4ee22..337b96b 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/utils/Preferences.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/utils/Preferences.java
@@ -157,6 +157,7 @@ public void onCreate(Bundle savedInstanceState) {
 
 
             final Preference collectionMethod = findPreference("dex_collection_method");
+            final Preference dexTxId = findPreference("dex_collection_method");
             final Preference runInForeground = findPreference("run_service_in_foreground");
             final Preference wifiRecievers = findPreference("wifi_recievers_addresses");
             final Preference predictiveBG = findPreference("predictive_bg");
@@ -190,11 +191,12 @@ public void onCreate(Bundle savedInstanceState) {
             collectionMethod.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                 @Override
                 public boolean onPreferenceChange(Preference preference, Object newValue) {
-                    if(((String) newValue).compareTo("DexcomShare") != 0) { // NOT USING SHARE
+                    if (((String) newValue).compareTo("DexcomShare") != 0) { // NOT USING SHARE
                         collectionCategory.removePreference(shareKey);
                         otherCategory.removePreference(interpretRaw);
                         otherCategory.addPreference(predictiveBG);
                         alertsCategory.addPreference(calibrationAlertsScreen);
+                        if(((String) newValue).compareTo("DexbridgeWixel") == 0) collectionCategory.addPreference(dexTxId);
                     } else {
                         collectionCategory.addPreference(shareKey);
                         otherCategory.addPreference(interpretRaw);
@@ -202,12 +204,12 @@ public boolean onPreferenceChange(Preference preference, Object newValue) {
                         alertsCategory.removePreference(calibrationAlertsScreen);
                         prefs.edit().putBoolean("calibration_notifications", false).apply();
                     }
-                    if(((String) newValue).compareTo("BluetoothWixel") != 0 && ((String) newValue).compareTo("DexcomShare") != 0) {
+                    if (((String) newValue).compareTo("BluetoothWixel") != 0 && ((String) newValue).compareTo("DexcomShare") != 0) {
                         collectionCategory.removePreference(runInForeground);
                     } else {
                         collectionCategory.addPreference(runInForeground);
                     }
-                    if(((String) newValue).compareTo("WifiWixel") != 0) {
+                    if (((String) newValue).compareTo("WifiWixel") != 0) {
                         collectionCategory.removePreference(wifiRecievers);
                     } else {
                         collectionCategory.addPreference(wifiRecievers);
diff --git a/app/src/main/res/layout/activity_home.xml b/app/src/main/res/layout/activity_home.xml
index db2a857..db0deeb 100644
--- a/app/src/main/res/layout/activity_home.xml
+++ b/app/src/main/res/layout/activity_home.xml
@@ -58,6 +58,18 @@
                     android:paddingEnd="20dp"
                     android:textSize="50dp"
                     android:paddingTop="0dp" />
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceSmall"
+                    android:text="100%"
+                    android:id="@+id/textBridgeBattery"
+                    android:textStyle="normal"
+                    android:textSize="12sp"
+                    android:inputType="none"
+                    android:layout_below="@+id/notices"
+                    android:layout_alignParentStart="true" />
             </RelativeLayout>
 
             <lecho.lib.hellocharts.view.PreviewLineChartView
diff --git a/app/src/main/res/values/arrays.xml b/app/src/main/res/values/arrays.xml
index 664513a..ce7717a 100644
--- a/app/src/main/res/values/arrays.xml
+++ b/app/src/main/res/values/arrays.xml
@@ -2,12 +2,14 @@
 <resources>
     <string-array name="DexCollectionMethods">
         <item>Bluetooth Wixel</item>
+        <item>Dexbridge</item>
         <item>Wifi Wixel</item>
         <item>DexcomShare</item>
     </string-array>
 
     <string-array name="DexCollectionMethodValues">
         <item>BluetoothWixel</item>
+        <item>DexbridgeWixel</item>
         <item>WifiWixel</item>
         <item>DexcomShare</item>
     </string-array>
diff --git a/app/src/main/res/xml/pref_advanced_settings.xml b/app/src/main/res/xml/pref_advanced_settings.xml
index 48ab827..e07523e 100644
--- a/app/src/main/res/xml/pref_advanced_settings.xml
+++ b/app/src/main/res/xml/pref_advanced_settings.xml
@@ -9,12 +9,12 @@
             android:summary="@string/pref_summary_broadcast_enabled"
             android:defaultValue="false" >
         </SwitchPreference>
-        <!--<SwitchPreference-->
-            <!--android:title="Send to Pebble"-->
-            <!--android:key="broadcast_to_pebble"-->
-            <!--android:summary="If you have a pebble watch you can send bg data straight to it"-->
-            <!--android:defaultValue="false" >-->
-        <!--</SwitchPreference>-->
+        <SwitchPreference
+            android:title="Send to Pebble"
+            android:key="broadcast_to_pebble"
+            android:summary="If you have a pebble watch you can send bg data straight to it"
+            android:defaultValue="false">
+        </SwitchPreference>
         <CheckBoxPreference
             android:key="predictive_bg"
             android:title="Display Predictive Values"
diff --git a/app/src/main/res/xml/pref_data_source.xml b/app/src/main/res/xml/pref_data_source.xml
index 13ed671..be895cb 100644
--- a/app/src/main/res/xml/pref_data_source.xml
+++ b/app/src/main/res/xml/pref_data_source.xml
@@ -21,6 +21,11 @@
             android:summary="Running in foreground prevents android from killing the service and creates a notification with a trend line."
             android:defaultValue="false" />
         <EditTextPreference
+            android:key="dex_txid"
+            android:title="Dexcom Transmitter ID"
+            android:summary="ID of your Dexcom Transmitter, eg 12AB3"
+            android:defaultValue="00000" />
+        <EditTextPreference
             android:title="List of recievers"
             android:key="wifi_recievers_addresses"
             android:dialogTitle="@string/wifi_recievers_dialog_title"
diff --git a/xDrip-Experimental.iml b/xDrip-Experimental.iml
index 5669e97..4384bd9 100644
--- a/xDrip-Experimental.iml
+++ b/xDrip-Experimental.iml
@@ -14,8 +14,8 @@
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
       <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
       <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
       <excludeFolder url="file://$MODULE_DIR$/.gradle" />
     </content>

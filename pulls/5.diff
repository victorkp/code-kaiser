diff --git a/DexDrip.iml b/DexDrip.iml
index 6bca3c7..c3eb993 100644
--- a/DexDrip.iml
+++ b/DexDrip.iml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
   <component name="FacetManager">
     <facet type="java-gradle" name="Java-Gradle">
       <configuration>
@@ -12,10 +12,10 @@
     <output-test url="file://$MODULE_DIR$/build/classes/test" />
     <exclude-output />
     <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />
       <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
       <excludeFolder url="file://$MODULE_DIR$/.gradle" />
     </content>
     <orderEntry type="inheritedJdk" />
diff --git a/app/app.iml b/app/app.iml
index 30376dc..97fbbbc 100644
--- a/app/app.iml
+++ b/app/app.iml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="xDrip" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="xDrip-Experimental" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
   <component name="FacetManager">
     <facet type="android-gradle" name="Android-Gradle">
       <configuration>
@@ -12,9 +12,9 @@
         <option name="SELECTED_TEST_ARTIFACT" value="_android_test_" />
         <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
         <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugAndroidTest" />
         <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugAndroidTestSources" />
         <option name="ALLOW_USER_CONFIGURATION" value="false" />
         <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
         <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
@@ -25,7 +25,7 @@
   </component>
   <component name="NewModuleRootManager" inherit-compiler-output="false">
     <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <output-test url="file://$MODULE_DIR$/build/intermediates/classes/test/debug" />
+    <output-test url="file://$MODULE_DIR$/build/intermediates/classes/androidTest/debug" />
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
@@ -34,12 +34,12 @@
       <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
       <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
       <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/androidTest/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/androidTest/debug" type="java-test-resource" />
       <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
       <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
       <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
@@ -81,17 +81,22 @@
       <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
       <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
       <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
     </content>
     <orderEntry type="jdk" jdkName="Android API 21 Platform" jdkType="Android SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="library" exported="" name="android-support-v4" level="project" />
+    <orderEntry type="library" exported="" name="gson-2.3.1" level="project" />
     <orderEntry type="library" exported="" name="mongo-java-driver-2.10.1" level="project" />
     <orderEntry type="library" exported="" name="ActiveAndroid" level="project" />
+    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />
     <orderEntry type="library" exported="" name="usb-serial-for-android-v010" level="project" />
-    <orderEntry type="library" exported="" name="retrofit-1.7.1" level="project" />
+    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />
     <orderEntry type="library" exported="" name="pebblekit-2.6.0" level="project" />
+    <orderEntry type="library" exported="" name="retrofit-1.9.0" level="project" />
+    <orderEntry type="library" exported="" name="rxjava-1.0.0" level="project" />
+    <orderEntry type="library" exported="" name="acra-4.5.0" level="project" />
     <orderEntry type="library" exported="" name="hellocharts-library-1.1" level="project" />
-    <orderEntry type="library" exported="" name="gson-2.3" level="project" />
   </component>
 </module>
 
diff --git a/app/build.gradle b/app/build.gradle
index 17aad0e..e53ddf4 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -6,7 +6,7 @@ android {
 
     defaultConfig {
         applicationId "com.eveningoutpost.dexdrip"
-        minSdkVersion 17
+        minSdkVersion 19
         targetSdkVersion 21
         versionCode 1
         versionName "1.0"
@@ -17,8 +17,12 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.squareup.okhttp:okhttp:2.2.0'
+    testCompile 'com.squareup.okhttp:mockwebserver:2.2.0'
     compile 'com.google.code.gson:gson:2.3'
     compile 'org.mongodb:mongo-java-driver:2.10.1'
-    compile 'com.squareup.retrofit:retrofit:1.7.1'
+    compile 'com.squareup.retrofit:retrofit:1.9.0'
     compile 'com.getpebble:pebblekit:2.6.0@aar'
+    compile 'io.reactivex:rxjava:1.0.0'
+    compile 'ch.acra:acra:4.5.0'
 }
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 28d2eb8..f71a66c 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -2,7 +2,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.eveningoutpost.dexdrip" >
 
-    <permission android:name="com.eveningoutpost.dexdrip.permissions.RECEIVE_BG_ESTIMATE"/>
+    <permission android:name="com.eveningoutpost.dexdrip.permissions.RECEIVE_BG_ESTIMATE" />
 
     <uses-feature
         android:name="android.hardware.bluetooth_le"
@@ -20,9 +20,8 @@
     <uses-permission android:name="android.permission.WRITE_SETTINGS" />
     <uses-permission android:name="android.permission." />
 
-
     <application
-        android:name="com.activeandroid.app.Application"
+        android:name=".xdrip"
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
@@ -33,9 +32,9 @@
             android:value="DexDrip.db" />
         <meta-data
             android:name="AA_DB_VERSION"
-            android:value="20" />
+            android:value="24" />
 
-        <!-- <provider android:authorities="com.example" android:exported="false" android:name="com.activeandroid.content.ContentProvider" /> -->
+         <provider android:authorities="com.example" android:exported="false" android:name="com.activeandroid.content.ContentProvider" />
 
         <activity
             android:name=".Home"
@@ -43,10 +42,10 @@
             android:launchMode="singleInstance" >
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
-
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+
         <activity
             android:name=".BluetoothScan"
             android:label="@string/title_activity_bluetooth_scan" >
@@ -95,6 +94,7 @@
             android:enabled="true"
             android:exported="true" >
         </service>
+
         <service
             android:name=".ImportedLibraries.dexcom.SyncingService"
             android:enabled="true"
@@ -128,7 +128,6 @@
         <activity
             android:name=".CalibrationCheckInActivity"
             android:label="@string/title_activity_calibration_check_in" >
-
         </activity>
         <activity
             android:name=".UsbConnectedActivity"
@@ -136,11 +135,26 @@
             <intent-filter>
                 <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
             </intent-filter>
-
             <meta-data
                 android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED"
                 android:resource="@xml/device_filter" />
         </activity>
+
+        <service
+            android:name=".Services.DexShareCollectionService"
+            android:enabled="true"
+            android:exported="true" >
+        </service>
+
+        <activity
+            android:name=".ShareTest"
+            android:label="@string/title_activity_share_test" >
+        </activity>
+
+        <activity
+            android:name=".SystemStatus"
+            android:label="@string/title_activity_system_status" >
+        </activity>
     </application>
 
 </manifest>
diff --git a/app/src/main/assets/migrations/21.sql b/app/src/main/assets/migrations/21.sql
new file mode 100644
index 0000000..e878787
--- /dev/null
+++ b/app/src/main/assets/migrations/21.sql
@@ -0,0 +1 @@
+ALTER TABLE ActiveBluetoothDevice ADD COLUMN connected BOOLEAN;
diff --git a/app/src/main/assets/migrations/23.sql b/app/src/main/assets/migrations/23.sql
new file mode 100644
index 0000000..63b021c
--- /dev/null
+++ b/app/src/main/assets/migrations/23.sql
@@ -0,0 +1 @@
+ALTER TABLE BgReadings ADD COLUMN raw_calculated REAL;
diff --git a/app/src/main/assets/migrations/24.sql b/app/src/main/assets/migrations/24.sql
new file mode 100644
index 0000000..f59d28b
--- /dev/null
+++ b/app/src/main/assets/migrations/24.sql
@@ -0,0 +1 @@
+ALTER TABLE BgReadings ADD COLUMN hide_slope BOOLEAN;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/AddCalibration.java b/app/src/main/java/com/eveningoutpost/dexdrip/AddCalibration.java
index ddad3f4..f83c9d4 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/AddCalibration.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/AddCalibration.java
@@ -11,6 +11,7 @@
 import android.widget.EditText;
 
 import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
 
 public class AddCalibration extends Activity implements NavigationDrawerFragment.NavigationDrawerCallbacks {
@@ -21,6 +22,11 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        if(CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            Intent intent = new Intent(this, Home.class);
+            startActivity(intent);
+            finish();
+        }
         setContentView(R.layout.activity_add_calibration);
         addListenerOnButton();
     }
@@ -58,7 +64,7 @@ public void onClick(View v) {
                         value.setError("Calibration Can Not be blank");
                     }
                 } else {
-                    Log.w("CANNOT CALIBRATE WITHOUT CURRENT SENSOR", "ERROR");
+                    Log.w("CALERROR", "ERROR");
                 }
             }
         });
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/AutoStart.java b/app/src/main/java/com/eveningoutpost/dexdrip/AutoStart.java
index 8e96d3a..2839563 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/AutoStart.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/AutoStart.java
@@ -3,6 +3,7 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.util.Log;
 
 import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
@@ -12,7 +13,7 @@
 public class AutoStart extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
-        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter();
-        collectionServiceStarter.start(context);
+        Log.w("DexDrip", "Service auto starter, starting!");
+        CollectionServiceStarter.newStart(context);
     }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java b/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
index 8bd4f97..e17f39c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
@@ -24,6 +24,7 @@
 import com.activeandroid.query.Select;
 import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
 import com.eveningoutpost.dexdrip.Services.DexCollectionService;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
 import java.util.ArrayList;
 
@@ -50,8 +51,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
         ListView lv = (ListView)findViewById(android.R.id.list);
 
-        final BluetoothManager bluetooth_manager =
-                (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+        final BluetoothManager bluetooth_manager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
 
         bluetooth_adapter = bluetooth_manager.getAdapter();
         mHandler = new Handler();
@@ -64,6 +64,17 @@ protected void onCreate(Bundle savedInstanceState) {
         } else {
             has_bluetooth = true;
         }
+        if(bluetooth_manager == null) {
+            Toast.makeText(this, "This device does not seem to support bluetooth", Toast.LENGTH_LONG).show();
+        } else {
+            if(!bluetooth_manager.getAdapter().isEnabled()) {
+                Toast.makeText(this, "Bluetooth is turned off on this device currently", Toast.LENGTH_LONG).show();
+            } else {
+                if(android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2){
+                    Toast.makeText(this, "The android version of this device is not compatible with Bluetooth Low Energy", Toast.LENGTH_LONG).show();
+                }
+            }
+        }
         mLeDeviceListAdapter = new LeDeviceListAdapter();
         setListAdapter(mLeDeviceListAdapter);
 
@@ -103,7 +114,19 @@ public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
             case R.id.menu_scan:
                 scanLeDevice(true);
+                BluetoothManager bluetooth_manager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
                 Toast.makeText(this, "Scanning", Toast.LENGTH_LONG).show();
+                if(bluetooth_manager == null) {
+                    Toast.makeText(this, "This device does not seem to support bluetooth", Toast.LENGTH_LONG).show();
+                } else {
+                    if(!bluetooth_manager.getAdapter().isEnabled()) {
+                        Toast.makeText(this, "Bluetooth is turned off on this device currently", Toast.LENGTH_LONG).show();
+                    } else {
+                        if(android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2){
+                            Toast.makeText(this, "The android version of this device is not compatible with Bluetooth Low Energy", Toast.LENGTH_LONG).show();
+                        }
+                    }
+                }
                 return true;
 //            case R.id.menu_stop:
 //                Intent tableIntent = new Intent(this, RawDataTable.class);
@@ -141,8 +164,6 @@ protected void onListItemClick(ListView l, View v, int position, long id) {
         final BluetoothDevice device = mLeDeviceListAdapter.getDevice(position);
         if (device == null) return;
         Toast.makeText(this, R.string.connecting_to_device, Toast.LENGTH_LONG).show();
-        Intent intent = new Intent(this, Home.class);
-        Intent serviceIntent = new Intent(this, DexCollectionService.class);
 
         ActiveBluetoothDevice btDevice = new Select().from(ActiveBluetoothDevice.class)
                 .orderBy("_ID desc")
@@ -162,7 +183,8 @@ protected void onListItemClick(ListView l, View v, int position, long id) {
             bluetooth_adapter.stopLeScan(mLeScanCallback);
             is_scanning = false;
         }
-        startService(serviceIntent);
+        Intent intent = new Intent(this, Home.class);
+        CollectionServiceStarter.newStart(getApplicationContext());
         startActivity(intent);
         finish();
     }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/CalibrationOverride.java b/app/src/main/java/com/eveningoutpost/dexdrip/CalibrationOverride.java
index 4ff73a2..1477233 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/CalibrationOverride.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/CalibrationOverride.java
@@ -14,6 +14,7 @@
 import android.widget.Toast;
 
 import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
 
 public class CalibrationOverride extends Activity implements NavigationDrawerFragment.NavigationDrawerCallbacks {
@@ -23,10 +24,15 @@
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-            super.onCreate(savedInstanceState);
-            setContentView(R.layout.activity_calibration_override);
-            addListenerOnButton();
-            }
+        super.onCreate(savedInstanceState);
+        if(CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            Intent intent = new Intent(this, Home.class);
+            startActivity(intent);
+            finish();
+        }
+        setContentView(R.layout.activity_calibration_override);
+        addListenerOnButton();
+    }
 
     @Override
     protected void onResume(){
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/DoubleCalibrationActivity.java b/app/src/main/java/com/eveningoutpost/dexdrip/DoubleCalibrationActivity.java
index 68f0c58..5c33b48 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/DoubleCalibrationActivity.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/DoubleCalibrationActivity.java
@@ -14,6 +14,7 @@
 import android.widget.Toast;
 
 import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
 
 public class DoubleCalibrationActivity  extends Activity implements NavigationDrawerFragment.NavigationDrawerCallbacks {
@@ -24,6 +25,11 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        if(CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            Intent intent = new Intent(this, Home.class);
+            startActivity(intent);
+            finish();
+        }
         setContentView(R.layout.activity_double_calibration);
         addListenerOnButton();
     }
@@ -68,7 +74,7 @@ public void onClick(View v) {
                         value_1.setError("Calibration Can Not be blank");
                     }
                 } else {
-                    Log.w("CANNOT CALIBRATE WITHOUT CURRENT SENSOR", "ERROR");
+                    Log.w("DoubleCalibration", "ERROR");
                 }
             }
         });
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
index 7a36042..f314ef0 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
@@ -18,6 +18,7 @@
 import android.support.v4.widget.DrawerLayout;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.util.Log;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -60,6 +61,9 @@
     public boolean updateStuff;
     public boolean updatingPreviewViewport = false;
     public boolean updatingChartViewport = false;
+    boolean isBTWixel;
+    boolean isBTShare;
+    boolean isWifiWixel;
 
     public BgGraphBuilder bgGraphBuilder;
     BroadcastReceiver _broadcastReceiver;
@@ -68,16 +72,15 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
+        collectionServiceStarter.start(getApplicationContext());
         PreferenceManager.setDefaultValues(this, R.xml.pref_general, false);
         PreferenceManager.setDefaultValues(this, R.xml.pref_bg_notification, false);
         PreferenceManager.setDefaultValues(this, R.xml.pref_data_sync, false);
         PreferenceManager.setDefaultValues(this, R.xml.pref_wifi, false);
-
-
         prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
         checkEula();
         setContentView(R.layout.activity_home);
-
     }
 
     public void checkEula() {
@@ -93,10 +96,6 @@ public void checkEula() {
     protected void onResume(){
         super.onResume();
         checkEula();
-
-        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter();
-        collectionServiceStarter.start(getApplicationContext());
-
         _broadcastReceiver = new BroadcastReceiver() {
             @Override
             public void onReceive(Context ctx, Intent intent) {
@@ -108,6 +107,8 @@ public void onReceive(Context ctx, Intent intent) {
         newDataReceiver = new BroadcastReceiver() {
             @Override
             public void onReceive(Context ctx, Intent intent) {
+                holdViewport.set(0, 0, 0, 0);
+                setupCharts();
                 updateCurrentBgInfo();
             }
         };
@@ -197,37 +198,94 @@ public void updateCurrentBgInfo() {
         final TextView currentBgValueText = (TextView) findViewById(R.id.currentBgValueRealTime);
         final TextView notificationText = (TextView)findViewById(R.id.notices);
         notificationText.setText("");
-        boolean isBTWixel = CollectionServiceStarter.isBTWixel(getApplicationContext());
-        if((isBTWixel && ActiveBluetoothDevice.first() != null) || (!isBTWixel && WixelReader.IsConfigured(getApplicationContext()))) {
-            if (Sensor.isActive() && (Sensor.currentSensor().started_at + (60000 * 60 * 2)) < new Date().getTime()) {
-                if (BgReading.latest(2).size() > 1) {
-                    List<Calibration> calibrations = Calibration.latest(2);
-                    if (calibrations.size() > 1) {
-                        if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
-                            notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
-                        }
-                        displayCurrentInfo();
+        isBTWixel = CollectionServiceStarter.isBTWixel(getApplicationContext());
+        isBTShare = CollectionServiceStarter.isBTShare(getApplicationContext());
+        isWifiWixel = CollectionServiceStarter.isWifiWixel(getApplicationContext());
+        if(isBTShare) {
+            if((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
+                notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
+            } else {
+                String receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
+                if (receiverSn.compareTo("SM00000000") == 0 || receiverSn.length() == 0) {
+                    notificationText.setText("Please set your Dex Receiver Serial Number in App Settings");
+                } else {
+                    if (receiverSn.length() < 10) {
+                        notificationText.setText("Double Check Dex Receiver Serial Number, should be 10 characters, don't forget the letters");
                     } else {
-                        notificationText.setText("Please enter two calibrations to get started!");
+                        if (ActiveBluetoothDevice.first() == null) {
+                            notificationText.setText("Now pair with your Dexcom Share");
+                        } else {
+                            if (!Sensor.isActive()) {
+                                notificationText.setText("Now choose start your sensor in your settings");
+                            } else {
+                                displayCurrentInfo();
+                            }
+                        }
                     }
-                } else {
-                    notificationText.setText("Please wait, need 2 readings from transmitter first.");
                 }
-            } else if (Sensor.isActive() && ((Sensor.currentSensor().started_at + (60000 * 60 * 2))) >= new Date().getTime()) {
-                double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - (new Date().getTime())) / (60000) ;
-                notificationText.setText("Please wait while sensor warms up! ("+ String.format("%.2f", waitTime)+" minutes)");
-            } else {
-                notificationText.setText("Now start your sensor");
             }
-        } else {
-            if(isBTWixel) {
-                if((android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
-                    notificationText.setText("First pair with your BT device");
+        }
+        if(isBTWixel) {
+            if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
+                notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
+            } else {
+                if (ActiveBluetoothDevice.first() == null) {
+                    notificationText.setText("First pair with your BT device!");
                 } else {
-                    notificationText.setText("Your device has to be android 4.3 and up to support Bluetooth wixel");
+                    if (Sensor.isActive() && (Sensor.currentSensor().started_at + (60000 * 60 * 2)) < new Date().getTime()) {
+                        if (BgReading.latest(2).size() > 1) {
+                            List<Calibration> calibrations = Calibration.latest(2);
+                            if (calibrations.size() > 1) {
+                                if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
+                                    notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
+                                }
+                                displayCurrentInfo();
+                            } else {
+                                notificationText.setText("Please enter two calibrations to get started!");
+                            }
+                        } else {
+                            if(BgReading.latestUnCalculated(2).size() < 2) {
+                                notificationText.setText("Please wait, need 2 readings from transmitter first.");
+                            } else {
+                                List<Calibration> calibrations = Calibration.latest(2);
+                                if (calibrations.size() < 2) {
+                                    notificationText.setText("Please enter two calibrations to get started!");
+                                }
+                            }
+                        }
+                    } else if (Sensor.isActive() && ((Sensor.currentSensor().started_at + (60000 * 60 * 2))) >= new Date().getTime()) {
+                        double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - (new Date().getTime())) / (60000);
+                        notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
+                    } else {
+                        notificationText.setText("Now start your sensor");
+                    }
                 }
-            } else {
+            }
+        }
+        if(isWifiWixel) {
+            if (!WixelReader.IsConfigured(getApplicationContext())) {
                 notificationText.setText("First configure your wifi wixel reader ip addresses");
+            } else {
+                if (Sensor.isActive() && (Sensor.currentSensor().started_at + (60000 * 60 * 2)) < new Date().getTime()) {
+                    if (BgReading.latest(2).size() > 1) {
+                        List<Calibration> calibrations = Calibration.latest(2);
+                        if (calibrations.size() > 1) {
+                            if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
+                                notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
+                            }
+                            displayCurrentInfo();
+                        } else {
+                            notificationText.setText("Please enter two calibrations to get started!");
+                        }
+                    } else {
+                        notificationText.setText("Please wait, need 2 readings from transmitter first.");
+                    }
+                } else if (Sensor.isActive() && ((Sensor.currentSensor().started_at + (60000 * 60 * 2))) >= new Date().getTime()) {
+                    double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - (new Date().getTime())) / (60000);
+                    notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
+                } else {
+                    notificationText.setText("Now start your sensor");
+                }
             }
         }
         mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManager().findFragmentById(R.id.navigation_drawer);
@@ -245,7 +303,8 @@ public void displayCurrentInfo() {
         }
         BgReading lastBgreading = BgReading.lastNoSenssor();
         boolean predictive = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getBoolean("predictive_bg", false);
-            if (lastBgreading != null) {
+        if(isBTShare) { predictive = false; }
+        if (lastBgreading != null) {
             double estimate = 0;
             if ((new Date().getTime()) - (60000 * 11) - lastBgreading.timestamp > 0) {
                 notificationText.setText("Signal Missed");
@@ -260,7 +319,11 @@ public void displayCurrentInfo() {
                 if(!predictive){
                     estimate=lastBgreading.calculated_value;
                     String stringEstimate = bgGraphBuilder.unitized_string(estimate);
-                    currentBgValueText.setText( stringEstimate + " " + BgReading.slopeArrow((lastBgreading.staticSlope() * 60000)));
+                    String slope_arrow = BgReading.slopeArrow((lastBgreading.calculated_value_slope * 60000));
+                    if(lastBgreading.hide_slope) {
+                        slope_arrow = "";
+                    }
+                    currentBgValueText.setText( stringEstimate + " " + slope_arrow);
                 } else {
                     estimate = BgReading.activePrediction();
                     String stringEstimate = bgGraphBuilder.unitized_string(estimate);
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/Constants.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/Constants.java
index c8a4f1e..f60dd6c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/Constants.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/Constants.java
@@ -86,8 +86,8 @@
         DOWN_45(5,"\u2198", "FortyFiveDown"),
         SINGLE_DOWN(6,"\u2193", "SingleDown"),
         DOUBLE_DOWN(7,"\u21CA", "DoubleDown"),
-        NOT_COMPUTABLE(8),
-        OUT_OF_RANGE(9);
+        NOT_COMPUTABLE(8, "", "NOT_COMPUTABLE"),
+        OUT_OF_RANGE(9, "", "OUT_OF_RANGE");
 
         private String arrowSymbol;
         private String trendName;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/PacketBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/PacketBuilder.java
index 04cfbed..2746ea0 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/PacketBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/PacketBuilder.java
@@ -1,6 +1,9 @@
 package com.eveningoutpost.dexdrip.ImportedLibraries.dexcom;
 
+import android.util.Log;
+
 import java.util.ArrayList;
+import java.util.List;
 
 public class PacketBuilder {
     public static final int MAX_PAYLOAD = 1584;
@@ -15,9 +18,9 @@
     public static final int OFFSET_PAYLOAD = 4;
     public static final int CRC_LEN = 2;
     public static final int HEADER_LEN = 4;
-    private ArrayList<Byte> packet;
-    private int command;
-    private ArrayList<Byte> payload;
+    public ArrayList<Byte> packet;
+    public int command;
+    public ArrayList<Byte> payload;
 
     public PacketBuilder(int command) {
         this.command = command;
@@ -38,8 +41,24 @@ public PacketBuilder(int command, ArrayList<Byte> payload) {
         byte[] crc16 = CRC16.calculate(toBytes(), 0, this.packet.size());
         this.packet.add(crc16[0]);
         this.packet.add(crc16[1]);
+        Log.d("ShareTest", "About to start adding to Byte, size: " + this.packet.size());
         return this.toBytes();
     }
+
+    public List<byte[]> composeList() {
+        packet = new ArrayList<Byte>();
+        packet.add(OFFSET_SOF, SOF);
+        packet.add(OFFSET_LENGTH, getLength());
+        packet.add(OFFSET_NULL, NULL);
+        packet.add(OFFSET_CMD, (byte) command);
+        if (this.payload != null) { this.packet.addAll(OFFSET_PAYLOAD, this.payload); }
+        byte[] crc16 = CRC16.calculate(toBytes(), 0, this.packet.size());
+        this.packet.add(crc16[0]);
+        this.packet.add(crc16[1]);
+        Log.d("ShareTest", "About to start adding to ByteList, size: " + this.packet.size());
+        return this.toBytesList();
+    }
+
     private byte getLength() {
         int packetSize = payload == null ? MIN_LEN : payload.size() + CRC_LEN + HEADER_LEN;
 
@@ -51,11 +70,35 @@ private byte getLength() {
         return (byte) packetSize;
     }
 
-    private byte[] toBytes() {
+    public byte[] toBytes() {
         byte[] b = new byte[this.packet.size()];
         for (int i = 0; i < this.packet.size(); i++) {
             b[i] = this.packet.get(i).byteValue();
         }
         return b;
     }
+
+    public List<byte[]> toBytesList() {
+        List<byte[]> byteMessages = new ArrayList<byte[]>();
+        double totalPacketSize = packet.size();
+        int messages =(int) Math.ceil(totalPacketSize/18);
+        for(int m = 0; m < messages; m++) {
+            int thisPacketSize;
+            if (m == messages - 1) {
+                thisPacketSize = ((this.packet.size()+2) % 18);
+            } else {
+                thisPacketSize = (20);
+            }
+            int offset = m * 18;
+            Log.d("ShareTest", "This packet size: " + thisPacketSize);
+            byte[] b = new byte[thisPacketSize];
+            b[0] = (byte) (m + 1);
+            b[1] = (byte) (messages);
+            for (int i = 2; i < thisPacketSize; i++) {
+                b[i] = packet.get(offset + i - 2).byteValue();
+            }
+            byteMessages.add(b);
+        }
+        return byteMessages;
+    }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadData.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadData.java
index d38fb5b..0235c33 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadData.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadData.java
@@ -36,6 +36,7 @@
     private UsbDeviceConnection mConnection;
     private UsbDevice mDevice;
 
+    public ReadData(){}
     public ReadData(UsbSerialDriver device) {
         mSerialDevice = device;
     }
@@ -119,6 +120,13 @@ public long getTimeSinceEGVRecord(EGVRecord egvRecord) {
         Log.d(TAG, "Reading Cal Records page...");
         return readDataBasePage(recordType, endPage);
     }
+    public byte[] getRecentCalRecordsTest() {
+        Log.d(TAG, "Reading Cal Records page range...");
+        int recordType = Constants.RECORD_TYPES.CAL_SET.ordinal();
+        int endPage = readDataBasePageRange(recordType);
+        Log.d(TAG, "Reading Cal Records page...");
+        return readDataBasePageTest(recordType, endPage);
+    }
 
     public boolean ping() {
         writeCommand(Constants.PING);
@@ -186,6 +194,21 @@ private int readDataBasePageRange(int recordType) {
         byte[] readData = read(2122).getData();
         return ParsePage(readData, recordType);
     }
+    private byte[] readDataBasePageTest(int recordType, int page) {
+        byte numOfPages = 1;
+        if (page < 0){
+            throw new IllegalArgumentException("Invalid page requested:" + page);
+        }
+        ArrayList<Byte> payload = new ArrayList<Byte>();
+        payload.add((byte) recordType);
+        byte[] pageInt = ByteBuffer.allocate(4).putInt(page).array();
+        payload.add(pageInt[3]);
+        payload.add(pageInt[2]);
+        payload.add(pageInt[1]);
+        payload.add(pageInt[0]);
+        payload.add(numOfPages);
+        return writeCommandTest(Constants.READ_DATABASE_PAGES, payload);
+    }
 
     private void writeCommand(int command, ArrayList<Byte> payload) {
         byte[] packet = new PacketBuilder(command, payload).compose();
@@ -200,7 +223,10 @@ private void writeCommand(int command, ArrayList<Byte> payload) {
             }
         }
     }
-
+    private byte[] writeCommandTest(int command, ArrayList<Byte> payload) {
+        byte[] packet = new PacketBuilder(command, payload).compose();
+        return packet;
+    }
     private void writeCommand(int command) {
         byte[] packet = new PacketBuilder(command).compose();
         if (mSerialDevice != null) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadDataShare.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadDataShare.java
new file mode 100644
index 0000000..91b9e99
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/ReadDataShare.java
@@ -0,0 +1,310 @@
+package com.eveningoutpost.dexdrip.ImportedLibraries.dexcom;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbDeviceConnection;
+import android.util.Log;
+
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.CalRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.EGVRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.GenericXMLRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.MeterRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.PageHeader;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.SensorRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.usbserial.driver.UsbSerialDriver;
+import com.eveningoutpost.dexdrip.Services.DexCollectionService;
+import com.eveningoutpost.dexdrip.Services.DexShareCollectionService;
+import com.eveningoutpost.dexdrip.ShareTest;
+
+import org.w3c.dom.Element;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import rx.Observable;
+import rx.functions.Action1;
+
+public class ReadDataShare {
+    byte[] accumulatedResponse;
+    private ShareTest mShareTest;
+    private DexShareCollectionService mCollectionService;
+
+    public ReadDataShare(ShareTest aShareTest){
+        mShareTest = aShareTest;
+    }
+    public ReadDataShare(DexShareCollectionService collectionService){
+        mCollectionService = collectionService;
+    }
+
+    public void getRecentEGVs(final Action1<EGVRecord[]> recordListener) {
+        final int recordType = Constants.RECORD_TYPES.EGV_DATA.ordinal();
+        final Action1<byte[]> fullPageListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { ParsePage(read(0,s).getData(), recordType, recordListener); }
+        };
+        Action1<Integer> databasePageRangeCaller = new Action1<Integer>() {
+            @Override
+            public void call(Integer s) { readDataBasePage(recordType, s, fullPageListener); }
+        };
+        readDataBasePageRange(recordType, databasePageRangeCaller);
+    }
+
+    public void getRecentMeterRecords(final Action1<MeterRecord[]> recordListener) {
+        final int recordType = Constants.RECORD_TYPES.METER_DATA.ordinal();
+        final Action1<byte[]> fullPageListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { ParsePage(read(0,s).getData(), recordType, recordListener); }
+        };
+        Action1<Integer> databasePageRangeCaller = new Action1<Integer>() {
+            @Override
+            public void call(Integer s) { readDataBasePage(recordType, s, fullPageListener); }
+        };
+        readDataBasePageRange(recordType, databasePageRangeCaller);
+    }
+
+    public void getRecentCalRecords(final Action1<CalRecord[]> recordListener) {
+        final int recordType = Constants.RECORD_TYPES.CAL_SET.ordinal();
+        final Action1<byte[]> fullPageListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { ParsePage(read(0,s).getData(), recordType, recordListener); }
+        };
+        Action1<Integer> databasePageRangeCaller = new Action1<Integer>() {
+            @Override
+            public void call(Integer s) { readDataBasePage(recordType, s, fullPageListener); }
+        };
+        readDataBasePageRange(recordType, databasePageRangeCaller);
+    }
+
+
+    public void getRecentSensorRecords(final Action1<SensorRecord[]> recordListener) {
+        final int recordType = Constants.RECORD_TYPES.SENSOR_DATA.ordinal();
+        final Action1<byte[]> fullPageListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { ParsePage(read(0,s).getData(), recordType, recordListener); }
+        };
+        Action1<Integer> databasePageRangeCaller = new Action1<Integer>() {
+            @Override
+            public void call(Integer s) { readDataBasePage(recordType, s, fullPageListener); }
+        };
+        readDataBasePageRange(recordType, databasePageRangeCaller);
+    }
+
+    public void getTimeSinceEGVRecord(final EGVRecord egvRecord, final Action1<Long> timeSinceEgvRecord) {
+        Action1<Long> tempSystemTimeListener = new Action1<Long>() {
+            @Override
+            public void call(Long s) { Observable.just(s - egvRecord.getSystemTimeSeconds()).subscribe(timeSinceEgvRecord); }
+        };
+        readSystemTime(tempSystemTimeListener);
+    }
+
+    public void ping(final Action1<Boolean> pingListener) {
+        Action1<byte[]> pingReader = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { Observable.just(read(0, s).getCommand() == Constants.ACK).subscribe(pingListener); }
+        };
+        writeCommand(Constants.PING, pingReader);
+    }
+
+    public void readBatteryLevel(final Action1<Integer> batteryLevelListener) {
+        Action1<byte[]> batteryLevelReader = new Action1<byte[]>() {
+            @Override //TODO: find out if this should be wrapped in read(s).getData();
+            public void call(byte[] s) { Observable.just(ByteBuffer.wrap(s).order(ByteOrder.LITTLE_ENDIAN).getInt()).subscribe(batteryLevelListener); }
+        };
+        writeCommand(Constants.READ_BATTERY_LEVEL, batteryLevelReader);
+    }
+
+    public void readSerialNumber(final Action1<String> serialNumberListener) {
+        final Action1<byte[]> manufacturingDataListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) {
+                Element el = ParsePage(s, Constants.RECORD_TYPES.MANUFACTURING_DATA.ordinal());
+                Observable.just(el.getAttribute("SerialNumber")).subscribe(serialNumberListener);
+            }
+        };
+        readDataBasePage(Constants.RECORD_TYPES.MANUFACTURING_DATA.ordinal(), 0, manufacturingDataListener);
+    }
+
+    public void readDisplayTime(final Action1<Date> displayTimeListener) {
+        Action1<Long> tempSystemTimeListener = new Action1<Long>() {
+            @Override
+            public void call(Long s) {
+                final long systemTime = s;
+                Action1<Long> tempSystemTimeListener = new Action1<Long>() {
+                    @Override
+                    public void call(Long s) {
+                        Date dateDisplayTime = Utils.receiverTimeToDate(systemTime + s);
+                        Observable.just(dateDisplayTime).subscribe(displayTimeListener); }
+                };
+                readDisplayTimeOffset(tempSystemTimeListener);
+            }
+        };
+        readSystemTime(tempSystemTimeListener);
+    }
+
+    public void readSystemTime(final Action1<Long> systemTimeListener) {
+        Action1<byte[]> systemTimeReader = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) {
+                Observable.just(Utils.receiverTimeToDate(ByteBuffer.wrap(read(0,s).getData()).order(ByteOrder.LITTLE_ENDIAN).getInt()).getTime()).subscribe(systemTimeListener);
+            }
+        };
+        writeCommand(Constants.READ_SYSTEM_TIME, systemTimeReader);
+    }
+
+    public void readDisplayTimeOffset(final Action1<Long> displayTimeOffsetListener) {
+        Action1<byte[]> displayTimeOffsetReader = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) { Observable.just((long) ByteBuffer.wrap(read(0,s).getData()).order(ByteOrder.LITTLE_ENDIAN).getInt()).subscribe(displayTimeOffsetListener); }
+        };
+        writeCommand(Constants.READ_DISPLAY_TIME_OFFSET, displayTimeOffsetReader);
+    }
+
+    private void readDataBasePageRange(int recordType, final Action1<Integer> databasePageRangeCaller) {
+        ArrayList<Byte> payload = new ArrayList<Byte>();
+        payload.add((byte) recordType);
+        final Action1<byte[]> databasePageRangeListener = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) {
+                Observable.just(ByteBuffer.wrap(new ReadPacket(s).getData()).order(ByteOrder.LITTLE_ENDIAN).getInt(4)).subscribe(databasePageRangeCaller);
+            }
+        };
+        writeCommand(Constants.READ_DATABASE_PAGE_RANGE, payload, databasePageRangeListener);
+    }
+
+    private <T> T readDataBasePage(final int recordType, int page, final Action1<byte[]> fullPageListener) {
+        byte numOfPages = 1;
+        if (page < 0){ throw new IllegalArgumentException("Invalid page requested:" + page); }
+        ArrayList<Byte> payload = new ArrayList<Byte>();
+        payload.add((byte) recordType);
+        byte[] pageInt = ByteBuffer.allocate(4).putInt(page).array();
+        payload.add(pageInt[3]);
+        payload.add(pageInt[2]);
+        payload.add(pageInt[1]);
+        payload.add(pageInt[0]);
+        payload.add(numOfPages);
+        accumulatedResponse = null;
+        final Action1<byte[]> databasePageReader = new Action1<byte[]>() {
+            @Override
+            public void call(byte[] s) {
+                Log.d("ShareTest", "Database Page Reader received SIZE: " + s.length);
+                byte[] temp = s;
+                if (accumulatedResponse == null) {
+                    accumulatedResponse = s;
+                } else {
+                    try {
+                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                        outputStream.write(accumulatedResponse);
+                        outputStream.write(temp);
+                        accumulatedResponse = outputStream.toByteArray();
+                        Log.d("ShareTest", "Combined Response length: " + accumulatedResponse.length);
+                    } catch (Exception e) { e.printStackTrace(); }
+                }
+                if (temp.length < 20) { Observable.just(accumulatedResponse).subscribe(fullPageListener).unsubscribe(); }
+            }
+        };
+        writeCommand(Constants.READ_DATABASE_PAGES, payload, databasePageReader);
+        return null;
+    }
+
+    private void writeCommand(int command, ArrayList<Byte> payload, Action1<byte[]> responseListener) {
+        List<byte[]> packets = new PacketBuilder(command, payload).composeList();
+        if(mShareTest != null) { mShareTest.writeCommand(packets, 0, responseListener); }
+        else if (mCollectionService != null) { mCollectionService.writeCommand(packets, 0, responseListener); }
+    }
+
+    private void writeCommand(int command, Action1<byte[]> responseListener) {
+        List<byte[]> packets = new PacketBuilder(command).composeList();
+        if(mShareTest != null) { mShareTest.writeCommand(packets, 0, responseListener); }
+        else if (mCollectionService != null) { mCollectionService.writeCommand(packets, 0, responseListener); }
+    }
+
+    private ReadPacket read(int numOfBytes, byte[] readPacket) {
+        return new ReadPacket(Arrays.copyOfRange(readPacket, 0, readPacket.length));
+    }
+
+    private <T> T ParsePage(byte[] data, int recordType) { return ParsePage(data, recordType, null); }
+    private <T> T ParsePage(byte[] data, int recordType, Action1<T> parsedPageReceiver) {
+        int HEADER_LEN = 28;
+        PageHeader pageHeader=new PageHeader(data);
+        int NUM_REC_OFFSET = 4;
+        int numRec = data[NUM_REC_OFFSET];
+        int rec_len;
+
+        switch (Constants.RECORD_TYPES.values()[recordType]) {
+            case MANUFACTURING_DATA:
+                GenericXMLRecord xmlRecord = new GenericXMLRecord(Arrays.copyOfRange(data, HEADER_LEN, data.length - 1));
+                if(parsedPageReceiver != null) {
+                    Observable.just((T) xmlRecord).subscribe(parsedPageReceiver);
+                } else {
+                    return (T) xmlRecord;
+                }
+                break;
+            case SENSOR_DATA:
+                rec_len = 20;
+                SensorRecord[] sensorRecords = new SensorRecord[numRec];
+                for (int i = 0; i < numRec; i++) {
+                    int startIdx = HEADER_LEN + rec_len * i;
+                    sensorRecords[i] = new SensorRecord(Arrays.copyOfRange(data, startIdx, startIdx + rec_len - 1));
+                }
+                if(parsedPageReceiver != null) {
+                    Observable.just((T) sensorRecords).subscribe(parsedPageReceiver);
+                } else {
+                    return (T) sensorRecords;
+                }
+                break;
+            case EGV_DATA:
+                rec_len = 13;
+                EGVRecord[] egvRecords = new EGVRecord[numRec];
+                for (int i = 0; i < numRec; i++) {
+                    int startIdx = HEADER_LEN + rec_len * i;
+                    egvRecords[i] = new EGVRecord(Arrays.copyOfRange(data, startIdx, startIdx + rec_len - 1));
+                }
+                if(parsedPageReceiver != null) {
+                    Observable.just((T) egvRecords).subscribe(parsedPageReceiver);
+                } else {
+                    return (T) egvRecords;
+                }
+                break;
+            case METER_DATA:
+                rec_len = 16;
+                MeterRecord[] meterRecords = new MeterRecord[numRec];
+                for (int i = 0; i < numRec; i++) {
+                    int startIdx = HEADER_LEN + rec_len * i;
+                    meterRecords[i] = new MeterRecord(Arrays.copyOfRange(data, startIdx, startIdx + rec_len - 1));
+                }
+                if(parsedPageReceiver != null) {
+                    Observable.just((T) meterRecords).subscribe(parsedPageReceiver);
+                } else {
+                    return (T) meterRecords;
+                }
+                break;
+            case CAL_SET:
+                rec_len = 249;
+                if (pageHeader.getRevision()<=2) { rec_len = 148; }
+                CalRecord[] calRecords = new CalRecord[numRec];
+                for (int i = 0; i < numRec; i++) {
+                    int startIdx = HEADER_LEN + rec_len * i;
+                    calRecords[i] = new CalRecord(Arrays.copyOfRange(data, startIdx, startIdx + rec_len - 1));
+                }
+                if(parsedPageReceiver != null) {
+                    Observable.just((T) calRecords).subscribe(parsedPageReceiver);
+                } else {
+                    return (T) calRecords;
+                }
+                break;
+            default:
+                break;
+        }
+        Observable.just((T) null).subscribe(parsedPageReceiver);
+        return (T) null;
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/SyncingService.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/SyncingService.java
index 7c5cb0f..4e8e6c2 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/SyncingService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/SyncingService.java
@@ -214,8 +214,7 @@ private void handleActionSync(int numOfPages) {
 
     private void save_most_recent_cal_record(CalRecord[] calRecords) {
         int size = calRecords.length;
-
-        Calibration.create(calRecords, getApplicationContext(), false);
+        Calibration.create(calRecords,getApplicationContext(), false, 0);
     }
 
     private boolean acquireSerialDevice() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/CalRecord.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/CalRecord.java
index c9a8bf1..fe89873 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/CalRecord.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/CalRecord.java
@@ -34,6 +34,8 @@ public CalRecord(byte[] packet) {
             calSubrecords[i] = new CalSubrecord(temp, displayTimeOffset);
             start += SUB_LEN;
         }
+
+        Log.d("ShareTest", "slope: " + slope + " intercept: " + intercept);
     }
 
     public double getSlope() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/EGVRecord.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/EGVRecord.java
index 8fdb65a..0317fdb 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/EGVRecord.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/EGVRecord.java
@@ -1,5 +1,7 @@
 package com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records;
 
+import android.util.Log;
+
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.Constants;
 
 import org.json.JSONException;
@@ -23,6 +25,7 @@ public EGVRecord(byte[] packet) {
         bGValue = eGValue & Constants.EGV_VALUE_MASK;
         int trendValue = ByteBuffer.wrap(packet).get(10) & Constants.EGV_TREND_ARROW_MASK;
         trend = Constants.TREND_ARROW_VALUES.values()[trendValue];
+        Log.d("ShareTest", "BG: " + bGValue + " TREND: " + trend);
     }
 
     public EGVRecord(int bGValue,Constants.TREND_ARROW_VALUES trend,Date displayTime, Date systemTime){
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/PageHeader.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/PageHeader.java
index 2b7bef7..5de9b21 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/PageHeader.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/PageHeader.java
@@ -1,5 +1,7 @@
 package com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records;
 
+import android.util.Log;
+
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.CRC16;
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.CRCFailRuntimeException;
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.Constants;
@@ -32,6 +34,8 @@
 
 
     public PageHeader(byte[] packet) {
+        Log.d("ShareTest", "Header Packet Data Length: " + packet.length);
+
         firstRecordIndex = ByteBuffer.wrap(packet).order(ByteOrder.LITTLE_ENDIAN).getInt(FIRSTRECORDINDEX_OFFSET);
         numOfRecords = ByteBuffer.wrap(packet).order(ByteOrder.LITTLE_ENDIAN).getInt(NUMRECS_OFFSET);
         recordType = Constants.RECORD_TYPES.values()[packet[RECTYPE_OFFSET]];
@@ -45,7 +49,6 @@ public PageHeader(byte[] packet) {
         if (!Arrays.equals(this.crc, crc_calc)) {
             throw new CRCFailRuntimeException("CRC check failed: " + Utils.bytesToHex(this.crc) + " vs " + Utils.bytesToHex(crc_calc));
         }
-
     }
 
     public byte getRevision() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/SensorRecord.java b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/SensorRecord.java
index f050f1a..a2c1f56 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/SensorRecord.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ImportedLibraries/dexcom/records/SensorRecord.java
@@ -1,5 +1,7 @@
 package com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records;
 
+import android.util.Log;
+
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
@@ -17,6 +19,7 @@ public SensorRecord(byte[] packet) {
         unfiltered = ByteBuffer.wrap(packet).order(ByteOrder.LITTLE_ENDIAN).getInt(OFFSET_UNFILTERED);
         filtered = ByteBuffer.wrap(packet).order(ByteOrder.LITTLE_ENDIAN).getInt(OFFSET_FILTERED);
         rssi = ByteBuffer.wrap(packet).order(ByteOrder.LITTLE_ENDIAN).getShort(OFFSET_RSSI);
+        Log.d("ShareTest", "filtered: " + filtered + " unfiltered: " + unfiltered);
     }
 
     public long getUnfiltered() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBluetoothDevice.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBluetoothDevice.java
index ceb45d0..336a4c8 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBluetoothDevice.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBluetoothDevice.java
@@ -18,6 +18,9 @@
     @Column(name = "address")
     public String address;
 
+    @Column(name = "connected")
+    public boolean connected;
+
     public static ActiveBluetoothDevice first() {
         return new Select()
                 .from(ActiveBluetoothDevice.class)
@@ -25,4 +28,35 @@ public static ActiveBluetoothDevice first() {
                 .executeSingle();
     }
 
-}
\ No newline at end of file
+    public static void forget() {
+        ActiveBluetoothDevice activeBluetoothDevice = ActiveBluetoothDevice.first();
+        if (activeBluetoothDevice != null) {
+            activeBluetoothDevice.delete();
+        }
+    }
+
+    public static void connected() {
+        ActiveBluetoothDevice activeBluetoothDevice = ActiveBluetoothDevice.first();
+        if(activeBluetoothDevice != null) {
+            activeBluetoothDevice.connected = true;
+            activeBluetoothDevice.save();
+        }
+    }
+
+    public static void disconnected() {
+        ActiveBluetoothDevice activeBluetoothDevice = ActiveBluetoothDevice.first();
+        if(activeBluetoothDevice != null) {
+            activeBluetoothDevice.connected = false;
+            activeBluetoothDevice.save();
+        }
+    }
+
+    public static boolean is_connected() {
+        ActiveBluetoothDevice activeBluetoothDevice = ActiveBluetoothDevice.first();
+        if(activeBluetoothDevice != null) {
+            return activeBluetoothDevice.connected;
+        }
+        return false;
+    }
+
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 386103a..bc38ffa 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -1,6 +1,7 @@
 package com.eveningoutpost.dexdrip.Models;
 
 import android.content.Context;
+import android.content.Intent;
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
 import android.provider.BaseColumns;
@@ -10,7 +11,11 @@
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.CalSubrecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.EGVRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.SensorRecord;
 import com.eveningoutpost.dexdrip.Sensor;
+import com.eveningoutpost.dexdrip.Services.DexShareCollectionService;
 import com.eveningoutpost.dexdrip.UtilityModels.BgSendQueue;
 import com.eveningoutpost.dexdrip.UtilityModels.Constants;
 import com.eveningoutpost.dexdrip.UtilityModels.Notifications;
@@ -102,6 +107,12 @@
     @Column(name = "snyced")
     public boolean synced;
 
+    @Column(name = "raw_calculated")
+    public double raw_calculated;
+
+    @Column(name = "hide_slope")
+    public boolean hide_slope;
+
     public double calculated_value_mmol() {
         return mmolConvert(calculated_value);
     }
@@ -137,11 +148,6 @@ public static double activeSlope() {
         Log.w(TAG, "ESTIMATE SLOPE" + slope);
         return slope;
     }
-    public double staticSlope() {
-        double slope = (2 * this.a * this.timestamp) + this.b;
-        Log.w(TAG, "ESTIMATE SLOPE" + slope);
-        return slope;
-    }
 
     public static double activePrediction() {
         BgReading bgReading = BgReading.lastNoSenssor();
@@ -155,6 +161,103 @@ public static double activePrediction() {
     }
 
     //*******CLASS METHODS***********//
+    public static void create(EGVRecord[] egvRecords, long addativeOffset, Context context) {
+        for(EGVRecord egvRecord : egvRecords) { BgReading.create(egvRecord, addativeOffset, context); }
+    }
+
+    public static void create(SensorRecord[] sensorRecords, long addativeOffset, Context context) {
+        for(SensorRecord sensorRecord : sensorRecords) { BgReading.create(sensorRecord, addativeOffset, context); }
+    }
+
+    public static void create(SensorRecord sensorRecord, long addativeOffset, Context context) {
+        Log.w(TAG, "gonna make some sensor records: " + sensorRecord.getUnfiltered());
+        if(BgReading.is_new(sensorRecord, addativeOffset)) {
+            BgReading bgReading = new BgReading();
+            Sensor sensor = Sensor.currentSensor();
+            Calibration calibration = Calibration.getForTimestamp(sensorRecord.getSystemTime().getTime() + addativeOffset);
+            if(sensor != null && calibration != null) {
+                bgReading.sensor = sensor;
+                bgReading.sensor_uuid = sensor.uuid;
+                bgReading.calibration = calibration;
+                bgReading.calibration_uuid = calibration.uuid;
+                bgReading.raw_data = (sensorRecord.getUnfiltered() / 1000);
+                bgReading.timestamp = sensorRecord.getSystemTime().getTime() + addativeOffset;
+                if(bgReading.timestamp > new Date().getTime()) { return; }
+                bgReading.uuid = UUID.randomUUID().toString();
+                bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
+                bgReading.synced = false;
+                bgReading.calculateAgeAdjustedRawValue();
+                bgReading.save();
+            }
+        }
+    }
+
+    public static void create(EGVRecord egvRecord, long addativeOffset, Context context) {
+        BgReading bgReading = BgReading.getForTimestamp(egvRecord.getSystemTime().getTime() + addativeOffset);
+        Log.w(TAG, "Looking for BG reading to tag this thing to: " + egvRecord.getBGValue());
+        if(bgReading != null) {
+            bgReading.calculated_value = egvRecord.getBGValue();
+            if (egvRecord.getBGValue() <= 13) {
+                Calibration calibration = bgReading.calibration;
+                double firstAdjSlope = calibration.first_slope + (calibration.first_decay * (Math.ceil(new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
+                double calSlope = (calibration.first_scale / firstAdjSlope)*1000;
+                double calIntercept = ((calibration.first_scale * calibration.first_intercept) / firstAdjSlope)*-1;
+                bgReading.raw_calculated = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
+            }
+            Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
+            bgReading.calculated_value_slope = bgReading.slopefromName(egvRecord.getTrend().friendlyTrendName());
+            if(egvRecord.getTrend().friendlyTrendName().compareTo("NOT_COMPUTABLE") == 0 || egvRecord.getTrend().friendlyTrendName().compareTo("OUT_OF_RANGE") == 0) {
+                bgReading.hide_slope = true;
+            }
+
+            bgReading.save();
+            bgReading.find_new_curve();
+            bgReading.find_new_raw_curve();
+            bgReading.perform_calculations();
+            Notifications.notificationSetter(context);
+            BgSendQueue.addToQueue(bgReading, "create", context);
+        }
+    }
+
+    public static BgReading getForTimestamp(double timestamp) {
+        Sensor sensor = Sensor.currentSensor();
+        if(sensor != null) {
+            BgReading bgReading = new Select()
+                    .from(BgReading.class)
+                    .where("Sensor = ? ", sensor.getId())
+                    .where("timestamp <= ?",  (timestamp + (60*1000))) // 1 minute padding (should never be that far off, but why not)
+                    .where("calculated_value = 0")
+                    .where("raw_calculated = 0")
+                    .orderBy("timestamp desc")
+                    .executeSingle();
+            if(bgReading != null && Math.abs(bgReading.timestamp - timestamp) < (3*60*1000)) { //cool, so was it actually within 4 minutes of that bg reading?
+                Log.w(TAG, "Found a BG timestamp match");
+                return bgReading;
+            }
+        }
+        Log.w(TAG, "No luck finding a BG timestamp match");
+        return null;
+    }
+
+    public static boolean is_new(SensorRecord sensorRecord, long addativeOffset) {
+        double timestamp = sensorRecord.getSystemTime().getTime() + addativeOffset;
+        Sensor sensor = Sensor.currentSensor();
+        if(sensor != null) {
+            BgReading bgReading = new Select()
+                    .from(BgReading.class)
+                    .where("Sensor = ? ", sensor.getId())
+                    .where("timestamp <= ?",  (timestamp + (60*1000))) // 1 minute padding (should never be that far off, but why not)
+                    .orderBy("timestamp desc")
+                    .executeSingle();
+            if(bgReading != null && Math.abs(bgReading.timestamp - timestamp) < (3*60*1000)) { //cool, so was it actually within 4 minutes of that bg reading?
+                Log.w(TAG, "Old Reading");
+                return false;
+            }
+        }
+        Log.w(TAG, "New Reading");
+        return true;
+    }
+
     public static BgReading create(double raw_data, Context context, Long timestamp) {
         BgReading bgReading = new BgReading();
         Sensor sensor = Sensor.currentSensor();
@@ -190,11 +293,8 @@ public static BgReading create(double raw_data, Context context, Long timestamp)
 
                 if(calibration.check_in) {
                     double firstAdjSlope = calibration.first_slope + (calibration.first_decay * (Math.ceil(new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
-//                    double secondAdjSlope = calibration.first_slope + (calibration.first_decay * ((new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
                     double calSlope = (calibration.first_scale / firstAdjSlope)*1000;
                     double calIntercept = ((calibration.first_scale * calibration.first_intercept) / firstAdjSlope)*-1;
-//                    double calSlope = ((calibration.second_scale / secondAdjSlope) + (3 * calibration.first_scale / firstAdjSlope)) * 250;
-//                    double calIntercept = (((calibration.second_scale * calibration.second_intercept) / secondAdjSlope) + ((3 * calibration.first_scale * calibration.first_intercept) / firstAdjSlope)) / -4;
                     bgReading.calculated_value = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
 
                 } else {
@@ -261,26 +361,57 @@ public String slopeName() {
             arrow = "FortyFiveUp";
         } else if (slope_by_minute <= (3.5)) {
             arrow = "SingleUp";
-        } else {
+        } else if (slope_by_minute <= (40)) {
             arrow = "DoubleUp";
         }
+        if(hide_slope) {
+            arrow = "9";
+        }
         return arrow;
     }
 
+    public double slopefromName(String slope_name) {
+        double slope_by_minute = 0;
+        if (slope_name.compareTo("DoubleDown") == 0) {
+            slope_by_minute = -3.5;
+        } else if (slope_name.compareTo("SingleDown") == 0) {
+            slope_by_minute = -2;
+        } else if (slope_name.compareTo("FortyFiveDown") == 0) {
+            slope_by_minute = -1;
+        } else if (slope_name.compareTo("Flat") == 0) {
+            slope_by_minute = 0;
+        } else if (slope_name.compareTo("FortyFiveUp") == 0) {
+            slope_by_minute = 2;
+        } else if (slope_name.compareTo("SingleUp") == 0) {
+            slope_by_minute = 2;
+        } else if (slope_name.compareTo("DoubleUp") == 0) {
+            slope_by_minute = 4;
+        } else if (slope_name.compareTo("NOT_COMPUTABLE") == 0 || slope_name.compareTo("OUT_OF_RANGE") == 0) {
+            slope_by_minute = 0;
+        }
+        return slope_by_minute /60000;
+    }
+
     public static BgReading last() {
         Sensor sensor = Sensor.currentSensor();
-        return new Select()
-                .from(BgReading.class)
-                .where("Sensor = ? ", sensor.getId())
-                .orderBy("_ID desc")
-                .executeSingle();
+        if (sensor != null) {
+            return new Select()
+                    .from(BgReading.class)
+                    .where("Sensor = ? ", sensor.getId())
+                    .where("calculated_value != 0")
+                    .where("raw_data != 0")
+                    .orderBy("timestamp desc")
+                    .executeSingle();
+        }
+        return null;
     }
     public static List<BgReading> latest_by_size(int number) {
         Sensor sensor = Sensor.currentSensor();
         return new Select()
                 .from(BgReading.class)
                 .where("Sensor = ? ", sensor.getId())
-                .orderBy("_ID desc")
+                .where("raw_data != 0")
+                .orderBy("timestamp desc")
                 .limit(number)
                 .execute();
     }
@@ -288,7 +419,9 @@ public static BgReading last() {
     public static BgReading lastNoSenssor() {
         return new Select()
                 .from(BgReading.class)
-                .orderBy("_ID desc")
+                .where("calculated_value != 0")
+                .where("raw_data != 0")
+                .orderBy("timestamp desc")
                 .executeSingle();
     }
 
@@ -298,7 +431,21 @@ public static BgReading lastNoSenssor() {
         return new Select()
                 .from(BgReading.class)
                 .where("Sensor = ? ", sensor.getId())
-                .orderBy("_ID desc")
+                .where("calculated_value != 0")
+                .where("raw_data != 0")
+                .orderBy("timestamp desc")
+                .limit(number)
+                .execute();
+    }
+
+    public static List<BgReading> latestUnCalculated(int number) {
+        Sensor sensor = Sensor.currentSensor();
+        if (sensor == null) { return null; }
+        return new Select()
+                .from(BgReading.class)
+                .where("Sensor = ? ", sensor.getId())
+                .where("raw_data != 0")
+                .orderBy("timestamp desc")
                 .limit(number)
                 .execute();
     }
@@ -306,10 +453,11 @@ public static BgReading lastNoSenssor() {
     public static List<BgReading> latestForGraph(int number, double startTime) {
         DecimalFormat df = new DecimalFormat("#");
         df.setMaximumFractionDigits(1);
-
         return new Select()
                 .from(BgReading.class)
                 .where("timestamp >= " + df.format(startTime))
+                .where("calculated_value != 0")
+                .where("raw_data != 0")
                 .orderBy("timestamp desc")
                 .limit(number)
                 .execute();
@@ -320,7 +468,9 @@ public static BgReading lastNoSenssor() {
         return new Select()
                 .from(BgReading.class)
                 .where("timestamp >= " + timestamp)
-                .orderBy("_ID desc")
+                .where("calculated_value != 0")
+                .where("raw_data != 0")
+                .orderBy("timestamp desc")
                 .execute();
     }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/Calibration.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/Calibration.java
index dba7923..0876c91 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/Calibration.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/Calibration.java
@@ -141,7 +141,6 @@
     @Column(name = "second_scale")
     public double second_scale;
 
-
     public static void initialCalibration(double bg1, double bg2, Context context) {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
         String unit = prefs.getString("units", "mgdl");
@@ -172,7 +171,7 @@ public static void initialCalibration(double bg1, double bg2, Context context) {
         }
 
         higherCalibration.bg = higher_bg;
-        higherCalibration.slope = 0;
+        higherCalibration.slope = 1;
         higherCalibration.intercept = higher_bg;
         higherCalibration.sensor = sensor;
         higherCalibration.estimate_raw_at_time_of_calibration = highBgReading.age_adjusted_raw_value;
@@ -188,7 +187,7 @@ public static void initialCalibration(double bg1, double bg2, Context context) {
         higherCalibration.save();
 
         lowerCalibration.bg = lower_bg;
-        lowerCalibration.slope = 0;
+        lowerCalibration.slope = 1;
         lowerCalibration.intercept = lower_bg;
         lowerCalibration.sensor = sensor;
         lowerCalibration.estimate_raw_at_time_of_calibration = lowBgReading.age_adjusted_raw_value;
@@ -233,7 +232,9 @@ public static void initialCalibration(double bg1, double bg2, Context context) {
     }
 
     //Create Calibration Checkin
-    public static void create(CalRecord[] calRecords, Context context, boolean override) {
+    public static void create(CalRecord[] calRecords, long addativeOffset, Context context) { create(calRecords, context, false, addativeOffset); }
+    public static void create(CalRecord[] calRecords, Context context) { create(calRecords, context, false, 0); }
+    public static void create(CalRecord[] calRecords, Context context, boolean override, long addativeOffset) {
         //TODO: Change calibration.last and other queries to order calibrations by timestamp rather than ID
         Log.w("CALIBRATION-CHECK-IN: ", "Creating Calibration Record");
         Sensor sensor = Sensor.currentSensor();
@@ -242,6 +243,7 @@ public static void create(CalRecord[] calRecords, Context context, boolean overr
 //        CalRecord secondCalRecord = calRecords[calRecords.length - 1];
         //TODO: Figgure out how the ratio between the two is determined
         double calSlope = ((secondCalRecord.getScale() / secondCalRecord.getSlope()) + (3 * firstCalRecord.getScale() / firstCalRecord.getSlope())) * 250;
+
         double calIntercept = (((secondCalRecord.getScale() * secondCalRecord.getIntercept()) / secondCalRecord.getSlope()) + ((3 * firstCalRecord.getScale() * firstCalRecord.getIntercept()) / firstCalRecord.getSlope())) / -4;
 
         Log.d("CAL CHECK IN ", "fDecay "+firstCalRecord.getDecay());
@@ -291,14 +293,14 @@ public static void create(CalRecord[] calRecords, Context context, boolean overr
 
                     calibration.save();
 
-                    adjustRecentBgReadings(5);
+//                    adjustRecentBgReadings(5);
                     CalibrationSendQueue.addToQueue(calibration, context);
                     Calibration.requestCalibrationIfRangeTooNarrow();
                 }
             }
             if(firstCalRecord.getCalSubrecords()[0] != null && firstCalRecord.getCalSubrecords()[2] == null) {
                 if(Calibration.latest(2).size() == 1) {
-                    Calibration.create(calRecords, context, true);
+                    Calibration.create(calRecords, context, true, 0);
                 }
             }
             Notifications.notificationSetter(context);
@@ -322,6 +324,17 @@ public static boolean is_new(CalSubrecord calSubrecord) {
             return false;
         }
     }
+    public static Calibration getForTimestamp(double timestamp) {
+        Sensor sensor = Sensor.currentSensor();
+        return new Select()
+                .from(Calibration.class)
+                .where("Sensor = ? ", sensor.getId())
+                .where("slope_confidence != 0")
+                .where("sensor_confidence != 0")
+                .where("timestamp < ?", timestamp)
+                .orderBy("timestamp desc")
+                .executeSingle();
+    }
 
     public static Calibration create(double bg, Context context) {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
@@ -401,8 +414,8 @@ public static void calculate_w_l_s() {
             List<Calibration> calibrations = allForSensorInLastFourDays(); //5 days was a bit much, dropped this to 4
             if (calibrations.size() == 1) {
                 Calibration calibration = Calibration.last();
-                calibration.intercept = calibration.bg;
-                calibration.slope = 0;
+                calibration.slope = 1;
+                calibration.intercept = calibration.bg - (calibration.raw_value * calibration.slope);
                 calibration.save();
             } else {
                 for (Calibration calibration : calibrations) {
@@ -500,7 +513,7 @@ public static void adjustRecentBgReadings() {// This just adjust the last 30 bg
     public static void adjustRecentBgReadings(int adjustCount) {
         //TODO: add some handling around calibration overrides as they come out looking a bit funky
         List<Calibration> calibrations = Calibration.latest(3);
-        List<BgReading> bgReadings = BgReading.latest(adjustCount);
+        List<BgReading> bgReadings = BgReading.latestUnCalculated(adjustCount);
         if (calibrations.size() == 3) {
             int denom = bgReadings.size();
             Calibration latestCalibration = calibrations.get(0);
@@ -594,7 +607,11 @@ public static double max_recent() {
                 .where("timestamp > ?", (new Date().getTime() - (60000 * 60 * 24 * 4)))
                 .orderBy("bg desc")
                 .executeSingle();
-        return calibration.bg;
+        if(calibration != null) {
+            return calibration.bg;
+        } else {
+            return 120;
+        }
     }
 
     public static double min_recent() {
@@ -607,7 +624,11 @@ public static double min_recent() {
                 .where("timestamp > ?", (new Date().getTime() - (60000 * 60 * 24 * 4)))
                 .orderBy("bg asc")
                 .executeSingle();
-        return calibration.bg;
+        if(calibration != null) {
+            return calibration.bg;
+        } else {
+            return 100;
+        }
     }
 
     public static List<Calibration> latest(int number) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
index 335ac4a..589bb4a 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
@@ -20,12 +20,22 @@
  */
 public class NavDrawerBuilder {
     public final List<Calibration> last_two_calibrations = Calibration.latest(2);
-    public final List<BgReading> last_two_bgReadings = BgReading.latest(2);
+    public final List<BgReading> last_two_bgReadings = BgReading.latestUnCalculated(2);
     public final List<BgReading> bGreadings_in_last_30_mins = BgReading.last30Minutes();
     public final boolean is_active_sensor = Sensor.isActive();
     public final double time_now = new Date().getTime();
+    public List<Intent> nav_drawer_intents;
+    public List<String> nav_drawer_options;
+    public Context context;
 
-    public final List<String> nav_drawer_options(Context context) {
+    public NavDrawerBuilder(Context aContext) {
+        context = aContext;
+        this.nav_drawer_intents = nav_drawer_intents();
+        this.nav_drawer_options = nav_drawer_options();
+
+    }
+
+    private final List<String> nav_drawer_options() {
         List<String> options = new ArrayList<String>();
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
         boolean IUnderstand = prefs.getBoolean("I_understand", false);
@@ -43,32 +53,42 @@
 //        options.add("Sensor Data Table");
 
         if(is_active_sensor) {
-            if(last_two_bgReadings.size() > 1) {
-                if(last_two_calibrations.size() > 1) {
-                    if(bGreadings_in_last_30_mins.size() >= 2) {
-                        if (time_now - last_two_calibrations.get(0).timestamp < (1000 * 60 * 60)) { //Put steps in place to discourage over calibration
-                            options.add("Override Calibration");
+            if(!CollectionServiceStarter.isBTShare(context)) {
+                if (last_two_bgReadings.size() > 1) {
+                    if (last_two_calibrations.size() > 1) {
+                        if (bGreadings_in_last_30_mins.size() >= 2) {
+                            if (time_now - last_two_calibrations.get(0).timestamp < (1000 * 60 * 60)) { //Put steps in place to discourage over calibration
+                                options.add("Override Calibration");
+                            } else {
+                                options.add("Add Calibration");
+                            }
                         } else {
-                            options.add("Add Calibration");
+                            options.add("Cannot Calibrate right now");
+                        }
+                        if (last_two_calibrations.get(0).slope >= 1.4 || last_two_calibrations.get(0).slope <= 0.5) {
+                            options.add("Add Double Calibration");
                         }
-                    } else { options.add("Cannot Calibrate right now"); }
-                    if (last_two_calibrations.get(0).slope >= 1.4 || last_two_calibrations.get(0).slope <= 0.5) { options.add("Add Double Calibration"); }
-                } else { options.add("Add Double Calibration"); }
+                    } else {
+                        options.add("Add Double Calibration");
+                    }
+                }
             }
             options.add("Stop Sensor");
         } else { options.add("Start Sensor"); }
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            if(CollectionServiceStarter.isBTWixel(context)) {
+            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isBTShare(context)) {
                 options.add("Scan for BT");
             }
         }
+        options.add("System Status");
         options.add("Settings");
 //        options.add("Fake Numbers");
 //        options.add("Add Double Calibration");
+//        options.add("Share Test");
         return options;
     }
 
-    public final List<Intent> nav_drawer_intents(Context context) {
+    private List<Intent> nav_drawer_intents() {
         List<Intent> options = new ArrayList<Intent>();
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
         boolean IUnderstand = prefs.getBoolean("I_understand", false);
@@ -87,28 +107,38 @@
 
 
         if(is_active_sensor) {
-            if(last_two_bgReadings.size() > 1) {
-                if (last_two_calibrations.size() > 1) {
-                    if(bGreadings_in_last_30_mins.size() >= 2) {
-                         if (time_now - last_two_calibrations.get(0).timestamp < (1000 * 60 * 60)) { //Put steps in place to discourage over calibration
-                             options.add(new Intent(context, CalibrationOverride.class));
-                         } else {
-                             options.add(new Intent(context, AddCalibration.class));
-                         }
-                    } else { options.add(new Intent(context, Home.class)); }
-                    if (last_two_calibrations.get(0).slope >= 1.4 || last_two_calibrations.get(0).slope <= 0.5) { options.add(new Intent(context, DoubleCalibrationActivity.class)); }
-                } else { options.add(new Intent(context, DoubleCalibrationActivity.class)); }
+            if(!CollectionServiceStarter.isBTShare(context)) {
+                if (last_two_bgReadings.size() > 1) {
+                    if (last_two_calibrations.size() > 1) {
+                        if (bGreadings_in_last_30_mins.size() >= 2) {
+                            if (time_now - last_two_calibrations.get(0).timestamp < (1000 * 60 * 60)) { //Put steps in place to discourage over calibration
+                                options.add(new Intent(context, CalibrationOverride.class));
+                            } else {
+                                options.add(new Intent(context, AddCalibration.class));
+                            }
+                        } else {
+                            options.add(new Intent(context, Home.class));
+                        }
+                        if (last_two_calibrations.get(0).slope >= 1.4 || last_two_calibrations.get(0).slope <= 0.5) {
+                            options.add(new Intent(context, DoubleCalibrationActivity.class));
+                        }
+                    } else {
+                        options.add(new Intent(context, DoubleCalibrationActivity.class));
+                    }
+                }
             }
             options.add(new Intent(context, StopSensor.class));
         } else { options.add(new Intent(context, StartNewSensor.class)); }
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            if(CollectionServiceStarter.isBTWixel(context)) {
+            if(CollectionServiceStarter.isBTWixel(context) || CollectionServiceStarter.isBTShare(context)) {
                 options.add(new Intent(context, BluetoothScan.class));
             }
         }
+        options.add(new Intent(context, SystemStatus.class));
         options.add(new Intent(context, SettingsActivity.class));
 //        options.add(new Intent(context, FakeNumbers.class));
 //        options.add(new Intent(context, DoubleCalibrationActivity.class));
+//        options.add(new Intent(context, ShareTest.class));
         return options;
     }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java b/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
index ac13a64..51fee77 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
@@ -77,8 +77,8 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
             }
         });
 
-        navDrawerBuilder = new NavDrawerBuilder();
-        List<String> menu_option_list = navDrawerBuilder.nav_drawer_options(getActivity());
+        navDrawerBuilder = new NavDrawerBuilder(getActivity());
+        List<String> menu_option_list = navDrawerBuilder.nav_drawer_options;
         String[] menu_options = menu_option_list.toArray(new String[menu_option_list.size()]);
 
         mDrawerListView.setAdapter(new ArrayAdapter<String>(
@@ -95,12 +95,12 @@ public boolean isDrawerOpen() {
     }
 
     public void setUp(int fragmentId, DrawerLayout drawerLayout, String current_activity, Context context) {
-        navDrawerBuilder = new NavDrawerBuilder();
+        navDrawerBuilder = new NavDrawerBuilder(context);
         menu_name = current_activity;
-        menu_option_list = navDrawerBuilder.nav_drawer_options(context);
+        menu_option_list = navDrawerBuilder.nav_drawer_options;
         String[] menu_options = menu_option_list.toArray(new String[menu_option_list.size()]);
         menu_position = menu_option_list.indexOf(menu_name);
-       intent_list = navDrawerBuilder.nav_drawer_intents(context);
+        intent_list = navDrawerBuilder.nav_drawer_intents;
 
         mFragmentContainerView = getActivity().findViewById(fragmentId);
         mDrawerLayout = drawerLayout;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 3e45077..f304791 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -66,7 +66,6 @@
     private ForegroundServiceStarter foregroundServiceStarter;
     private int mConnectionState = STATE_DISCONNECTED;
     private BluetoothDevice device;
-    int mStartMode;
 
     private Context mContext = null;
 
@@ -80,31 +79,60 @@
     public final static UUID xDripDataCharacteristic = UUID.fromString(HM10Attributes.HM_RX_TX);
 
     @Override
+    public IBinder onBind(Intent intent) {
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    @Override
     public void onCreate() {
         foregroundServiceStarter = new ForegroundServiceStarter(getApplicationContext(), this);
         foregroundServiceStarter.start();
         mContext = getApplicationContext();
         dexCollectionService = this;
         listenForChangeInSettings();
-        this.startService(new Intent(this, SyncService.class));
         Log.w(TAG, "STARTING SERVICE");
     }
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
+            setFailoverTimer();
+        } else {
+            return START_NOT_STICKY;
+        }
         attemptConnection();
         return START_STICKY;
     }
 
     @Override
     public void onDestroy() {
-        setRetryTimer();
+        super.onDestroy();
         close();
         foregroundServiceStarter.stop();
+        setRetryTimer();
         Log.w(TAG, "SERVICE STOPPED");
     }
 
-    //TODO: Move this somewhere more reusable
+    public void setRetryTimer() {
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
+            long retry_in = (1000 * 60 * 2);
+            Log.d(TAG, "Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+            Calendar calendar = Calendar.getInstance();
+            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+        }
+    }
+
+    public void setFailoverTimer() { //Sometimes it gets stuck in limbo on 4.4, this should make it try again
+        if (CollectionServiceStarter.isBTWixel(getApplicationContext())) {
+            long retry_in = (1000 * 60 * 5);
+            Log.d(TAG, "Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+            Calendar calendar = Calendar.getInstance();
+            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+        }
+    }
+
     public void listenForChangeInSettings() {
         SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() {
             public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
@@ -121,7 +149,7 @@ public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
                     }
                 }
                 if(key.compareTo("dex_collection_method") == 0) {
-                    CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter();
+                    CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
                     collectionServiceStarter.start(getApplicationContext());
                 }
             }
@@ -131,54 +159,37 @@ public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
     }
 
     public void attemptConnection() {
-        if (device != null) {
-            mConnectionState = mBluetoothManager.getConnectionState(device, BluetoothProfile.GATT);
-        }
-        Log.w(TAG, "Connection state: " + mConnectionState);
-        if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
-            ActiveBluetoothDevice btDevice = new Select().from(ActiveBluetoothDevice.class)
-                    .orderBy("_ID desc")
-                    .executeSingle();
-            if (btDevice != null) {
-                mDeviceName = btDevice.name;
-                mDeviceAddress = btDevice.address;
-
-                if (mBluetoothManager == null) {
-                    mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-                    if (mBluetoothManager == null) {
-                        Log.w(TAG, "Unable to initialize BluetoothManager.");
+        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+        if (mBluetoothManager != null) {
+            mBluetoothAdapter = mBluetoothManager.getAdapter();
+            if (mBluetoothAdapter != null) {
+                if (device != null) {
+                    mConnectionState = STATE_DISCONNECTED;
+                    for (BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
+                        if (bluetoothDevice.getAddress().compareTo(device.getAddress()) == 0) {
+                            mConnectionState = STATE_CONNECTED;
+                        }
                     }
                 }
-                if (mBluetoothManager != null) {
-                    mBluetoothAdapter = mBluetoothManager.getAdapter();
-                    if (mBluetoothAdapter == null) {
-                        Log.w(TAG, "Unable to obtain a BluetoothAdapter.");
-                        setRetryTimer();
-                    }
-                    is_connected = connect(mDeviceAddress);
-                    if (is_connected) {
-                        Log.w(TAG, "connected to device");
-                    } else {
-                        Log.w(TAG, "Unable to connect to device");
-                        setRetryTimer();
-                    }
 
-                } else {
-                    Log.w(TAG, "Still no bluetooth Manager");
-                    setRetryTimer();
+                Log.w(TAG, "Connection state: " + mConnectionState);
+                if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
+                    ActiveBluetoothDevice btDevice = ActiveBluetoothDevice.first();
+                    if (btDevice != null) {
+                        mDeviceName = btDevice.name;
+                        mDeviceAddress = btDevice.address;
+                        if (mBluetoothAdapter.isEnabled() && mBluetoothAdapter.getRemoteDevice(mDeviceAddress) != null) {
+                            connect(mDeviceAddress);
+                            return;
+                        }
+                    }
+                } else if (mConnectionState == STATE_CONNECTED) { //WOOO, we are good to go, nothing to do here!
+                    Log.w(TAG, "Looks like we are already connected, going to read!");
+                    return;
                 }
-            } else {
-                Log.w(TAG, "No bluetooth device to try to connect to");
-                setRetryTimer();
             }
         }
-    }
-
-    public void setRetryTimer() {
-        Calendar calendar = Calendar.getInstance();
-        AlarmManager alarm = (AlarmManager)getSystemService(ALARM_SERVICE);
-        alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + (1000 * 60 * 2), PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
-        Log.w(TAG, "Retry set for" +  (((calendar.getTimeInMillis() + (1000 * 60 * 2)) - (int) (new Date().getTime())) / (60000)) + "mins from now!");
+        setRetryTimer();
     }
 
     private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
@@ -186,12 +197,12 @@ public void setRetryTimer() {
         public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
             if (newState == BluetoothProfile.STATE_CONNECTED) {
                 mConnectionState = STATE_CONNECTED;
+                ActiveBluetoothDevice.connected();
                 Log.w(TAG, "Connected to GATT server.");
-                Log.w(TAG, "Attempting to start service discovery: " +
-                        mBluetoothGatt.discoverServices());
-
+                mBluetoothGatt.discoverServices();
             } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                 mConnectionState = STATE_DISCONNECTED;
+                ActiveBluetoothDevice.disconnected();
                 Log.w(TAG, "Disconnected from GATT server.");
                 setRetryTimer();
             }
@@ -203,143 +214,62 @@ public void onServicesDiscovered(BluetoothGatt gatt, int status) {
                 for (BluetoothGattService gattService : mBluetoothGatt.getServices()) {
                     Log.w(TAG, "Service Found");
                     for (BluetoothGattCharacteristic gattCharacteristic : gattService.getCharacteristics()) {
-                        Log.w(TAG, "Characteristic Found");
                         setCharacteristicNotification(gattCharacteristic, true);
                     }
                 }
-                Log.w(TAG, "onServicesDiscovered received success: " + status);
-            } else {
-                Log.w(TAG, "onServicesDiscovered received: " + status);
             }
         }
 
         @Override
-        public void onCharacteristicRead(BluetoothGatt gatt,
-                                         BluetoothGattCharacteristic characteristic,
-                                         int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
-            }
-        }
-
-        @Override
-        public void onCharacteristicChanged(BluetoothGatt gatt,
-                                            BluetoothGattCharacteristic characteristic) {
-            broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
-        }
-};
-
-    private void broadcastUpdate(final String action) {
-    }
-
-    private void broadcastUpdate(final String action,
-                                 final BluetoothGattCharacteristic characteristic) {
-
-        final byte[] data = characteristic.getValue();
-
-        if (data != null && data.length > 0) {
-            setSerialDataToTransmitterRawData(data, data.length);
-        }
-    }
-
-    public class LocalBinder extends Binder {
-        DexCollectionService getService() {
-            return DexCollectionService.this;
-        }
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return mBinder;
-    }
-
-    @Override
-    public boolean onUnbind(Intent intent) {
-        close();
-        return super.onUnbind(intent);
-    }
-
-    private final IBinder mBinder = new LocalBinder();
-    public boolean initialize() {
-        if (mBluetoothManager == null) {
-            mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-            if (mBluetoothManager == null) {
-                Log.w(TAG, "Unable to initialize BluetoothManager.");
-                return false;
-            }
+        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
+            final byte[] data = characteristic.getValue();
+            if (data != null && data.length > 0) { setSerialDataToTransmitterRawData(data, data.length); }
         }
-
-        mBluetoothAdapter = mBluetoothManager.getAdapter();
-        if (mBluetoothAdapter == null) {
-            Log.w(TAG, "Unable to obtain a BluetoothAdapter.");
-            return false;
-        }
-        return true;
-    }
+    };
 
     public boolean connect(final String address) {
-        Log.w(TAG, "CONNECTING TO DEVICE");
-        Log.w(TAG, address);
+        Log.w(TAG, "going to connect to device at address" + address);
         if (mBluetoothAdapter == null || address == null) {
             Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
+            setRetryTimer();
             return false;
         }
-        if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress)
-                && mBluetoothGatt != null) {
-            Log.w(TAG, "Trying to use an existing mBluetoothGatt for connection.");
-            if (mBluetoothGatt.connect()) {
-                mConnectionState = STATE_CONNECTING;
-                return true;
-            } else {
-                return false;
-            }
+        if (mBluetoothGatt != null) {
+            Log.w(TAG, "BGatt isnt null, Closing.");
+            mBluetoothGatt.close();
+            mBluetoothGatt = null;
         }
         device = mBluetoothAdapter.getRemoteDevice(address);
         if (device == null) {
             Log.w(TAG, "Device not found.  Unable to connect.");
+            setRetryTimer();
             return false;
         }
-        mBluetoothGatt = device.connectGatt(this, true, mGattCallback);
         Log.w(TAG, "Trying to create a new connection.");
-        mBluetoothDeviceAddress = address;
+        mBluetoothGatt = device.connectGatt(getApplicationContext(), true, mGattCallback);
         mConnectionState = STATE_CONNECTING;
         return true;
     }
 
     public void disconnect() {
-        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
-            Log.w(TAG, "BluetoothAdapter not initialized");
-            return;
-        }
+        if ( mBluetoothGatt == null) { return; }
         mBluetoothGatt.disconnect();
+        Log.d(TAG, "Gatt Disconnect");
     }
-
     public void close() {
-        disconnect();
         if (mBluetoothGatt == null) {
             return;
         }
         mBluetoothGatt.close();
+        setRetryTimer();
         mBluetoothGatt = null;
         mConnectionState = STATE_DISCONNECTED;
+        Log.w(TAG, "bt Disconnected");
     }
 
-    public void readCharacteristic(BluetoothGattCharacteristic characteristic) {
-        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
-            Log.w(TAG, "BluetoothAdapter not initialized");
-            return;
-        }
-        mBluetoothGatt.readCharacteristic(characteristic);
-    }
-
-    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic,
-                                              boolean enabled) {
-        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
-            Log.w(TAG, "BluetoothAdapter not initialized");
-            return;
-        }
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) { return; }
         mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
-        Log.w(TAG, "UUID FOUND: " + characteristic.getUuid());
         if (xDripDataCharacteristic.equals(characteristic.getUuid())) {
             Log.w(TAG, "UUID MATCH FOUND!!! " + characteristic.getUuid());
             BluetoothGattDescriptor descriptor = characteristic.getDescriptor(
@@ -350,7 +280,6 @@ public void setCharacteristicNotification(BluetoothGattCharacteristic characteri
     }
 
     public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
-
         Log.w(TAG, "received some data!");
         Long timestamp = new Date().getTime();
         TransmitterData transmitterData = TransmitterData.create(buffer, len, timestamp);
@@ -360,7 +289,7 @@ public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
                 sensor.latest_battery_level = transmitterData.sensor_battery_level;
                 sensor.save();
 
-                BgReading bgReading = BgReading.create(transmitterData.raw_data, this, timestamp);
+                BgReading.create(transmitterData.raw_data, this, timestamp);
             } else {
                 Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
             }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
new file mode 100644
index 0000000..ae9d37e
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
@@ -0,0 +1,633 @@
+package com.eveningoutpost.dexdrip.Services;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.preference.PreferenceManager;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.activeandroid.query.Select;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.ReadDataShare;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.CalRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.EGVRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.SensorRecord;
+import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.Sensor;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
+import com.eveningoutpost.dexdrip.UtilityModels.DexShareAttributes;
+import com.eveningoutpost.dexdrip.UtilityModels.ForegroundServiceStarter;
+import com.eveningoutpost.dexdrip.UtilityModels.HM10Attributes;
+
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import java.util.logging.Logger;
+
+import rx.Observable;
+import rx.functions.Action1;
+
+public class DexShareCollectionService extends Service {
+    private final static String TAG = DexShareCollectionService.class.getSimpleName();
+    private String mDeviceAddress;
+    private String mDeviceName;
+    private boolean is_connected = false;
+    private boolean reconnecting = false;
+
+    private BluetoothManager mBluetoothManager;
+    private BluetoothAdapter mBluetoothAdapter;
+    private BluetoothGatt mBluetoothGatt;
+    private String mBluetoothDeviceAddress;
+    private int mConnectionState = STATE_DISCONNECTED;
+    private BluetoothDevice device;
+
+    private static final int STATE_DISCONNECTED = BluetoothProfile.STATE_DISCONNECTED;
+    private static final int STATE_DISCONNECTING = BluetoothProfile.STATE_DISCONNECTING;
+    private static final int STATE_CONNECTING = BluetoothProfile.STATE_CONNECTING;
+    private static final int STATE_CONNECTED = BluetoothProfile.STATE_CONNECTED;
+
+    private BluetoothGattService mShareService;
+    private BluetoothGattCharacteristic mAuthenticationCharacteristic;
+    private BluetoothGattCharacteristic mSendDataCharacteristic;
+    private BluetoothGattCharacteristic mReceiveDataCharacteristic;
+    private BluetoothGattCharacteristic mCommandCharacteristic;
+    private BluetoothGattCharacteristic mResponseCharacteristic;
+    private BluetoothGattCharacteristic mHeartBeatCharacteristic;
+
+    //Gatt Tasks
+    public final int GATT_NOTHING = 0;
+    public final int GATT_SETUP = 1;
+    public final int GATT_WRITING_COMMANDS = 2;
+    public final int GATT_READING_RESPONSE = 3;
+    public int successfulWrites;
+
+    //RXJAVA FUN
+    Action1<byte[]> mDataResponseListener;
+    public int currentGattTask;
+    public int step;
+    public List<byte[]> writePackets;
+    public int recordType;
+    SharedPreferences prefs;
+    ReadDataShare readData;
+
+    public boolean state_authSucess = false;
+    public boolean state_authInProgress = false;
+    public boolean state_notifSetupSucess = false;
+
+    public boolean shouldDisconnect = true;
+    public boolean share2 = false;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        readData = new ReadDataShare(this);
+        final IntentFilter bondintent = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        registerReceiver(mPairReceiver, bondintent);
+        prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
+        listenForChangeInSettings();
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        share2 = prefs.getBoolean("share_auth_mode_two", false);
+        int currentapiVersion = android.os.Build.VERSION.SDK_INT;
+        if (currentapiVersion < android.os.Build.VERSION_CODES.LOLLIPOP){
+            shouldDisconnect = false;
+        }
+        if (CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            setFailoverTimer();
+        } else {
+            return START_NOT_STICKY;
+        }
+        if (Sensor.currentSensor() == null) {
+            setRetryTimer();
+            return START_NOT_STICKY;
+        }
+        Log.w(TAG, "STARTING SERVICE");
+        attemptConnection();
+        return START_STICKY;
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        close();
+        setRetryTimer();
+        unregisterReceiver(mPairReceiver);
+        Log.w(TAG, "SERVICE STOPPED");
+    }
+
+    public SharedPreferences.OnSharedPreferenceChangeListener prefListener = new SharedPreferences.OnSharedPreferenceChangeListener() {
+        public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
+            if (key.compareTo("dex_collection_method") == 0) {
+                CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(getApplicationContext());
+                collectionServiceStarter.start(getApplicationContext());
+            }
+        }
+    };
+
+    public void listenForChangeInSettings() {
+        prefs.registerOnSharedPreferenceChangeListener(prefListener);
+    }
+
+    public void setRetryTimer() {
+        if (CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            BgReading bgReading = BgReading.last();
+            long retry_in;
+            if (bgReading != null) {
+                retry_in = Math.min(Math.max((1000 * 30), (1000 * 60 * 5) - (new Date().getTime() - bgReading.timestamp) + 20), (1000 * 60 * 5));
+            } else {
+                retry_in = (1000 * 60);
+            }
+            Log.d(TAG, "Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+            Calendar calendar = Calendar.getInstance();
+            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexShareCollectionService.class), 0));
+        }
+    }
+
+    public void setFailoverTimer() { //Sometimes it gets stuck in limbo on 4.4, this should make it try again
+        if (CollectionServiceStarter.isBTShare(getApplicationContext())) {
+            long retry_in = (1000 * 60 * 5);
+            Log.d(TAG, "Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
+            Calendar calendar = Calendar.getInstance();
+            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+            alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexShareCollectionService.class), 0));
+        }
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    public void attemptConnection() {
+        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+        if (mBluetoothManager != null) {
+            if (device != null) {
+                mConnectionState = STATE_DISCONNECTED;
+                for (BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
+                    if (bluetoothDevice.getAddress().compareTo(device.getAddress()) == 0) {
+                        mConnectionState = STATE_CONNECTED;
+                    }
+                }
+            }
+            Log.w(TAG, "Connection state: " + mConnectionState);
+            if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
+                ActiveBluetoothDevice btDevice = ActiveBluetoothDevice.first();
+                if (btDevice != null) {
+                    mDeviceName = btDevice.name;
+                    mDeviceAddress = btDevice.address;
+                    mBluetoothAdapter = mBluetoothManager.getAdapter();
+                    if (mBluetoothAdapter.isEnabled() && mBluetoothAdapter.getRemoteDevice(mDeviceAddress) != null) {
+                        connect(mDeviceAddress);
+                        return;
+                    } else {
+                        Log.w(TAG, "Bluetooth is disabled or BT device cant be found");
+                        setRetryTimer();
+                        return;
+                    }
+                } else {
+                    Log.w(TAG, "No bluetooth device to try and connect to");
+                    setRetryTimer();
+                    return;
+                }
+            } else if (mConnectionState == STATE_CONNECTED) {
+                Log.w(TAG, "Looks like we are already connected, going to read!");
+                attemptRead();
+                return;
+            } else {
+                setRetryTimer();
+                return;
+            }
+        } else {
+            setRetryTimer();
+            return;
+        }
+    }
+
+    public void attemptRead() {
+        Log.d(TAG, "Attempting to read data");
+        final Action1<Long> systemTimeListener = new Action1<Long>() {
+            @Override
+            public void call(Long s) {
+                if (s != null) {
+                    Log.d(TAG, "Made the full round trip, got " + s + " as the system time");
+                    final long addativeSystemTimeOffset = new Date().getTime() - s;
+
+                    final Action1<EGVRecord[]> evgRecordListener = new Action1<EGVRecord[]>() {
+                        @Override
+                        public void call(EGVRecord[] egvRecords) {
+                            if (egvRecords != null) {
+                                Log.d(TAG, "Made the full round trip, got " + egvRecords.length + " EVG Records");
+                                BgReading.create(egvRecords, addativeSystemTimeOffset, getApplicationContext());
+                                if(shouldDisconnect) {
+                                    stopSelf();
+                                } else {
+                                    setRetryTimer();
+                                }
+                            }
+                        }
+                    };
+
+                    final Action1<SensorRecord[]> sensorRecordListener = new Action1<SensorRecord[]>() {
+                        @Override
+                        public void call(SensorRecord[] sensorRecords) {
+                            if (sensorRecords != null) {
+                                Log.d(TAG, "Made the full round trip, got " + sensorRecords.length + " Sensor Records");
+                                BgReading.create(sensorRecords, addativeSystemTimeOffset, getApplicationContext());
+                                readData.getRecentEGVs(evgRecordListener);
+                            }
+                        }
+                    };
+
+                    final Action1<CalRecord[]> calRecordListener = new Action1<CalRecord[]>() {
+                        @Override
+                        public void call(CalRecord[] calRecords) {
+                            if (calRecords != null) {
+                                Log.d(TAG, "Made the full round trip, got " + calRecords.length + " Cal Records");
+                                Calibration.create(calRecords, addativeSystemTimeOffset, getApplicationContext());
+                                readData.getRecentSensorRecords(sensorRecordListener);
+                            }
+                        }
+                    };
+                    readData.getRecentCalRecords(calRecordListener);
+                }
+            }
+        };
+        readData.readSystemTime(systemTimeListener);
+    }
+
+    public boolean connect(final String address) {
+        Log.w(TAG, "going to connect to device at address" + address);
+        if (mBluetoothAdapter == null || address == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
+            setRetryTimer();
+            return false;
+        }
+        if (mBluetoothGatt != null) {
+            Log.w(TAG, "BGatt isnt null, Closing.");
+            mBluetoothGatt.close();
+            mBluetoothGatt = null;
+        }
+        for (BluetoothDevice bluetoothDevice : mBluetoothAdapter.getBondedDevices()) {
+            if (bluetoothDevice.getAddress().compareTo(address) == 0) {
+                Log.v(TAG, "Device found, already bonded, going to connect");
+               if(mBluetoothAdapter.getRemoteDevice(bluetoothDevice.getAddress()) != null) {
+                   device = bluetoothDevice;
+                   mBluetoothGatt = device.connectGatt(getApplicationContext(), false, mGattCallback);
+                   return true;
+               }
+            }
+        }
+        device = mBluetoothAdapter.getRemoteDevice(address);
+        if (device == null) {
+            Log.w(TAG, "Device not found.  Unable to connect.");
+            setRetryTimer();
+            return false;
+        }
+        Log.w(TAG, "Trying to create a new connection.");
+        mBluetoothGatt = device.connectGatt(getApplicationContext(), false, mGattCallback);
+        mConnectionState = STATE_CONNECTING;
+        return true;
+    }
+
+    public void authenticateConnection() {
+        Log.w(TAG, "Trying to auth");
+        String receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase() + "000000";
+        if(receiverSn.compareTo("SM00000000000000") == 0) { // They havnt set their serial number, dont bond!
+            setRetryTimer();
+            return;
+        }
+        byte[] bondkey = (receiverSn).getBytes(StandardCharsets.US_ASCII);
+        if (mBluetoothGatt != null) {
+            if (mShareService != null) {
+                if(!share2) {
+                    mAuthenticationCharacteristic = mShareService.getCharacteristic(DexShareAttributes.AuthenticationCode);
+                } else {
+                    mAuthenticationCharacteristic = mShareService.getCharacteristic(DexShareAttributes.AuthenticationCode2);
+                }
+                if (mAuthenticationCharacteristic != null) {
+                    Log.v(TAG, "Auth Characteristic found: " + mAuthenticationCharacteristic.toString());
+                    if (mAuthenticationCharacteristic.setValue(bondkey)) {
+                        mBluetoothGatt.writeCharacteristic(mAuthenticationCharacteristic);
+                    } else {
+                        setRetryTimer();
+                    }
+                } else {
+                    Log.w(TAG, "Authentication Characteristic IS NULL");
+                    setRetryTimer();
+                }
+            } else {
+                Log.w(TAG, "CRADLE SERVICE IS NULL");
+            }
+        } else {
+            setRetryTimer();
+        }
+    }
+
+    public void assignCharacteristics() {
+        if(!share2) {
+            Log.d(TAG, "Setting #1 characteristics");
+            mSendDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageReceiver);
+            mReceiveDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageResponse);
+            mCommandCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Command);
+            mResponseCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Response);
+            mHeartBeatCharacteristic = mShareService.getCharacteristic(DexShareAttributes.HeartBeat);
+        } else {
+            Log.d(TAG, "Setting #1 characteristics");
+            mSendDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageReceiver2);
+            mReceiveDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageResponse2);
+            mCommandCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Command2);
+            mResponseCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Response2);
+            mHeartBeatCharacteristic = mShareService.getCharacteristic(DexShareAttributes.HeartBeat2);
+        }
+    }
+
+    public void setListeners(int listener_number) {
+        Log.w(TAG, "Setting Listener: #" + listener_number);
+        if (listener_number == 1) {
+            step = 2;
+            setCharacteristicIndication(mReceiveDataCharacteristic);
+        } else {
+            step = 3;
+            attemptRead();
+        }
+    }
+
+
+    public void close() {
+        if (mBluetoothGatt == null) {
+            return;
+        }
+        mBluetoothGatt.close();
+        setRetryTimer();
+        mBluetoothGatt = null;
+        mConnectionState = STATE_DISCONNECTED;
+        Log.w(TAG, "bt Disconnected");
+    }
+
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic) {
+        setCharacteristicNotification(characteristic, true);
+    }
+
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {
+        Log.w(TAG, "Characteristic setting notification");
+        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
+        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(HM10Attributes.CLIENT_CHARACTERISTIC_CONFIG));
+        Log.w(TAG, "Descriptor found: " + descriptor.getUuid());
+        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+        mBluetoothGatt.writeDescriptor(descriptor);
+    }
+
+    public void setCharacteristicIndication(BluetoothGattCharacteristic characteristic) {
+        setCharacteristicIndication(characteristic, true);
+    }
+
+    public void setCharacteristicIndication(BluetoothGattCharacteristic characteristic, boolean enabled) {
+        Log.w(TAG, "Characteristic setting indication");
+        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
+        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(HM10Attributes.CLIENT_CHARACTERISTIC_CONFIG));
+        Log.w(TAG, "Descriptor found: " + descriptor.getUuid());
+        descriptor.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
+        mBluetoothGatt.writeDescriptor(descriptor);
+    }
+
+    public void writeCommand(List<byte[]> packets, int aRecordType, Action1<byte[]> dataResponseListener) {
+        mDataResponseListener = dataResponseListener;
+        successfulWrites = 0;
+        writePackets = packets;
+        recordType = aRecordType;
+        step = 0;
+        currentGattTask = GATT_WRITING_COMMANDS;
+        gattWritingStep();
+    }
+
+    public void clearGattTask() {
+        currentGattTask = GATT_NOTHING;
+        step = 0;
+    }
+
+    private void gattSetupStep() {
+        step = 1;
+        if(share2) { assignCharacteristics(); }
+        setListeners(1);
+    }
+
+    private void gattWritingStep() {
+        Log.d(TAG, "Writing command to the Gatt, step: " + step);
+        int index = step;
+        if (index <= (writePackets.size() - 1)) {
+            Log.d(TAG, "Writing: " + writePackets.get(index) + " index: " + index);
+            mSendDataCharacteristic.setValue(writePackets.get(index));
+            if(mBluetoothGatt.writeCharacteristic(mSendDataCharacteristic)) {
+                Log.d(TAG, "Wrote Successfully");
+            }
+        } else {
+            Log.d(TAG, "Done Writing commands");
+            clearGattTask();
+        }
+    }
+
+    private final BroadcastReceiver mPairReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            final BluetoothDevice bondDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+            if (!bondDevice.getAddress().equals(mBluetoothGatt.getDevice().getAddress())) {
+                Log.d(TAG, "Bond state wrong device");
+                return; // That wasnt a device we care about!!
+            }
+
+            if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
+                final int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR);
+                if (state == BluetoothDevice.BOND_BONDED) {
+                    Log.d(TAG, "CALLBACK RECIEVED Bonded");
+                    authenticateConnection();
+                } else if (state == BluetoothDevice.BOND_NONE) {
+                    Log.d(TAG, "CALLBACK RECIEVED: Not Bonded");
+                } else if (state == BluetoothDevice.BOND_BONDING) {
+                    Log.d(TAG, "CALLBACK RECIEVED: Trying to bond");
+                }
+            }
+        }
+    };
+
+    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+            Log.w(TAG, "Gatt state change status: " + status + " new state: " + newState);
+            writeStatusConnectionFailures(status);
+            if (status == 133) {
+                Log.e(TAG, "Got the status 133 bug, GROSS!!");
+            }
+            if (newState == BluetoothProfile.STATE_CONNECTED) {
+                mBluetoothGatt = gatt;
+                device = mBluetoothGatt.getDevice();
+                mConnectionState = STATE_CONNECTED;
+                ActiveBluetoothDevice.connected();
+                Log.w(TAG, "Connected to GATT server.");
+
+                Log.w(TAG, "discovering services");
+                currentGattTask = GATT_SETUP;
+                if (!mBluetoothGatt.discoverServices()) {
+                    Log.w(TAG, "discovering failed");
+                    if(shouldDisconnect) {
+                        stopSelf();
+                    } else {
+                        setRetryTimer();
+                    }
+                }
+            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                mConnectionState = STATE_DISCONNECTED;
+                ActiveBluetoothDevice.disconnected();
+                if(shouldDisconnect) {
+                    stopSelf();
+                } else {
+                    setRetryTimer();
+                }
+                Log.w(TAG, "Disconnected from GATT server.");
+            } else {
+                Log.w(TAG, "Gatt callback... strange state.");
+            }
+        }
+
+        @Override
+        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+            Log.d(TAG, "services discovered " + status);
+           if (status == BluetoothGatt.GATT_SUCCESS) {
+               mShareService = mBluetoothGatt.getService(DexShareAttributes.CradleService);
+               if(mShareService == null) {
+                   mShareService = mBluetoothGatt.getService(DexShareAttributes.CradleService2);
+                   share2 = true;
+               } else {
+                   share2 = false;
+               }
+                assignCharacteristics();
+                authenticateConnection();
+                gattSetupStep();
+            } else {
+                Log.w(TAG, "No Services Discovered!");
+            }
+        }
+
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                Log.v(TAG, "Characteristic Read " + characteristic.getUuid());
+                if(mHeartBeatCharacteristic.getUuid().equals(characteristic.getUuid())) {
+                    Log.v(TAG, "Characteristic Read " + characteristic.getUuid() + " " + characteristic.getValue());
+                    setCharacteristicNotification(mHeartBeatCharacteristic);
+                }
+                mBluetoothGatt.readCharacteristic(mHeartBeatCharacteristic);
+            } else {
+                Log.e(TAG, "Characteristic failed to read");
+            }
+        }
+
+        @Override
+        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
+            UUID charUuid = characteristic.getUuid();
+            Log.d(TAG, "Characteristic Update Received: " + charUuid);
+            if (charUuid.compareTo(mReceiveDataCharacteristic.getUuid()) == 0) {
+                Log.d(TAG, "mCharReceiveData Update");
+                byte[] value = characteristic.getValue();
+                if (value != null) {
+                    Observable.just(characteristic.getValue()).subscribe(mDataResponseListener);
+                }
+            }
+        }
+
+        @Override
+        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
+                Log.d(TAG, "Characteristic onDescriptorWrite ch " + characteristic.getUuid());
+                if(mHeartBeatCharacteristic.getUuid().equals(characteristic.getUuid())) {
+                    state_notifSetupSucess = true;
+                    setCharacteristicIndication(mReceiveDataCharacteristic);
+                }
+                if(mReceiveDataCharacteristic.getUuid().equals(characteristic.getUuid())) {
+                    setCharacteristicIndication(mResponseCharacteristic);
+                }
+                if(mResponseCharacteristic.getUuid().equals(characteristic.getUuid())) {
+                    attemptRead();
+                }
+            } else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
+                if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
+                    device = gatt.getDevice();
+                    bondDevice();
+                } else {
+                    Log.e(TAG, "The phone is trying to read from paired device without encryption. Android Bug?");
+                }
+            } else {
+                Log.e(TAG, "Unknown error writing descriptor");
+            }
+        }
+
+        @Override
+        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Log.d(TAG, "characteristic wrote " + status);
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                Log.d(TAG, "Wrote a characteristic successfully " + characteristic.getUuid());
+                if (mAuthenticationCharacteristic.getUuid().equals(characteristic.getUuid())) {
+                    state_authSucess = true;
+                    mBluetoothGatt.readCharacteristic(mHeartBeatCharacteristic);
+                }
+            } else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
+                if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
+                    device = gatt.getDevice();
+                    state_authInProgress = true;
+                    bondDevice();
+                } else {
+                    Log.e(TAG, "The phone is trying to read from paired device without encryption. Android Bug?");
+                }
+            } else {
+                Log.e(TAG, "Unknown error writing Characteristic");
+            }
+        }
+    };
+
+    public void bondDevice() {
+        final IntentFilter bondintent = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        registerReceiver(mPairReceiver, bondintent);
+        if(!share2){ device.setPin("000000".getBytes()); }
+        device.createBond();
+    }
+
+    private void writeStatusConnectionFailures(int status) {
+        if(status != 0) {
+            Log.e(TAG, "ERRR: GATT_WRITE_NOT_PERMITTED " + (status & BluetoothGatt.GATT_WRITE_NOT_PERMITTED));
+            Log.e(TAG, "ERRR: GATT_INSUFFICIENT_AUTHENTICATION " + (status & BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION));
+            Log.e(TAG, "ERRR: GATT_REQUEST_NOT_SUPPORTED " + (status & BluetoothGatt.GATT_REQUEST_NOT_SUPPORTED));
+            Log.e(TAG, "ERRR: GATT_INSUFFICIENT_ENCRYPTION " + (status & BluetoothGatt.GATT_INSUFFICIENT_ENCRYPTION));
+            Log.e(TAG, "ERRR: GATT_INVALID_OFFSET " + (status & BluetoothGatt.GATT_INVALID_OFFSET));
+            Log.e(TAG, "ERRR: GATT_FAILURE " + (status & BluetoothGatt.GATT_FAILURE));
+            Log.e(TAG, "ERRR: GATT_INVALID_ATTRIBUTE_LENGTH " + (status & BluetoothGatt.GATT_INVALID_ATTRIBUTE_LENGTH));
+            Log.e(TAG, "ERRR: GATT_READ_NOT_PERMITTED" + (status & BluetoothGatt.GATT_READ_NOT_PERMITTED));
+        }
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/SettingsActivity.java b/app/src/main/java/com/eveningoutpost/dexdrip/SettingsActivity.java
index 65cc334..f8a1a80 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/SettingsActivity.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/SettingsActivity.java
@@ -50,6 +50,10 @@ private void setupSimplePreferencesScreen() {
 
         fakeHeader = new PreferenceCategory(this);
         getPreferenceScreen().addPreference(fakeHeader);
+        addPreferencesFromResource(R.xml.pref_share);
+
+        fakeHeader = new PreferenceCategory(this);
+        getPreferenceScreen().addPreference(fakeHeader);
         addPreferencesFromResource(R.xml.pref_data_sync);
 
         fakeHeader = new PreferenceCategory(this);
@@ -67,6 +71,7 @@ private void setupSimplePreferencesScreen() {
         bindPreferenceSummaryToValue(findPreference("dex_collection_method"));
         bindPreferenceSummaryToValue(findPreference("wifi_recievers_addresses"));
         bindPreferenceSummaryToValue(findPreference("units"));
+        bindPreferenceSummaryToValue(findPreference("share_key"));
     }
 
     private static Preference.OnPreferenceChangeListener sBindPreferenceSummaryToValueListener = new Preference.OnPreferenceChangeListener() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java
new file mode 100644
index 0000000..1c6d5cb
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java
@@ -0,0 +1,33 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import java.util.Map;
+
+import retrofit.Callback;
+import retrofit.client.Response;
+import retrofit.http.Body;
+import retrofit.http.POST;
+import retrofit.http.QueryMap;
+
+/**
+ * Created by stephenblack on 3/16/15.
+ */
+public interface DexcomShareInterface {
+    @POST("/Publisher/ReadPublisherLatestGlucoseValues")
+    ShareGlucose[] getShareBg(@QueryMap Map<String, String> options);
+
+    @POST("/General/LoginPublisherAccountByName")
+    void getSessionId(@Body ShareAuthenticationBody body, Callback<Response> callback);
+    //Since this seems to respond with a string we need a callback that will parse the response body
+    //new String(((TypedByteArray) response.getBody()).getBytes());
+
+    @POST("/Publisher/IsRemoteMonitoringSessionActive")
+    void checkSessionActive(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}
+    // returns true or false
+
+    @POST("/Publisher/PostReceiverEgvRecords")
+    void uploadBGRecords(@QueryMap Map<String, String> options, @Body ShareUploadPayload payload, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}
+    // body ShareUploadPayload
+    // status code
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/Egv.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/Egv.java
new file mode 100644
index 0000000..9537753
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/Egv.java
@@ -0,0 +1,65 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.google.gson.annotations.Expose;
+
+/**
+ * Created by stephenblack on 3/19/15.
+ */
+public class Egv {
+    @Expose
+    public int Trend;
+
+    @Expose
+    public int Value;
+
+    @Expose
+    public String ST;
+
+    @Expose
+    public String DT;
+
+
+    public Egv(BgReading bg) {
+        this.Value = (int) bg.calculated_value;
+        this.DT = toDateString(bg.timestamp);
+        this.ST = toDateString(bg.timestamp);
+        this.Trend = slopeOrdinal(bg);
+    }
+
+    public String toDateString(double timestamp) {
+        long shortened = (long) Math.floor((timestamp/1000));
+        return "/Date(" + Long.toString(shortened*1000) + ")/";
+    }
+
+    public int slopeOrdinal(BgReading bg) {
+        double slope_by_minute = bg.calculated_value_slope * 60000;
+        int arrow = 0;
+        if (slope_by_minute <= (-3.5)) {
+            arrow = 7;
+        } else if (slope_by_minute <= (-2)) {
+            arrow = 6;
+        } else if (slope_by_minute <= (-1)) {
+            arrow = 5;
+        } else if (slope_by_minute <= (1)) {
+            arrow = 4;
+        } else if (slope_by_minute <= (2)) {
+            arrow = 3;
+        } else if (slope_by_minute <= (3.5)) {
+            arrow = 2;
+        } else {
+            arrow = 1;
+        }
+        if(bg.hide_slope) {
+            arrow = 9;
+        }
+        return arrow;
+    }
+//    {
+//
+//        "Trend":4,
+//            "ST":"\/Date(1426783106000 - 1426754317000)\/",
+//            "DT":"\/Date(1426754317000)\/",
+//            "Value":97
+//    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareAuthenticationBody.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareAuthenticationBody.java
new file mode 100644
index 0000000..8627217
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareAuthenticationBody.java
@@ -0,0 +1,23 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import com.google.gson.annotations.Expose;
+
+/**
+ * Created by stephenblack on 3/16/15.
+ */
+public class ShareAuthenticationBody {
+    @Expose
+    public String password;
+
+    @Expose
+    public String applicationId;
+
+    @Expose
+    public String accountName;
+
+    public ShareAuthenticationBody(String aPassword, String aAccountName) {
+        this.password = aPassword;
+        this.accountName = aAccountName;
+        this.applicationId = "d89443d2-327c-4a6f-89e5-496bbb0317db";
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareGlucose.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareGlucose.java
new file mode 100644
index 0000000..17dbb1b
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareGlucose.java
@@ -0,0 +1,105 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.BatteryManager;
+import android.provider.BaseColumns;
+import android.util.Log;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.google.gson.annotations.Expose;
+
+/**
+ * Created by stephenblack on 3/16/15.
+ */
+@Table(name = "ShareGlucose", id = BaseColumns._ID)
+public class ShareGlucose extends Model {
+    public Context mContext;
+    @Expose
+    @Column(name = "DT")
+    public String DT;
+
+    @Expose
+    @Column(name = "ST")
+    public String ST;
+
+    @Expose
+    @Column(name = "Trend")
+    public double Trend;
+
+    @Expose
+    @Column(name = "Value")
+    public double Value;
+
+    @Expose
+    @Column(name = "WT")
+    public String WT;
+
+    public void processShareData(Context context) {
+        Log.d("SHARE", "Share Data being processed!"); // TODO maybe set this up??
+//        mContext = context;
+//        Log.d("SHARE", "Timestamp before parsing: " + WT);
+//        Log.d("SHARE", "Timestamp before parsing: " + WT.replaceAll("[^\\d.]", ""));
+//
+//        double timestamp = (Double.parseDouble(WT.replaceAll("[^\\d.]", "")));
+//        Log.d("SHARE", "Timestamp: " + timestamp);
+//        if (!Bg.alreadyExists(timestamp)) {
+//            Log.d("SHARE", "Data looks new!!");
+//            Bg bg = new Bg();
+//            bg.direction = slopeDirection();
+//            bg.battery = Integer.toString(getBatteryLevel());
+//            bg.bgdelta = calculateDelta(timestamp, Value);
+//            bg.datetime = timestamp;
+//            bg.sgv = Integer.toString((int) Value);
+//            bg.save();
+//            DataCollectionService.newDataArrived(mContext, true);
+//            Log.d("SHARE", "Share Data Processed Successfully!");
+//        } else {
+//            Log.d("SHARE", "A Bg Value similar to this timestamp already exists.");
+//        }
+    }
+
+    public String slopeDirection() {
+        switch((int) Trend) {
+            case 1:
+                return "DoubleUp";
+            case 2:
+                return "SingleUp";
+            case 3:
+                return "FortyFiveUp";
+            case 4:
+                return "Flat";
+            case 5:
+                return "FortyFiveDown";
+            case 6:
+                return "SingleDown";
+            case 7:
+                return "DoubleDown";
+            default:
+                return "";
+        }
+    }
+
+
+    public int getBatteryLevel() {
+        Intent batteryIntent = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+        int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
+        int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
+        if(level == -1 || scale == -1) {
+            return 50;
+        }
+        return (int)(((float)level / (float)scale) * 100.0f);
+    }
+
+    public double calculateDelta(double timestamp, double currentValue) {
+//        Bg bg = Bg.mostRecentBefore(timestamp);
+//        if (bg != null && Math.abs(bg.datetime - timestamp) < (60*1000*15)) {
+//            return (bg.sgv_double() - currentValue);
+//        } else {
+            return 0;
+//        }
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java
new file mode 100644
index 0000000..10e1f27
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java
@@ -0,0 +1,351 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.squareup.okhttp.OkHttpClient;
+
+import java.security.cert.CertificateException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+import retrofit.Callback;
+import retrofit.RequestInterceptor;
+import retrofit.RestAdapter;
+import retrofit.RetrofitError;
+import retrofit.android.AndroidLog;
+import retrofit.client.OkClient;
+import retrofit.client.Response;
+import retrofit.converter.GsonConverter;
+import retrofit.mime.TypedByteArray;
+
+/**
+ * Created by stephenblack on 12/26/14.
+ */
+public class ShareRest {
+    private Context mContext;
+    private String login;
+    private String password;
+    private SharedPreferences prefs;
+    OkClient client;
+
+    public static Gson gson = new GsonBuilder()
+            .excludeFieldsWithoutExposeAnnotation()
+            .create();
+
+    public ShareRest(Context context) {
+        client = getOkClient();
+        mContext = context;
+        prefs = PreferenceManager.getDefaultSharedPreferences(context);
+        login = prefs.getString("dexcom_account_name", "");
+        password = prefs.getString("dexcom_account_password", "");
+    }
+
+    public boolean getBgData() {
+        if (prefs.getBoolean("share_poll", false) && login.compareTo("") != 0 && password.compareTo("") != 0) {
+            return loginAndGetData();
+        } else {
+            return false;
+        }
+    }
+    public boolean sendBgData(BgReading bg) {
+        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mContext);
+        String receiverSn = preferences.getString("share_key", "SM00000000").toUpperCase();
+        if (prefs.getBoolean("share_upload", false) && login.compareTo("") != 0 && password.compareTo("") != 0 && receiverSn.compareTo("SM00000000") != 0) {
+            return loginAndSendData(bg);
+        } else {
+            return false;
+        }
+    }
+
+    private boolean loginAndGetData() {
+        try {
+            dexcomShareAuthorizeInterface().getSessionId(new ShareAuthenticationBody(password, login), new Callback() {
+                @Override
+                public void success(Object o, Response response) {
+                    Log.d("ShareRest", "Success!! got a response on auth.");
+                    String returnedSessionId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
+
+                    getBgData(returnedSessionId);
+                }
+
+                @Override
+                public void failure(RetrofitError retrofitError) {
+                    Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
+                }
+            });
+            return true;
+        } catch (Exception e) {
+                Log.e("REST CALL ERROR: ", "BOOOO");
+                    return false;
+        }
+    }
+
+    private boolean loginAndSendData(final BgReading bg) {
+        try {
+            dexcomShareAuthorizeInterface().getSessionId(new ShareAuthenticationBody(password, login), new Callback() {
+                @Override
+                public void success(Object o, Response response) {
+                    Log.d("ShareRest", "Success!! got a response on auth.");
+                    String returnedSessionId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
+
+                    sendBgData(returnedSessionId, bg);
+                }
+
+                @Override
+                public void failure(RetrofitError retrofitError) {
+                    Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
+                }
+            });
+            return true;
+        } catch (Exception e) {
+            Log.e("REST CALL ERROR: ", "BOOOO");
+            return false;
+        }
+    }
+
+    private void getBgData(String sessionId) {
+        DataFetcher dataFetcher = new DataFetcher(mContext, sessionId);
+        dataFetcher.execute((Void) null);
+    }
+
+    private void sendBgData(String sessionId, BgReading bg) {
+        DataSender dataSender = new DataSender(mContext, sessionId, bg);
+        dataSender.execute((Void) null);
+    }
+
+    private DexcomShareInterface dexcomShareAuthorizeInterface() {
+        RestAdapter adapter = authoirizeAdapterBuilder().build();
+        DexcomShareInterface dexcomShareInterface =
+                adapter.create(DexcomShareInterface.class);
+        return dexcomShareInterface;
+    }
+
+    private DexcomShareInterface dexcomShareGetBgInterface() {
+        RestAdapter adapter = getBgAdapterBuilder().build();
+        DexcomShareInterface dexcomShareInterface =
+                adapter.create(DexcomShareInterface.class);
+        return dexcomShareInterface;
+    }
+
+    private DexcomShareInterface dexcomShareSendBgInterface() {
+        RestAdapter adapter = authoirizeAdapterBuilder().build();
+        DexcomShareInterface dexcomShareInterface =
+                adapter.create(DexcomShareInterface.class);
+        return dexcomShareInterface;
+    }
+
+    private DexcomShareInterface checkSessionActive() {
+        RestAdapter adapter = getBgAdapterBuilder().build();
+        DexcomShareInterface checkSessionActive =
+                adapter.create(DexcomShareInterface.class);
+        return checkSessionActive;
+    }
+
+    private RestAdapter.Builder authoirizeAdapterBuilder() {
+        RestAdapter.Builder adapterBuilder = new RestAdapter.Builder();
+        adapterBuilder
+                .setClient(client)
+                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("SHAREREST"))
+                .setEndpoint("https://share1.dexcom.com/ShareWebServices/Services")
+                .setRequestInterceptor(authorizationRequestInterceptor)
+                .setConverter(new GsonConverter(new GsonBuilder()
+                        .excludeFieldsWithoutExposeAnnotation()
+                        .create()));
+        return adapterBuilder;
+    }
+
+    private RestAdapter.Builder getBgAdapterBuilder() {
+        RestAdapter.Builder adapterBuilder = new RestAdapter.Builder();
+        adapterBuilder
+                .setClient(client)
+                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("SHAREREST"))
+                .setEndpoint("https://share1.dexcom.com/ShareWebServices/Services")
+                .setRequestInterceptor(getBgRequestInterceptor)
+                .setConverter(new GsonConverter(new GsonBuilder()
+                        .excludeFieldsWithoutExposeAnnotation()
+                        .create()));
+        return adapterBuilder;
+    }
+
+    RequestInterceptor authorizationRequestInterceptor = new RequestInterceptor() {
+        @Override
+        public void intercept(RequestInterceptor.RequestFacade request) {
+            request.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
+            request.addHeader("Content-Type", "application/json");
+            request.addHeader("Accept", "application/json");
+        }
+    };
+    RequestInterceptor getBgRequestInterceptor = new RequestInterceptor() {
+        @Override
+        public void intercept(RequestInterceptor.RequestFacade request) {
+            request.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
+            request.addHeader("Content-Type", "application/json");
+            request.addHeader("Content-Length", "0");
+            request.addHeader("Accept", "application/json");
+        }
+    };
+
+    public OkHttpClient getOkHttpClient() {
+
+        try {
+            final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
+                @Override
+                public void checkClientTrusted(
+                        java.security.cert.X509Certificate[] chain,
+                        String authType) throws CertificateException {
+                }
+
+                @Override
+                public void checkServerTrusted(
+                        java.security.cert.X509Certificate[] chain,
+                        String authType) throws CertificateException {
+                }
+
+                @Override
+                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                    return null;
+                }
+            } };
+
+            final SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
+            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+
+            OkHttpClient okHttpClient = new OkHttpClient();
+            okHttpClient.setSslSocketFactory(sslSocketFactory);
+            okHttpClient.setHostnameVerifier(new HostnameVerifier() {
+
+                @Override
+                public boolean verify(String hostname, SSLSession session) {
+                        return true;
+                }
+            });
+
+            return okHttpClient;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    public OkClient getOkClient (){
+        OkHttpClient client1 = getOkHttpClient();
+        OkClient _client = new OkClient(client1);
+        return _client;
+    }
+
+    public Map<String, String> queryParamMap(String sessionId) {
+        Map map = new HashMap<String, String>();
+        map.put("sessionID", sessionId);
+        map.put("minutes", String.valueOf(minutesCount()));
+        map.put("maxCount", String.valueOf(requestCount()));
+        return map;
+
+    }
+
+    public class DataFetcher extends AsyncTask<Void, Void, Boolean> {
+        Context mContext;
+        String mSessionId;
+        DataFetcher(Context context, String sessionId) {
+            mContext = context;
+            mSessionId = sessionId;
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            try {
+                try {
+                    final ShareGlucose[] shareGlucoses = dexcomShareGetBgInterface().getShareBg(queryParamMap(mSessionId));
+                    Log.d("REST Success: ", "YAY!");
+                    if(shareGlucoses != null && shareGlucoses.length > 0) {
+                        for (ShareGlucose shareGlucose : shareGlucoses) {
+                            shareGlucose.processShareData(mContext);
+                        }
+                    return true;
+                    }
+                    return false;
+                } catch (Exception e) {
+                    Log.d("REST CALL ERROR: ", "BOOOO");
+                    return false;
+                }
+            }
+            catch (RetrofitError e) { Log.d("Retrofit Error: ", "BOOOO"); }
+            catch (Exception ex) { Log.d("Unrecognized Error: ", "BOOOO"); }
+            return false;
+        }
+    }
+
+    public class DataSender extends AsyncTask<Void, Void, Boolean> {
+        Context mContext;
+        String mSessionId;
+        BgReading mBg;
+        DataSender(Context context, String sessionId, BgReading bg) {
+            mContext = context;
+            mSessionId = sessionId;
+            mBg = bg;
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            try {
+                SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mContext);
+                String receiverSn = preferences.getString("share_key", "SM00000000").toUpperCase();
+                dexcomShareSendBgInterface().uploadBGRecords(querySessionMap(mSessionId), new ShareUploadPayload(receiverSn, mBg), new Callback() {
+                    @Override
+                    public void success(Object o, Response response) {
+                        Log.d("ShareRest", "Success!! Uploaded!!");
+                    }
+
+                    @Override
+                    public void failure(RetrofitError retrofitError) {
+                        Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
+                    }
+                });
+            }
+            catch (RetrofitError e) { Log.d("Retrofit Error: ", "BOOOO"); }
+            catch (Exception ex) { Log.d("Unrecognized Error: ", "BOOOO"); }
+            return false;
+        }
+    }
+    public int requestCount() {
+        BgReading bg = BgReading.last();
+        if(bg != null) {
+            return 20;
+        } else if (bg.timestamp < new Date().getTime()) {
+            return Math.min((int) Math.ceil(((new Date().getTime() - bg.timestamp) / (5 * 1000 * 60))), 10);
+        } else {
+            return 1;
+        }
+    }
+
+    public int minutesCount() {
+        BgReading bg = BgReading.last();
+        if(bg != null && bg.timestamp < new Date().getTime()) {
+            return Math.min((int) Math.ceil(((new Date().getTime() - bg.timestamp) / (1000 * 60))), 1440);
+        } else {
+            return 1440;
+        }
+    }
+
+    public Map<String, String> querySessionMap(String sessionId) {
+        Map map = new HashMap<String, String>();
+        map.put("sessionID", sessionId);
+        return map;
+
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareUploadPayload.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareUploadPayload.java
new file mode 100644
index 0000000..f589c4c
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareUploadPayload.java
@@ -0,0 +1,28 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.google.gson.annotations.Expose;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by stephenblack on 3/19/15.
+ */
+public class ShareUploadPayload {
+    @Expose
+    public String SN;
+
+    @Expose
+    public Egv[] Egvs;
+
+    @Expose
+    public long TA = -5;
+
+    public ShareUploadPayload(String sn, BgReading bg) {
+        this.SN = sn;
+        List<Egv> egvList = new ArrayList<Egv>();
+        egvList.add(new Egv(bg));
+        this.Egvs = egvList.toArray(new Egv[egvList.size()]);
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareTest.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareTest.java
new file mode 100644
index 0000000..bdcd815
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareTest.java
@@ -0,0 +1,537 @@
+package com.eveningoutpost.dexdrip;
+
+import android.app.Activity;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.activeandroid.query.Select;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.PacketBuilder;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.ReadData;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.ReadDataShare;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.CalRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.EGVRecord;
+import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.SensorRecord;
+import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.UtilityModels.DexShareAttributes;
+import com.eveningoutpost.dexdrip.UtilityModels.ForegroundServiceStarter;
+import com.eveningoutpost.dexdrip.UtilityModels.HM10Attributes;
+
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+
+import rx.Observable;
+import rx.functions.Action1;
+
+
+public class ShareTest extends Activity {
+    private final static String TAG = ShareTest.class.getSimpleName();
+    Button button;
+    Button closeButton;
+    Button readButton;
+    Button bondButton;
+    TextView details;
+
+    private String mDeviceName;
+    private String mDeviceAddress;
+    private boolean is_connected = false;
+    private boolean reconnecting = false;
+    SharedPreferences prefs;
+
+    private BluetoothManager mBluetoothManager;
+    private BluetoothAdapter mBluetoothAdapter;
+    private String mBluetoothDeviceAddress;
+    private BluetoothGatt mBluetoothGatt;
+    private ForegroundServiceStarter foregroundServiceStarter;
+    private int mConnectionState = STATE_DISCONNECTED;
+    private BluetoothDevice device;
+    int mStartMode;
+    private Context mContext = null;
+
+    private static final int STATE_DISCONNECTED = BluetoothProfile.STATE_DISCONNECTED;
+    private static final int STATE_DISCONNECTING = BluetoothProfile.STATE_DISCONNECTING;
+    private static final int STATE_CONNECTING = BluetoothProfile.STATE_CONNECTING;
+    private static final int STATE_CONNECTED = BluetoothProfile.STATE_CONNECTED;
+
+    private BluetoothGattService mShareService;
+    private BluetoothGattCharacteristic mAuthenticationCharacteristic;
+    private BluetoothGattCharacteristic mSendDataCharacteristic;
+    private BluetoothGattCharacteristic mReceiveDataCharacteristic;
+    private BluetoothGattCharacteristic mHeartBeatCharacteristic;
+    private BluetoothGattCharacteristic mCommandCharacteristic;
+    private BluetoothGattCharacteristic mResponseCharacteristic;
+
+    //Gatt Tasks
+    public final int GATT_NOTHING = 0;
+    public final int GATT_SETUP = 1;
+    public final int GATT_WRITING_COMMANDS = 2;
+    public final int GATT_READING_RESPONSE = 3;
+    public int successfulWrites;
+
+    //RXJAVA FUN
+    Action1<byte[]> mDataResponseListener;
+
+    public ReadDataShare mReadDataShare;
+
+    public int currentGattTask;
+    public int step;
+
+    public List<byte[]> writePackets;
+    public int recordType;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_share_test);
+        button = (Button) findViewById(R.id.connect);
+        closeButton = (Button) findViewById(R.id.closeConnect);
+        bondButton = (Button) findViewById(R.id.bond);
+        readButton = (Button) findViewById(R.id.read);
+        details = (TextView) findViewById(R.id.connection_details);
+        addListenerOnButton();
+        addListenerOnCloseButton();
+        IntentFilter intent = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        registerReceiver(mPairReceiver, intent);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        close();
+        Log.w(TAG, "CLOSING CONNECTION");
+    }
+
+    public void addListenerOnButton() {
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                attemptConnection();
+            }
+        });
+        readButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                attemptRead();
+            }
+        });
+        bondButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                bond(mBluetoothGatt);
+            }
+        });
+    }
+
+    public void addListenerOnCloseButton() {
+        closeButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                close();
+                details.setText("");
+            }
+        });
+    }
+
+    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+            if (newState == BluetoothProfile.STATE_CONNECTED) {
+                mBluetoothGatt = gatt;
+                mConnectionState = STATE_CONNECTED;
+                ActiveBluetoothDevice.connected();
+                Log.w(TAG, "Connected to GATT server.");
+                Log.w(TAG, "Connection state: Bonded - " + device.getBondState());
+
+                if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
+                    currentGattTask = GATT_SETUP;
+                    mBluetoothGatt.discoverServices();
+
+                } else {
+                    device.setPin("000000".getBytes());
+                    device.createBond();
+                }
+            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                mConnectionState = STATE_DISCONNECTED;
+                ActiveBluetoothDevice.disconnected();
+                Log.w(TAG, "Disconnected from GATT server.");
+            }
+        }
+
+        @Override
+        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                Log.w(TAG, "Services Discovered: " + status);
+                authenticateConnection(gatt);
+
+            }
+        }
+
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                Log.w(TAG, "Characteristic Read");
+                byte[] value = characteristic.getValue();
+                if(value != null) {
+                    Log.w(TAG, "VALUE" + value);
+                } else {
+                    Log.w(TAG, "Characteristic was null");
+                }
+                nextGattStep();
+            } else {
+                Log.w(TAG, "Characteristic failed to read");
+            }
+        }
+
+        @Override
+        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
+            Log.w(TAG, "Characteristic changed");
+            UUID charUuid = characteristic.getUuid();
+            Log.w(TAG, "Characteristic Update Received: " + charUuid);
+            if(charUuid.compareTo(mResponseCharacteristic.getUuid()) == 0) {
+                Log.w(TAG, "mResponseCharacteristic Update");
+            }
+            if(charUuid.compareTo(mCommandCharacteristic.getUuid()) == 0) {
+                Log.w(TAG, "mCommandCharacteristic Update");
+            }
+            if(charUuid.compareTo(mHeartBeatCharacteristic.getUuid()) == 0) {
+                Log.w(TAG, "mHeartBeatCharacteristic Update");
+            }
+            if(charUuid.compareTo(mReceiveDataCharacteristic.getUuid()) == 0) {
+                Log.w(TAG, "mReceiveDataCharacteristic Update");
+                byte[] value = characteristic.getValue();
+                if(value != null) {
+                    Log.w(TAG, "Characteristic: " + value);
+                    Log.w(TAG, "Characteristic: " + value.toString());
+                    Log.w(TAG, "Characteristic getstring: " + characteristic.getStringValue(0));
+                    Log.w(TAG, "SUBSCRIBED TO RESPONSE LISTENER");
+                    Observable.just(characteristic.getValue()).subscribe(mDataResponseListener);
+                } else {
+                    Log.w(TAG, "Characteristic was null");
+                }
+            }
+            Log.w(TAG, "NEW VALUE: " + characteristic.getValue().toString());
+        }
+
+        @Override
+        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+            Log.w(TAG, "Wrote a discriptor, status: " + status);
+            if(step == 2 && currentGattTask == GATT_SETUP) {
+                setListeners(2);
+            } else if(step == 3) {
+                setListeners(3);
+            } else if(step == 4) {
+                setListeners(4);
+            } else if(step == 5) {
+                Log.w(TAG, "Done setting Listeners");
+            }
+        }
+
+        @Override
+        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Log.w(TAG, "Wrote a characteristic: " + status);
+            nextGattStep();
+        }
+    };
+
+    public void attemptConnection() {
+        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+        if (device != null) {
+            details.append("\nConnection state: " + " Device is not null");
+            mConnectionState = mBluetoothManager.getConnectionState(device, BluetoothProfile.GATT);
+        }
+
+        Log.w(TAG, "Connection state: " + mConnectionState);
+        details.append("\nConnection state: " + mConnectionState);
+        if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
+            ActiveBluetoothDevice btDevice = new Select().from(ActiveBluetoothDevice.class)
+                    .orderBy("_ID desc")
+                    .executeSingle();
+            if (btDevice != null) {
+                details.append("\nBT Device: " + btDevice.name);
+                mDeviceName = btDevice.name;
+                mDeviceAddress = btDevice.address;
+                mBluetoothAdapter = mBluetoothManager.getAdapter();
+                boolean newConnection = true;
+                if(newConnection) {
+                    is_connected = connect(mDeviceAddress);
+                    details.append("\nConnecting...: ");
+                }
+            }
+        }
+    }
+
+    public void attemptRead() {
+        final ReadDataShare readData = new ReadDataShare(this);
+        final Action1<Long> systemTimeListener = new Action1<Long>() {
+            @Override
+            public void call(Long s) {
+
+                Log.d(TAG, "Made the full round trip, got " + s + " as the system time");
+                Log.d("SYSTTIME", "Made the full round trip, got " + s + " as the system time");
+                final long addativeSystemTimeOffset = new Date().getTime() - s;
+                Log.d(TAG, "Made the full round trip, got " + addativeSystemTimeOffset + " offset");
+                Log.d("SYSTTIME", "Made the full round trip, got " + addativeSystemTimeOffset + " offset");
+
+                final Action1<CalRecord[]> calRecordListener = new Action1<CalRecord[]>() {
+                    @Override
+                    public void call(CalRecord[] calRecords) {
+                        Log.d(TAG, "Made the full round trip, got " + calRecords.length + " Cal Records");
+                        Calibration.create(calRecords, addativeSystemTimeOffset, getApplicationContext());
+
+                        final Action1<SensorRecord[]> sensorRecordListener = new Action1<SensorRecord[]>() {
+                            @Override
+                            public void call(SensorRecord[] sensorRecords) {
+                                Log.d(TAG, "Made the full round trip, got " + sensorRecords.length + " Sensor Records");
+                                BgReading.create(sensorRecords, addativeSystemTimeOffset, getApplicationContext());
+
+                                final Action1<EGVRecord[]> evgRecordListener = new Action1<EGVRecord[]>() {
+                                    @Override
+                                    public void call(EGVRecord[] egvRecords) {
+                                        Log.d(TAG, "Made the full round trip, got " + egvRecords.length + " EVG Records");
+                                        BgReading.create(egvRecords, addativeSystemTimeOffset, getApplicationContext());
+                                    }
+                                };
+                                readData.getRecentEGVs(evgRecordListener);
+                            }
+                        };
+                        readData.getRecentSensorRecords(sensorRecordListener);
+                    }
+                };
+                readData.getRecentCalRecords(calRecordListener);
+            }
+        };
+        readData.readSystemTime(systemTimeListener);
+    }
+
+    public void bond(BluetoothGatt gatt) {
+        reconnecting = true;
+        attemptConnection();
+    }
+
+    public boolean connect(final String address) {
+
+        details.append("\nConnecting to device");
+        Log.w(TAG, "CONNECTING TO DEVICE");
+        if (mBluetoothAdapter == null || address == null) {
+            details.append("\nBT adapter is null");
+            Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
+            return false;
+        }
+        if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress) && mBluetoothGatt != null) {
+            details.append("\nTrying to use an existing mBluetoothGatt for connection.");
+            if (mBluetoothGatt.connect()) {
+                mConnectionState = STATE_CONNECTING;
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            device = mBluetoothAdapter.getRemoteDevice(address);
+            device.setPin("000000".getBytes());
+            if (device == null) {
+                Log.w(TAG, "Device not found.  Unable to connect.");
+                details.append("\nDevice not found.  Unable to connect.");
+                return false;
+            }
+            mBluetoothGatt = device.connectGatt(getApplicationContext(), true, mGattCallback);
+            Log.w(TAG, "Trying to create a new connection.");
+            details.append("\nTrying to create a new connection to device");
+            mConnectionState = STATE_CONNECTING;
+            return true;
+        }
+    }
+
+    public void authenticateConnection(BluetoothGatt bluetoothGatt) {
+        Log.w(TAG, "Trying to auth");
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
+        String receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
+        if(bluetoothGatt != null) {
+            mBluetoothGatt = bluetoothGatt;
+            mShareService = mBluetoothGatt.getService(DexShareAttributes.CradleService);
+            if (mShareService != null) {
+                mAuthenticationCharacteristic = mShareService.getCharacteristic(DexShareAttributes.AuthenticationCode);
+                if(mAuthenticationCharacteristic != null) {
+                    Log.w(TAG, "Auth Characteristic found: " + mAuthenticationCharacteristic.toString());
+                    mAuthenticationCharacteristic.setValue((receiverSn + "000000").getBytes(StandardCharsets.US_ASCII));
+                    currentGattTask = GATT_SETUP;
+                    step = 1;
+                    bluetoothGatt.writeCharacteristic(mAuthenticationCharacteristic);
+                } else {
+                    Log.w(TAG, "Authentication Characteristic IS NULL");
+                }
+            } else {
+                Log.w(TAG, "CRADLE SERVICE IS NULL");
+            }
+        }
+    }
+
+    public void assignCharacteristics() {
+        mSendDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageReceiver);
+        mReceiveDataCharacteristic = mShareService.getCharacteristic(DexShareAttributes.ShareMessageResponse);
+        mHeartBeatCharacteristic = mShareService.getCharacteristic(DexShareAttributes.HeartBeat);
+        mCommandCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Command);
+        mResponseCharacteristic = mShareService.getCharacteristic(DexShareAttributes.Response);
+    }
+
+    public void setListeners(int listener_number) {
+
+        Log.w(TAG, "Setting Listener: #" + listener_number);
+        if(listener_number == 1) {
+            step = 3;
+            setCharacteristicIndication(mReceiveDataCharacteristic);
+        } else if(listener_number == 3) {
+            setCharacteristicIndication(mResponseCharacteristic);
+            step = 5;
+        }
+     }
+
+    public void disconnect() {
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized");
+            return;
+        }
+        mBluetoothGatt.disconnect();
+    }
+
+    public void close() {
+        disconnect();
+        if (mBluetoothGatt == null) {
+            return;
+        }
+        mBluetoothGatt.close();
+        mBluetoothGatt = null;
+        mConnectionState = STATE_DISCONNECTED;
+        Log.w(TAG, "bt Disconnected");
+    }
+
+    public void readCharacteristic(BluetoothGattCharacteristic characteristic) {
+        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
+            Log.w(TAG, "BluetoothAdapter not initialized");
+            return;
+        }
+        mBluetoothGatt.readCharacteristic(characteristic);
+    }
+
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic){ setCharacteristicNotification(characteristic, true);}
+    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {
+        Log.w(TAG, "Characteristic setting notification");
+        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
+        Log.w(TAG, "UUID FOUND: " + characteristic.getUuid());
+        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(HM10Attributes.CLIENT_CHARACTERISTIC_CONFIG));
+        Log.w(TAG, "Descriptor found: " + descriptor.getUuid());
+        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+        mBluetoothGatt.writeDescriptor(descriptor);
+    }
+
+    public void setCharacteristicIndication(BluetoothGattCharacteristic characteristic){ setCharacteristicIndication(characteristic, true);}
+    public void setCharacteristicIndication(BluetoothGattCharacteristic characteristic, boolean enabled) {
+        Log.w(TAG, "Characteristic setting notification");
+        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
+        Log.w(TAG, "UUID FOUND: " + characteristic.getUuid());
+        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(HM10Attributes.CLIENT_CHARACTERISTIC_CONFIG));
+        Log.w(TAG, "Descriptor found: " + descriptor.getUuid());
+        descriptor.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
+        mBluetoothGatt.writeDescriptor(descriptor);
+    }
+
+    private final BroadcastReceiver mPairReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
+                final int state        = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR);
+                final int prevState    = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.ERROR);
+                if (state == BluetoothDevice.BOND_BONDED) {
+                    Log.d(TAG, "CALLBACK RECIEVED Bonded");
+                    currentGattTask = GATT_SETUP;
+                    mBluetoothGatt.discoverServices();
+                } else if (state == BluetoothDevice.BOND_NONE){
+                    Log.d(TAG, "CALLBACK RECIEVED: Not Bonded");
+                    Toast.makeText(getApplicationContext(), "unBonded", Toast.LENGTH_LONG).show();
+                } else if (state == BluetoothDevice.BOND_BONDING) {
+                    Log.d(TAG, "CALLBACK RECIEVED: Trying to bond");
+                    Toast.makeText(getApplicationContext(), "trying to bond", Toast.LENGTH_LONG).show();
+                }
+            }
+        }
+    };
+
+    public void writeCommand(List<byte[]> packets, int aRecordType, Action1<byte[]> dataResponseListener) {
+        mDataResponseListener = dataResponseListener;
+        successfulWrites = 0;
+        writePackets = packets;
+        recordType = aRecordType;
+        step = 0;
+        currentGattTask = GATT_WRITING_COMMANDS;
+        gattWritingStep();
+    }
+
+    private void nextGattStep() {
+        Log.d(TAG, "Next Gatt Step");
+        step++;
+        switch (currentGattTask) {
+        case GATT_NOTHING:
+            Log.d(TAG, "Next NOTHING: " + step);
+            break;
+        case GATT_SETUP:
+            Log.d(TAG, "Next GATT SETUP: " + step);
+            gattSetupStep();
+            break;
+        case GATT_WRITING_COMMANDS:
+            Log.d(TAG, "Next GATT WRITING: " + step);
+            gattWritingStep();
+            break;
+        }
+    }
+
+    public void clearGattTask() {
+        currentGattTask = GATT_NOTHING;
+        step = 0;
+    }
+
+    private void gattSetupStep() {
+        step = 1;
+        assignCharacteristics();
+        setListeners(1);
+    }
+
+    private void gattWritingStep() {
+        Log.d(TAG, "Writing command to the Gatt, step: " + step);
+        int index = step;
+        if (index <= (writePackets.size() - 1)) {
+            Log.d(TAG, "Writing: " + writePackets.get(index) + " index: " + index);
+            mSendDataCharacteristic.setValue(writePackets.get(index));
+            mBluetoothGatt.writeCharacteristic(mSendDataCharacteristic);
+        } else {
+            clearGattTask();
+        }
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java b/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
index 6c50539..9ffd8b4 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
@@ -49,14 +49,15 @@ protected void onResume(){
         mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManager().findFragmentById(R.id.navigation_drawer);
         mNavigationDrawerFragment.setUp(R.id.navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), menu_name, this);
     }
+    
     @Override
     public void onNavigationDrawerItemSelected(int position) {
-        NavDrawerBuilder navDrawerBuilder = new NavDrawerBuilder();
-        List<String> menu_option_list = navDrawerBuilder.nav_drawer_options(getApplicationContext());
+        NavDrawerBuilder navDrawerBuilder = new NavDrawerBuilder(getApplicationContext());
+        List<String> menu_option_list = navDrawerBuilder.nav_drawer_options;
         int menu_position = menu_option_list.indexOf(menu_name);
 
         if (position != menu_position) {
-            List<Intent> intent_list = navDrawerBuilder.nav_drawer_intents(this);
+            List<Intent> intent_list = navDrawerBuilder.nav_drawer_intents;
             Intent[] intent_array = intent_list.toArray(new Intent[intent_list.size()]);
             startActivity(intent_array[position]);
             finish();
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/SystemStatus.java b/app/src/main/java/com/eveningoutpost/dexdrip/SystemStatus.java
new file mode 100644
index 0000000..36e5385
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/SystemStatus.java
@@ -0,0 +1,174 @@
+package com.eveningoutpost.dexdrip;
+
+import android.app.Activity;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.support.v4.widget.DrawerLayout;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.TextView;
+
+import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
+import com.eveningoutpost.dexdrip.Models.Calibration;
+import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
+
+import java.lang.reflect.Method;
+
+
+public class SystemStatus extends Activity implements NavigationDrawerFragment.NavigationDrawerCallbacks {
+    private String menu_name = "System Status";
+    private NavigationDrawerFragment mNavigationDrawerFragment;
+    public TextView collection_method;
+    public TextView current_device;
+    public TextView connection_status;
+    public TextView notes;
+    public Button restart_collection_service;
+    public Button forget_device;
+    public ImageButton refresh;
+    public SharedPreferences prefs;
+    public BluetoothManager mBluetoothManager;
+    public ActiveBluetoothDevice activeBluetoothDevice;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_system_status);
+        prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
+        mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManager().findFragmentById(R.id.navigation_drawer);
+        mNavigationDrawerFragment.setUp(R.id.navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), menu_name, this);
+
+        collection_method = (TextView)findViewById(R.id.collection_method);
+        connection_status = (TextView)findViewById(R.id.connection_status);
+        current_device = (TextView)findViewById(R.id.remembered_device);
+
+        notes = (TextView)findViewById(R.id.other_notes);
+
+        restart_collection_service = (Button)findViewById(R.id.restart_collection_service);
+        forget_device = (Button)findViewById(R.id.forget_device);
+        refresh = (ImageButton)findViewById(R.id.refresh_current_values);
+
+        set_current_values();
+        restartButtonListener();
+        forgetDeviceListener();
+        refreshButtonListener();
+    }
+
+    @Override
+    public void onNavigationDrawerItemSelected(int position) {
+        mNavigationDrawerFragment.swapContext(position);
+    }
+
+    private void set_current_values() {
+        activeBluetoothDevice = ActiveBluetoothDevice.first();
+        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+        setCollectionMethod();
+        setCurrentDevice();
+        setConnectionStatus();
+        setNotes();
+    }
+
+    public void setCollectionMethod() {
+        collection_method.setText(prefs.getString("dex_collection_method", "BluetoothWixel"));
+    }
+
+    public void setCurrentDevice() {
+        if(activeBluetoothDevice != null) {
+            current_device.setText(activeBluetoothDevice.name);
+        } else {
+            current_device.setText("None Set");
+        }
+    }
+
+    public void setConnectionStatus() {
+        boolean connected = false;
+        if (mBluetoothManager != null && activeBluetoothDevice != null) {
+            for (BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
+                if (bluetoothDevice.getAddress().compareTo(activeBluetoothDevice.address) == 0) {
+                    connected = true;
+                }
+            }
+        }
+        if(connected) {
+            connection_status.setText("Connected");
+        } else {
+            connection_status.setText("Not Connected");
+        }
+    }
+
+    public void setNotes() {
+        if(mBluetoothManager == null) {
+            notes.append("\n- This device does not seem to support bluetooth");
+        } else {
+            if(!mBluetoothManager.getAdapter().isEnabled()) {
+                notes.append("\n- Bluetooth seems to be turned off");
+            } else {
+                if(android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2){
+                    notes.append("\n- The android version of this device is not compatible with Bluetooth Low Energy");
+                }
+            }
+        }
+    }
+
+    public void restartButtonListener() {
+        restart_collection_service.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                CollectionServiceStarter.restartCollectionService(getApplicationContext());
+                set_current_values();
+            }
+        });
+    }
+
+    public void forgetDeviceListener() {
+        forget_device.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                if(mBluetoothManager != null && ActiveBluetoothDevice.first() != null) {
+                    BluetoothAdapter bluetoothAdapter = mBluetoothManager.getAdapter();
+                    if(bluetoothAdapter != null) {
+                        for( BluetoothDevice bluetoothDevice : bluetoothAdapter.getBondedDevices()) {
+                            if(bluetoothDevice.getAddress().compareTo(ActiveBluetoothDevice.first().address) == 0) {
+                                try {
+                                    Method m = bluetoothDevice.getClass().getMethod("removeBond", (Class[]) null);
+                                    m.invoke(bluetoothDevice, (Object[]) null);
+                                    notes.append("\n- Bluetooth unbonded, if using share tell it to forget your device.");
+                                    notes.append("\n- Scan for devices again to set connection back up!");
+                                } catch (Exception e) { Log.e("SystemStatus", e.getMessage()); }
+                            }
+                        }
+
+                        ActiveBluetoothDevice.forget();
+                        bluetoothAdapter.disable();
+                        bluetoothAdapter.enable();
+                        try {
+                            wait(1000);
+                        } catch(Exception e) {
+                            Log.e("SystemStatus", "Error stalling");
+                        }
+                    }
+                }
+                CollectionServiceStarter.restartCollectionService(getApplicationContext());
+                set_current_values();
+            }
+        });
+    }
+
+    public void refreshButtonListener() {
+        refresh.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                set_current_values();
+            }
+        });
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
index f34a88d..1fa617c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
@@ -31,8 +31,9 @@
  * Created by stephenblack on 11/15/14.
  */
 public class BgGraphBuilder {
-    public double  end_time = new Date().getTime() + (60000 * 10);
-    public double  start_time = end_time - (60000 * 60 * 24);
+    public int fuzzer = (1000 * 60 * 5);
+    public double  end_time = (new Date().getTime() + (60000 * 10)) / fuzzer;
+    public double  start_time = end_time - ((60000 * 60 * 24)) / fuzzer;
     public Context context;
     public SharedPreferences prefs;
     public double highMark;
@@ -47,10 +48,11 @@
 
     private double endHour;
     private final int numValues =(60/5)*24;
-    private final List<BgReading> bgReadings = BgReading.latestForGraph( numValues, start_time);
+    private final List<BgReading> bgReadings = BgReading.latestForGraph( numValues, (start_time * fuzzer));
     private List<PointValue> inRangeValues = new ArrayList<PointValue>();
     private List<PointValue> highValues = new ArrayList<PointValue>();
     private List<PointValue> lowValues = new ArrayList<PointValue>();
+    private List<PointValue> rawInterpretedValues = new ArrayList<PointValue>();
     public Viewport viewport;
 
 
@@ -95,6 +97,7 @@ public LineChartData previewLineData() {
         lines.add(inRangeValuesLine());
         lines.add(lowValuesLine());
         lines.add(highValuesLine());
+        lines.add(rawInterpretedLine());
         return lines;
     }
 
@@ -125,18 +128,28 @@ public Line inRangeValuesLine() {
         return inRangeValuesLine;
     }
 
+    public Line rawInterpretedLine() {
+        Line line = new Line(rawInterpretedValues);
+        line.setHasLines(false);
+        line.setPointRadius(1);
+        line.setHasPoints(true);
+        return line;
+    }
+
     private void addBgReadingValues() {
         for (BgReading bgReading : bgReadings) {
-            if (bgReading.calculated_value >= 400) {
-                highValues.add(new PointValue((float) bgReading.timestamp, (float) unitized(400)));
+            if (bgReading.raw_calculated != 0 && prefs.getBoolean("interpret_raw", false)) {
+                rawInterpretedValues.add(new PointValue((float) (bgReading.timestamp/fuzzer), (float) unitized(bgReading.raw_calculated)));
+            } else if (bgReading.calculated_value >= 400) {
+                highValues.add(new PointValue((float) (bgReading.timestamp/fuzzer), (float) unitized(400)));
             } else if (unitized(bgReading.calculated_value) >= highMark) {
-                highValues.add(new PointValue((float) bgReading.timestamp, (float) unitized(bgReading.calculated_value)));
+                highValues.add(new PointValue((float) (bgReading.timestamp/fuzzer), (float) unitized(bgReading.calculated_value)));
             } else if (unitized(bgReading.calculated_value) >= lowMark) {
-                inRangeValues.add(new PointValue((float) bgReading.timestamp, (float) unitized(bgReading.calculated_value)));
+                inRangeValues.add(new PointValue((float) (bgReading.timestamp/fuzzer), (float) unitized(bgReading.calculated_value)));
             } else if (bgReading.calculated_value >= 40) {
-                lowValues.add(new PointValue((float)bgReading.timestamp, (float) unitized(bgReading.calculated_value)));
-            } else {
-                lowValues.add(new PointValue((float)bgReading.timestamp, (float) unitized(40)));
+                lowValues.add(new PointValue((float)(bgReading.timestamp/fuzzer), (float) unitized(bgReading.calculated_value)));
+            } else if (bgReading.calculated_value > 13) {
+                lowValues.add(new PointValue((float)(bgReading.timestamp/fuzzer), (float) unitized(40)));
             }
         }
     }
@@ -214,19 +227,19 @@ public Axis xAxis() {
         GregorianCalendar today = new GregorianCalendar(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH));
         final java.text.DateFormat timeFormat = hourFormat();
         timeFormat.setTimeZone(TimeZone.getDefault());
-        double start_hour = today.getTime().getTime();
+        double start_hour_block = today.getTime().getTime();
         double timeNow = new Date().getTime();
         for(int l=0; l<=24; l++) {
-            if ((start_hour + (60000 * 60 * (l))) <  timeNow) {
-                if((start_hour + (60000 * 60 * (l + 1))) >=  timeNow) {
-                    endHour = start_hour + (60000 * 60 * (l));
+            if ((start_hour_block + (60000 * 60 * (l))) <  timeNow) {
+                if((start_hour_block + (60000 * 60 * (l + 1))) >=  timeNow) {
+                    endHour = start_hour_block + (60000 * 60 * (l));
                     l=25;
                 }
             }
         }
         for(int l=0; l<=24; l++) {
-            double timestamp = endHour - (60000 * 60 * l);
-            xAxisValues.add(new AxisValue((long)(timestamp), (timeFormat.format(timestamp)).toCharArray()));
+            double timestamp = (endHour - (60000 * 60 * l));
+            xAxisValues.add(new AxisValue((long)(timestamp/fuzzer), (timeFormat.format(timestamp)).toCharArray()));
         }
         xAxis.setValues(xAxisValues);
         xAxis.setHasLines(true);
@@ -247,8 +260,8 @@ public Axis previewXAxis(){
         final java.text.DateFormat timeFormat = hourFormat();
         timeFormat.setTimeZone(TimeZone.getDefault());
         for(int l=0; l<=24; l+=hoursPreviewStep) {
-            double timestamp = endHour - (60000 * 60 * l);
-            previewXaxisValues.add(new AxisValue((long)(timestamp), (timeFormat.format(timestamp)).toCharArray()));
+            double timestamp = (endHour - (60000 * 60 * l));
+            previewXaxisValues.add(new AxisValue((long)(timestamp/fuzzer), (timeFormat.format(timestamp)).toCharArray()));
         }
         Axis previewXaxis = new Axis();
         previewXaxis.setValues(previewXaxisValues);
@@ -260,8 +273,8 @@ public Axis previewXAxis(){
     /////////VIEWPORT RELATED//////////////
     public Viewport advanceViewport(Chart chart, Chart previewChart) {
         viewport = new Viewport(previewChart.getMaximumViewport());
-        viewport.inset((float)(86400000 / 2.5), 0);
-        double distance_to_move = (new Date().getTime()) - viewport.left - (((viewport.right - viewport.left) /2));
+        viewport.inset((float)((86400000 / 2.5)/fuzzer), 0);
+        double distance_to_move = ((new Date().getTime())/fuzzer) - viewport.left - (((viewport.right - viewport.left) /2));
         viewport.offset((float) distance_to_move, 0);
         return viewport;
     }
@@ -290,8 +303,10 @@ public String unitized_string(double value) {
                 df.setMinimumFractionDigits(1);
                 return df.format(mmolConvert(value));
             }
-        } else {
+        } else if (value > 13) {
             return "LOW";
+        } else {
+            return "???";
         }
     }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
index 32d080c..e2b9dbf 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
@@ -2,7 +2,9 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.SharedPreferences;
+import android.os.BatteryManager;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
 import android.provider.BaseColumns;
@@ -13,6 +15,7 @@
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
 import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.ShareModels.ShareRest;
 
 import java.util.List;
 
@@ -68,6 +71,7 @@ public static void addToQueue(BgReading bgReading, String operation_type, Contex
         bgSendQueue.success = false;
         bgSendQueue.mongo_success = false;
         bgSendQueue.save();
+        Log.d("BGQueue", "New value added to queue!");
 
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
 
@@ -87,8 +91,12 @@ public static void addToQueue(BgReading bgReading, String operation_type, Contex
             final Bundle bundle = new Bundle();
             bundle.putDouble(Intents.EXTRA_BG_ESTIMATE, bgReading.calculated_value);
             bundle.putDouble(Intents.EXTRA_BG_SLOPE, bgReading.calculated_value_slope);
-            bundle.putString(Intents.EXTRA_BG_SLOPE_NAME, bgReading.slopeName());
-            bundle.putInt(Intents.EXTRA_SENSOR_BATTERY, bgReading.sensor.latest_battery_level);
+            if(bgReading.hide_slope) {
+                bundle.putString(Intents.EXTRA_BG_SLOPE_NAME, "9");
+            } else {
+                bundle.putString(Intents.EXTRA_BG_SLOPE_NAME, bgReading.slopeName());
+            }
+            bundle.putInt(Intents.EXTRA_SENSOR_BATTERY, getBatteryLevel(context));
             bundle.putLong(Intents.EXTRA_TIMESTAMP, bgReading.timestamp);
 
             Intent intent = new Intent(Intents.ACTION_NEW_BG_ESTIMATE);
@@ -100,10 +108,26 @@ public static void addToQueue(BgReading bgReading, String operation_type, Contex
             PebbleSync pebbleSync = new PebbleSync();
             pebbleSync.sendData(context, bgReading);
         }
+
+        if(prefs.getBoolean("share_upload", false)) {
+            ShareRest shareRest = new ShareRest(context);
+            Log.w("ShareRest", "About to call ShareRest!!");
+            shareRest.sendBgData(bgReading);
+        }
     }
 
     public void markMongoSuccess() {
         mongo_success = true;
         save();
     }
+
+    public static int getBatteryLevel(Context context) {
+        Intent batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+        int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
+        int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
+        if(level == -1 || scale == -1) {
+            return 50;
+        }
+        return (int)(((float)level / (float)scale) * 100.0f);
+    }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
index acd9a7b..5f1746e 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/CollectionServiceStarter.java
@@ -7,6 +7,7 @@
 import android.util.Log;
 
 import com.eveningoutpost.dexdrip.Services.DexCollectionService;
+import com.eveningoutpost.dexdrip.Services.DexShareCollectionService;
 import com.eveningoutpost.dexdrip.Services.WixelReader;
 
 /**
@@ -23,7 +24,27 @@ public static boolean isBTWixel(Context context) {
         }
         return false;
     }
-    
+    public static boolean isBTShare(Context context) {
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String collection_method = prefs.getString("dex_collection_method", "BluetoothWixel");
+        if(collection_method.compareTo("DexcomShare") == 0) {
+            return true;
+        }
+        return false;
+    }
+    public static boolean isWifiWixel(Context context) {
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String collection_method = prefs.getString("dex_collection_method", "BluetoothWixel");
+        if(collection_method.compareTo("WifiWixel") == 0) {
+            return true;
+        }
+        return false;
+    }
+    public static void newStart(Context context) {
+        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(context);
+        collectionServiceStarter.start(context);
+    }
+
     public void start(Context context) {
         mContext = context;
 
@@ -31,27 +52,56 @@ public void start(Context context) {
         String collection_method = prefs.getString("dex_collection_method", "BluetoothWixel");
 
         if(isBTWixel(context)) {
+            Log.d("DexDrip", "Starting bt wixel collector");
             stopWifWixelThread();
             startBtWixelService();
-        } else {
+            stopBtShareService();
+        } else if(isWifiWixel(context)){
+            Log.d("DexDrip", "Starting wifi wixel collector");
             stopBtWixelService();
             startWifWixelThread();
+            stopBtShareService();
+        } else if(isBTShare(context)) {
+            Log.d("DexDrip", "Starting bt share collector");
+            stopBtWixelService();
+            stopWifWixelThread();
+            startBtShareService();
         }
+        Log.d("ColServiceStarter", collection_method);
+    }
 
-        Log.d("CollectionServiceStarter ", collection_method);
+    public CollectionServiceStarter(Context context) {
+        mContext = context;
     }
 
+    public static void restartCollectionService(Context context) {
+        CollectionServiceStarter collectionServiceStarter = new CollectionServiceStarter(context);
+        collectionServiceStarter.stopBtShareService();
+        collectionServiceStarter.stopBtWixelService();
+        collectionServiceStarter.stopWifWixelThread();
+        collectionServiceStarter.start(context);
+    }
 
     private void startBtWixelService() {
+        Log.d("ColServiceStarter", "starting bt wixel service");
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
             mContext.startService(new Intent(mContext, DexCollectionService.class));
     	}
     }
     private void stopBtWixelService() {
+        Log.d("ColServiceStarter", "stopping bt wixel service");
+        mContext.stopService(new Intent(mContext, DexCollectionService.class));
+    }
+    private void startBtShareService() {
+        Log.d("ColServiceStarter", "starting bt share service");
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            mContext.stopService(new Intent(mContext, DexCollectionService.class));
+            mContext.startService(new Intent(mContext, DexShareCollectionService.class));
         }
     }
+    private void stopBtShareService() {
+        Log.d("ColServiceStarter", "stopping bt share service");
+        mContext.stopService(new Intent(mContext, DexShareCollectionService.class));
+    }
 
     private void startWifWixelThread() {
         WixelReader.sStart(mContext);
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/DexShareAttributes.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/DexShareAttributes.java
new file mode 100644
index 0000000..544077b
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/DexShareAttributes.java
@@ -0,0 +1,34 @@
+package com.eveningoutpost.dexdrip.UtilityModels;
+
+import java.math.BigInteger;
+import java.util.UUID;
+
+/**
+ * Created by stephenblack on 2/4/15.
+ */
+public class DexShareAttributes {
+    //Share Service String
+    public static final UUID CradleService= UUID.fromString("F0ABA0B1-EBFA-F96F-28DA-076C35A521DB");
+
+    //Share Characteristic Strings
+    public static final UUID AuthenticationCode = UUID.fromString("F0ABACAC-EBFA-F96F-28DA-076C35A521DB");
+    public static final UUID ShareMessageReceiver= UUID.fromString("F0ABB20A-EBFA-F96F-28DA-076C35A521DB"); // Max 20 Bytes - Writable
+    public static final UUID ShareMessageResponse= UUID.fromString("F0ABB20B-EBFA-F96F-28DA-076C35A521DB"); // Max 20 Bytes
+    public static final UUID Command= UUID.fromString("F0ABB0CC-EBFA-F96F-28DA-076C35A521DB");
+    public static final UUID Response= UUID.fromString("F0ABB0CD-EBFA-F96F-28DA-076C35A521DB"); // Writable?
+    public static final UUID HeartBeat= UUID.fromString("F0AB2B18-EBFA-F96F-28DA-076C35A521DB");
+
+    //Possible new uuids????  60bfxxxx-60b0-4d4f-0000-000160c48d70
+    public static final UUID CradleService2= UUID.fromString("F0ACA0B1-EBFA-F96F-28DA-076C35A521DB");
+    public static final UUID AuthenticationCode2 = UUID.fromString("F0ACACAC-EBFA-F96F-28DA-076C35A521DB"); // read, write
+    public static final UUID ShareMessageReceiver2= UUID.fromString("F0ACB20A-EBFA-F96F-28DA-076C35A521DB"); // read, write
+    public static final UUID ShareMessageResponse2= UUID.fromString("F0ACB20B-EBFA-F96F-28DA-076C35A521DB"); // indicate, read
+    public static final UUID Command2= UUID.fromString("F0ACB0CC-EBFA-F96F-28DA-076C35A521DB"); // read, write
+    public static final UUID Response2= UUID.fromString("F0ACB0CD-EBFA-F96F-28DA-076C35A521DB"); // indicate, read, write
+    public static final UUID HeartBeat2= UUID.fromString("F0AC2B18-EBFA-F96F-28DA-076C35A521DB"); // notify, read
+
+    //Device Info
+    public static final UUID DeviceService= UUID.fromString("00001804-0000-1000-8000-00805f9b34fb");
+    public static final UUID PowerLevel= UUID.fromString("00002a07-0000-1000-8000-00805f9b34fb");
+
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HM10Attributes.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HM10Attributes.java
index c413d9a..22af375 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HM10Attributes.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HM10Attributes.java
@@ -7,4 +7,4 @@
     public static String CLIENT_CHARACTERISTIC_CONFIG = "00002902-0000-1000-8000-00805f9b34fb";
     public static String HM_10_SERVICE = "0000ffe0-0000-1000-8000-00805f9b34fb";
     public static String HM_RX_TX = "0000ffe1-0000-1000-8000-00805f9b34fb";
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
index f471600..6461cc8 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
@@ -84,11 +84,19 @@ public static void notificationSetter(Context context) {
 
         List<BgReading> bgReadings = BgReading.latest(3);
         List<Calibration> calibrations = Calibration.allForSensorInLastFourDays();
+        if(bgReadings.size() < 3) { return; }
+        if(calibrations.size() < 2) { return; }
         BgReading bgReading = bgReadings.get(0);
 
         if (bg_notifications && sensor != null) {
             if (bgGraphBuilder.unitized(bgReading.calculated_value) >= high || bgGraphBuilder.unitized(bgReading.calculated_value) <= low) {
-                bgAlert(bgReading.displayValue(mContext), bgReading.slopeArrow());
+                if(bgReading.calculated_value > 14) {
+                    if (bgReading.hide_slope) {
+                        bgAlert(bgReading.displayValue(mContext), "");
+                    } else {
+                        bgAlert(bgReading.displayValue(mContext), bgReading.slopeArrow());
+                    }
+                }
             } else {
                 clearBgAlert();
             }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
index b663ae6..e829e7f 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/PebbleSync.java
@@ -41,8 +41,8 @@ public PebbleDictionary buildDictionary() {
         PebbleDictionary dictionary = new PebbleDictionary();
         dictionary.addString(ICON_KEY, slopeOrdinal());
         dictionary.addString(BG_KEY, bgReading());
-        dictionary.addUint32(RECORD_TIME_KEY, (int) mBgReading.timestamp);
-        dictionary.addUint32(PHONE_TIME_KEY, (int) new Date().getTime());
+        dictionary.addUint32(RECORD_TIME_KEY, (int) (mBgReading.timestamp / 1000));
+        dictionary.addUint32(PHONE_TIME_KEY, (int) (new Date().getTime() / 1000));
         dictionary.addString(BG_DELTA_KEY, bgDelta());
         dictionary.addString(UPLOADER_BATTERY_KEY, phoneBattery());
         dictionary.addString(NAME_KEY, "xDrip");
@@ -61,9 +61,11 @@ public String bgReading() {
     }
 
     public String bgDelta() {
-        String deltaString = bgGraphBuilder.unitized_string((mBgReading.calculated_value_slope * (5 * 60 * 1000)));
-        if(mBgReading.calculated_value_slope > 0) {
+        String deltaString = bgGraphBuilder.unitized_string((int)(mBgReading.calculated_value_slope * (5 * 60 * 1000)));
+        if(mBgReading.calculated_value_slope > 0.1) {
             return ("+"+deltaString);
+        } else if(mBgReading.calculated_value_slope > -0.1 && mBgReading.calculated_value_slope < 0.1) {
+            return "0";
         } else {
             return deltaString;
         }
@@ -114,6 +116,9 @@ public String slopeOrdinal(){
         } else {
             arrow = "1";
         }
+        if(mBgReading.hide_slope) {
+            arrow = "9";
+        }
         return arrow;
     }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/RedBearLabAttributes.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/RedBearLabAttributes.java
new file mode 100644
index 0000000..ec1702f
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/RedBearLabAttributes.java
@@ -0,0 +1,12 @@
+package com.eveningoutpost.dexdrip.UtilityModels;
+
+import java.util.UUID;
+
+/**
+ * Created by stephenblack on 2/21/15.
+ */
+public class RedBearLabAttributes {
+    public static UUID CLIENT_CHARACTERISTIC_CONFIG = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");
+    public static UUID REDBEARLAB_SERVICE =  UUID.fromString("0000ffe0-0000-1000-8000-00805f9b34fb");
+    public static UUID REDBEARLAB_TX =  UUID.fromString("713d0002-503e-4c75-ba94-3148f18d941e");
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/xdrip.java b/app/src/main/java/com/eveningoutpost/dexdrip/xdrip.java
new file mode 100644
index 0000000..5d0a46e
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/xdrip.java
@@ -0,0 +1,43 @@
+package com.eveningoutpost.dexdrip;
+
+import android.app.Application;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.ReportingInteractionMode;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.sender.HttpSender;
+
+/**
+ * Created by stephenblack on 3/21/15.
+ */
+@ReportsCrashes(
+        formUri = "https://yoursolace.cloudant.com/acra-xdrip/_design/acra-storage/_update/report",
+        reportType = HttpSender.Type.JSON,
+        httpMethod = HttpSender.Method.POST,
+        formUriBasicAuthLogin = "nateriverldstiondrephery",
+        formUriBasicAuthPassword = "GEK5Nv7NtMkloAkufNvFgast",
+        formKey = "", // This is required for backward compatibility but not used
+        customReportContent = {
+                ReportField.APP_VERSION_CODE,
+                ReportField.APP_VERSION_NAME,
+                ReportField.ANDROID_VERSION,
+                ReportField.PACKAGE_NAME,
+                ReportField.REPORT_ID,
+                ReportField.BUILD,
+                ReportField.STACK_TRACE
+        },
+        mode = ReportingInteractionMode.TOAST,
+        logcatArguments = {"-t", "500", "-v", "time"},
+        resToastText = R.string.toast_crash
+)
+
+public class xdrip extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // The following line triggers the initialization of ACRA
+        ACRA.init(this);
+    }
+}
diff --git a/app/src/main/res/layout/activity_share_test.xml b/app/src/main/res/layout/activity_share_test.xml
new file mode 100644
index 0000000..6e0c5c8
--- /dev/null
+++ b/app/src/main/res/layout/activity_share_test.xml
@@ -0,0 +1,59 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
+    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    tools:context="com.eveningoutpost.dexdrip.ShareTest">
+
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:weightSum="1">
+
+        <Button
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Connect"
+            android:id="@+id/connect"
+            android:layout_gravity="center_horizontal" />
+
+        <LinearLayout
+            android:orientation="horizontal"
+            android:layout_width="fill_parent"
+            android:layout_height="55dp"
+            android:gravity="center_horizontal">
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Close"
+                android:id="@+id/closeConnect"
+                android:layout_gravity="center_horizontal" />
+
+            <Button
+                style="?android:attr/buttonStyleSmall"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Read"
+                android:id="@+id/read"
+                android:layout_gravity="right" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="bond"
+                android:id="@+id/bond" />
+
+        </LinearLayout>
+
+        <TextView
+            android:layout_width="334dp"
+            android:layout_height="wrap_content"
+            android:id="@+id/connection_details"
+            android:layout_weight="1.02"
+            android:nestedScrollingEnabled="true" />
+    </LinearLayout>
+
+</RelativeLayout>
diff --git a/app/src/main/res/layout/activity_stop_sensor.xml b/app/src/main/res/layout/activity_stop_sensor.xml
index 2bd092b..83975e1 100644
--- a/app/src/main/res/layout/activity_stop_sensor.xml
+++ b/app/src/main/res/layout/activity_stop_sensor.xml
@@ -7,52 +7,41 @@
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical" android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:weightSum="1">
-
-    <RelativeLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:layout_gravity="center_horizontal">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textAppearance="?android:attr/textAppearanceLarge"
-            android:text="Current Sensor Information"
-            android:id="@+id/textView3" />
-
-        <LinearLayout
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:id="@+id/sensor_age_container"
-            android:layout_gravity="center"
-            android:orientation="vertical">
-
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:textAppearance="?android:attr/textAppearanceMedium"
-                android:text="Sensor Age: "
-                android:layout_below="@+id/textView"
-                android:layout_alignParentStart="true"
-                android:layout_marginTop="111dp" />
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="47dp"
-                android:id="@+id/sensor_age" />
-        </LinearLayout>
-
-        <Button
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="STOP SENSOR"
-            android:id="@+id/stop_sensor"
-            android:layout_toEndOf="@+id/sensor_age_container"
-            android:layout_alignParentBottom="true"
-            android:layout_alignEnd="@+id/textView3" />
-
-    </RelativeLayout>
+    android:weightSum="1"
+    android:id="@+id/stop_sensor_container">
+
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAppearance="?android:attr/textAppearanceLarge"
+        android:text="Stop Sensor"
+        android:id="@+id/textView3"
+        android:layout_gravity="center_horizontal" />
+
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAppearance="?android:attr/textAppearanceMedium"
+        android:text="Only stop your sensor when you actually plan to remove it, otherwise leave it running!"
+        android:layout_below="@+id/textView"
+        android:layout_alignParentStart="true"
+        android:layout_marginTop="40dp"
+        android:id="@+id/stop_sensor_instructions"
+        android:layout_gravity="right"
+        android:paddingLeft="20dp"
+        android:paddingRight="20dp"
+        android:gravity="center_vertical|center_horizontal" />
+
+    <Button
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="STOP SENSOR"
+        android:id="@+id/stop_sensor"
+        android:layout_toEndOf="@+id/sensor_age_container"
+        android:layout_alignParentBottom="true"
+        android:layout_alignEnd="@+id/textView3"
+        android:layout_gravity="center_horizontal"
+        android:layout_marginTop="30dp" />
 
 
 </LinearLayout>
diff --git a/app/src/main/res/layout/activity_system_status.xml b/app/src/main/res/layout/activity_system_status.xml
new file mode 100644
index 0000000..5d085e1
--- /dev/null
+++ b/app/src/main/res/layout/activity_system_status.xml
@@ -0,0 +1,162 @@
+<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools" android:id="@+id/drawer_layout"
+    android:layout_width="match_parent" android:layout_height="match_parent"
+    tools:context="com.eveningoutpost.dexdrip.SystemStatus">
+
+    <!-- As the main content view, the view below consumes the entire
+         space available using match_parent in both dimensions. -->
+    <FrameLayout android:id="@+id/container" android:layout_width="match_parent"
+        android:layout_height="match_parent" >
+
+    </FrameLayout>
+    <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
+        android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
+        android:paddingRight="@dimen/activity_horizontal_margin"
+        android:paddingTop="@dimen/activity_vertical_margin"
+        android:paddingBottom="@dimen/activity_vertical_margin"
+        tools:context="com.eveningoutpost.dexdrip.SystemStatus"
+        android:id="@+id/status_layout">
+
+        <LinearLayout
+            android:orientation="vertical"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:layout_alignParentTop="true"
+            android:layout_alignParentStart="true">
+
+            <LinearLayout
+                android:orientation="horizontal"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:id="@+id/layout_horiz"
+                android:paddingTop="10dp">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:text="Collection Method:   "
+                    android:id="@+id/textView6" />
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:id="@+id/collection_method" />
+            </LinearLayout>
+
+            <LinearLayout
+                android:orientation="horizontal"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:paddingTop="10dp">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:text="Remembered Device:   "
+                    android:id="@+id/textView7" />
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:id="@+id/remembered_device" />
+            </LinearLayout>
+
+            <LinearLayout
+                android:orientation="horizontal"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:paddingTop="10dp">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:text="Connection Status:   "
+                    android:id="@+id/textView8" />
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceMedium"
+                    android:id="@+id/connection_status" />
+            </LinearLayout>
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textAppearance="?android:attr/textAppearanceLarge"
+                android:text="Other Notes:"
+                android:id="@+id/textView9"
+                android:layout_gravity="center_horizontal"
+                android:paddingTop="10dp" />
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textAppearance="?android:attr/textAppearanceMedium"
+                android:id="@+id/other_notes"
+                android:layout_gravity="center_horizontal" />
+
+            <LinearLayout
+                android:orientation="vertical"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="bottom"
+                android:gravity="center|bottom"
+                android:baselineAligned="false"
+                android:paddingTop="10dp">
+
+                <LinearLayout
+                    android:orientation="horizontal"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_horizontal|bottom"
+                    android:gravity="center_horizontal|bottom">
+
+                    <Button
+                        style="?android:attr/buttonStyleSmall"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:text="Restart Collector"
+                        android:id="@+id/restart_collection_service" />
+
+                    <Button
+                        style="?android:attr/buttonStyleSmall"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:text="Forget Device"
+                        android:id="@+id/forget_device" />
+                </LinearLayout>
+
+                <LinearLayout
+                    android:orientation="horizontal"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:gravity="center_horizontal"
+                    android:layout_gravity="center_horizontal">
+
+                    <ImageButton
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:id="@+id/refresh_current_values"
+                        android:src="@android:drawable/stat_notify_sync" />
+                </LinearLayout>
+            </LinearLayout>
+
+        </LinearLayout>
+    </RelativeLayout>
+
+    <fragment android:id="@+id/navigation_drawer"
+        android:layout_width="@dimen/navigation_drawer_width" android:layout_height="match_parent"
+        android:layout_gravity="start"
+        android:name="com.eveningoutpost.dexdrip.NavigationDrawerFragment"
+        tools:layout="@layout/fragment_navigation_drawer" />
+
+</android.support.v4.widget.DrawerLayout>
diff --git a/app/src/main/res/menu/menu_share_test.xml b/app/src/main/res/menu/menu_share_test.xml
new file mode 100644
index 0000000..64b8eb8
--- /dev/null
+++ b/app/src/main/res/menu/menu_share_test.xml
@@ -0,0 +1,6 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.eveningoutpost.dexdrip.ShareTest">
+    <item android:id="@+id/action_settings" android:title="@string/action_settings"
+        android:orderInCategory="100" android:showAsAction="never" />
+</menu>
diff --git a/app/src/main/res/menu/menu_system_status.xml b/app/src/main/res/menu/menu_system_status.xml
new file mode 100644
index 0000000..7dbf8d9
--- /dev/null
+++ b/app/src/main/res/menu/menu_system_status.xml
@@ -0,0 +1,6 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.eveningoutpost.dexdrip.SystemStatus">
+    <item android:id="@+id/action_settings" android:title="@string/action_settings"
+        android:orderInCategory="100" android:showAsAction="never" />
+</menu>
diff --git a/app/src/main/res/values/arrays.xml b/app/src/main/res/values/arrays.xml
index 623969a..46a65b7 100644
--- a/app/src/main/res/values/arrays.xml
+++ b/app/src/main/res/values/arrays.xml
@@ -3,11 +3,13 @@
     <string-array name="DexCollectionMethods">
         <item>Bluetooth Wixel</item>
         <item>Wifi Wixel</item>
+        <item>DexcomShare</item>
     </string-array>
 
     <string-array name="DexCollectionMethodValues">
         <item>BluetoothWixel</item>
         <item>WifiWixel</item>
+        <item>DexcomShare</item>
     </string-array>
 
 
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
index 2ee0933..6cd923a 100644
--- a/app/src/main/res/values/strings.xml
+++ b/app/src/main/res/values/strings.xml
@@ -87,4 +87,9 @@
     <!-- broadcast settings -->
     <string name="pref_title_broadcast_enabled">Broadcast locally</string>
     <string name="pref_summary_broadcast_enabled">Enable local broadcast of data so other apps (eg. NightWatch) can listen on new values</string>
+    <string name="title_activity_share_test">ShareTest</string>
+    <string name="title_activity_system_status">SystemStatus</string>
+
+    <string name="toast_crash">Something went wrong :( a report has been sent to help fix the issue.</string>
+
 </resources>
diff --git a/app/src/main/res/xml/pref_data_source.xml b/app/src/main/res/xml/pref_data_source.xml
index 96eb9e1..a7ef1ae 100644
--- a/app/src/main/res/xml/pref_data_source.xml
+++ b/app/src/main/res/xml/pref_data_source.xml
@@ -5,7 +5,6 @@
         android:dependency="I_understand"
         android:title="Data Source"
         android:key="dataSource">
-
         <ListPreference
             android:key="dex_collection_method"
             android:title="Dexcom Data Collection Method"
diff --git a/app/src/main/res/xml/pref_data_sync.xml b/app/src/main/res/xml/pref_data_sync.xml
index 62d038b..501b4c1 100644
--- a/app/src/main/res/xml/pref_data_sync.xml
+++ b/app/src/main/res/xml/pref_data_sync.xml
@@ -13,7 +13,7 @@
             android:title="@string/pref_title_mongodb"
             android:summary="@string/pref_summary_mongodb_enabled">
 
-            <CheckBoxPreference
+            <SwitchPreference
                 android:key="cloud_storage_mongodb_enable"
                 android:title="Enable Nightscout Mongo DB sync"
                 android:defaultValue="false" />
diff --git a/app/src/main/res/xml/pref_general.xml b/app/src/main/res/xml/pref_general.xml
index 57886f3..86a2481 100644
--- a/app/src/main/res/xml/pref_general.xml
+++ b/app/src/main/res/xml/pref_general.xml
@@ -21,10 +21,15 @@
             android:numeric="decimal"
             android:summary="The minimum value you consider to be in range."
             android:defaultValue="70" />
-        <CheckBoxPreference
+        <SwitchPreference
             android:key="predictive_bg"
             android:title="Display Predictive Values"
-            android:summary="xDrip will attempt to predict readings each minute based on the past few values, this is not always accurate."
+            android:summary="Not Recommended. xDrip will attempt to predict readings each minute based on the past few values."
+            android:defaultValue="false" />
+        <SwitchPreference
+            android:key="interpret_raw"
+            android:title="Interpret Raw Values"
+            android:summary="If using Share, DexDrip will show values when they are normally hidden on the reciever."
             android:defaultValue="false" />
     </PreferenceCategory>
 </PreferenceScreen>
diff --git a/app/src/main/res/xml/pref_share.xml b/app/src/main/res/xml/pref_share.xml
new file mode 100644
index 0000000..e6f13f8
--- /dev/null
+++ b/app/src/main/res/xml/pref_share.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <PreferenceCategory
+        android:title="Dexcom Share"
+        android:key="dexcomDataSource">
+        <EditTextPreference
+            android:title="10 Character Dexcom Receiver Serial Number"
+            android:key="share_key"
+            android:defaultValue="SM00000000">
+        </EditTextPreference>
+        <!--<CheckBoxPreference-->
+            <!--android:key="share_upload"-->
+            <!--android:title="Upload BG values as Dexcom Share"-->
+            <!--android:summary="If you are using Dexcom Share, choose this option."-->
+            <!--android:defaultValue="false" />-->
+        <!--<EditTextPreference-->
+            <!--android:dependency="share_upload"-->
+            <!--android:key="dexcom_account_name"-->
+            <!--android:title="Dexcom Account Login"-->
+            <!--android:summary="Your login for Dexcoms Website"-->
+            <!--android:defaultValue=""/>-->
+        <!--<EditTextPreference-->
+            <!--android:dependency="share_upload"-->
+            <!--android:key="dexcom_account_password"-->
+            <!--android:title="Dexcom Account Password"-->
+            <!--android:inputType="textPassword"-->
+            <!--android:summary="Your password for Dexcoms Website"-->
+            <!--android:defaultValue=""/>-->
+    </PreferenceCategory>
+
+</PreferenceScreen>
diff --git a/battle_of_the_dexes.md b/battle_of_the_dexes.md
new file mode 100644
index 0000000..6562051
--- /dev/null
+++ b/battle_of_the_dexes.md
@@ -0,0 +1,43 @@
+
+A few weeks ago I started a new sensor and kicked off the BattleOfTheDexes
+I compared my xDrip Alogrithm against the Dexcom 505 Algorithm.
+_(obviously its just one sample so nothing conclusive, but the results are in)_
+
+&nbsp;
+
+
+METER | Dexcom | xDrip
+-----:|-----:|-----:
+105 | 87 | **100**
+181 | **188** | 169
+166 | 236 | **185**
+75 | 53 | **66**
+103 | 101 | **103**
+118 | 102 | **111**
+120 | 154 | **144**
+151  | 125 | 137
+102 | 95 | **103**
+89 | **90** | 98
+97 | **106** | 111
+
+&nbsp;
+
+Overall MARDs:
+* Dexcom: 15.5%
+* xDrip: **8.7%**
+
+&nbsp;
+
+Note that Dexcoms actual MARD as calculated in studies is 9% I believe so its quite possible I had a bum sensor here. Also note that xDrip got one extra calibration value on the second day (because it asks for one if it thinks things are off at a time when it thinks the calibration will be the most helpful)
+
+&nbsp;
+
+I stopped this first comparison here because once I restart the sensor on my Dexcom, xDrip winds up with a huge advantage as it already knows the slope from the last few days of calibrations wheras dexcom will be starting from scratch. I will do more comparisons each time I change sensors!
+
+&nbsp;
+
+Want to know more about the project? Check it out [HERE](http://stephenblackwasalreadytaken.github.io/xDrip)
+
+&nbsp;
+
+All of the code is available and open source, if you want help getting it running just ask, Its constantly getting updated so either watch the repo in github or follow me on twitter @StephenIsTaken
diff --git a/build.gradle b/build.gradle
index b2a5c11..04e3b67 100644
--- a/build.gradle
+++ b/build.gradle
@@ -6,7 +6,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:1.1.3'
         apply plugin: 'java'
         apply plugin: 'maven'
 //        compile 'com.mcxiaoke.volley:library:1.0.+'
diff --git a/hardware_setup.md b/hardware_setup.md
new file mode 100644
index 0000000..01c076d
--- /dev/null
+++ b/hardware_setup.md
@@ -0,0 +1,71 @@
+## What you need to get started
+Note, the following describes what I am currently using and recommend, it could definitely change and you can definitely use other components. Just know that this is all that it has been tested with!
+
+* An Android Device
+ * Must be running 4.3 to support BLE
+ * Also must have BLE support
+* [A Wixel](http://www.pololu.com/product/1337)
+ * I recommend the one without headers(linked) if you want to use wires, if you plan to use a breadboard or make a custom PCB feel free to get the one with headers.
+* An HM-10 BLE Module
+ * I removed the link as it seems they replaced the HM10 with a cc41, **DO NOT GET A CC41!!!!!** I use the hm10 formerly sold by sunfounder, if you can find one with the pins at the bottom that is the easiest!
+ * The HM11 has been confirmed working but soldering it is VERY TOUGH
+* [Battery Power](http://www.adafruit.com/products/258)
+ * I use the one linked and have no problem getting through a day, I have not done extensive battery testing at this point
+ * *EDIT: that one was lasting over 6 days, which seemed like a waste of space, now I use [this 500mAh](http://www.adafruit.com/products/1578) Which gets me two days no problem!
+* [Battery Charger](http://www.adafruit.com/products/1904)
+ * I use this one, its nice and smallish and does the trick.
+ * If you find a nicer smaller one PLEASE LET ME KNOW (I wound up breaking the top bit off of this so I could make it fit in a new enclosure)
+* [Wires](http://www.adafruit.com/product/2051)
+ * I use these 30AWG silicon wires because they are super small and flexible
+ * Larger wires will make it harder to keep things nice and compact, keep with a small guage!
+* Solder and Soldering Iron
+ * Or a breadboard if you dont mind the bulk
+ * Or a custom made PCB (and one for me too please?)
+ * I used a cheap 15w soldering iron in order to solder and remove the pins from the HM10 (you can probably go a bit higher but I wouldnt go crazy)
+ * I used a regular not terrifying soldering iron for the rest of it!
+* [Resistors](http://www.radioshack.com)
+ * If you wish to measure the Wixel's battery voltage, you'll need to build a voltage divider using two resistors and a piece of wire
+ * You'll need a 1/4w 1K Ohm and a 1/4w 2.2K Ohm resistor.  1/8w should work, and be smaller, but it hasn't been tested
+ * Optional:  Small heatshrink tubing to protect the resistors (https://www.adafruit.com/product/344)
+
+ ## Putting it together!
+ ![SETUP](http://i.imgur.com/EIGki5R.png)
+ 
+ ## For the voltage measurement modification
+ ###### If you have already built the xDrip and are adding this, follow this first step:
+  * Remove the solder from the VIN and GND pins on the Wixel if possible using a solder sucker or solder wick.  If this is not possible, then you will have to work carefully by keeping the holes heated while inserting the resistors.  Keep in mind, if you do not have a controllable temperature soldering iron, you risk burning the board or the pads and ruining the Wixel.  **I highly recommend getting a solder sucker.**
+  * You will need to grab a new copy of the Wixel code and upload it to your Wixel for this modification to work.  The process is the same as when you first loaded the code onto the Wixel, except you will need to click the "Erase Flash" button first.
+
+ ###### Building the voltage divider
+ * Bend the one end of each resistor at a 90 degree angle as close to the resistor as possible 
+ ![Imgur](http://i.imgur.com/TXPCYx9.jpg)
+ * Using helping hands or tape, face the two resistors towards each other and place them side by side so that the leads are touching at the top
+ ![Imgur](http://i.imgur.com/WJNnoBv.jpg)
+ * Solder the touching leads, and then solder on the piece of wire
+ ![Imgur](http://i.imgur.com/jLdzr6q.jpg)
+ ![Imgur](http://i.imgur.com/W3praDM.jpg)
+ * Trim the leads of the 90 degree bend so they are flush with the resistors and trim any excess exposed wire from the piece you added to prevent any possible shorts.
+ ![Imgur](http://i.imgur.com/IzpXo1L.jpg)
+ * Insert the leads of the voltage divider into the VIN hole and GND hole.  The 1K resistor goes into the VIN hole and the 2.2K resistor goes into the GND hole next to it.  Additionally, insert the wires from the LiPo charger into the appropriate VIN and GND holes.
+ ![Imgur](http://i.imgur.com/zpLtRoc.jpg)
+ * CAREFULLY bend the resistor leads you inserted so the voltage divider is flat against the Wixel
+ ![Imgur](http://i.imgur.com/cvRmHaO.jpg)
+ * Solder the VIN and GND pads
+ ![Imgur](http://i.imgur.com/N9mqE99.jpg)
+ * Trim the excess wire from the resistor leads
+ ![Imgur](http://i.imgur.com/EFCnUlv.jpg)
+ * The back of your Wixel should look like this
+ ![Imgur](http://i.imgur.com/eYh9yOR.jpg)
+ * If you want to add a piece of heat shrink tubing to protect the resistors (highly recommended!), put it on now.
+ ![Imgur](http://i.imgur.com/4vyTY4v.jpg)
+  * Trim the wire you added to the voltage divider so that it is long enough to reach P0_0, and then insert it into the hole and solder it.
+ ![Imgur](http://i.imgur.com/4b625P5.jpg)
+ ![Imgur](http://i.imgur.com/97ZKzcC.jpg)
+ * Trim the excess leads from the soldered pads on the Wixel
+ ![Imgur](http://i.imgur.com/fXgbnp5.jpg)
+ * CAREFULLY heat the heat shrink tubing with the iron.  Only touch the tubing for a second to get it to slightly heat up and do this in multiple places.  You only want it to shrink enough to not fall off, it does not have to be super tight against the resistors.  **DO NOT USE A LIGHTER!**
+ ![Imgur](http://i.imgur.com/KfWcZfd.jpg)
+ * Congratulate yourself for building an electronic circuit!
+I also tossed it all into a "Crush Proof Pill Box" from CVS (Cost like $2)
+![Imgur](http://i.imgur.com/uB40JUG.jpg)
+![Imgur](http://i.imgur.com/8xIdz5w.jpg)
diff --git a/xDrip-Experimental.iml b/xDrip-Experimental.iml
new file mode 100644
index 0000000..c3eb993
--- /dev/null
+++ b/xDrip-Experimental.iml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+

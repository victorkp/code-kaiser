diff --git a/app/build.gradle b/app/build.gradle
index bd9f7db..479425e 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -21,13 +21,14 @@ android {
 
     defaultConfig {
         applicationId "com.eveningoutpost.dexdrip"
-        minSdkVersion 19
+        minSdkVersion 17
         targetSdkVersion 21
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
     }
+
 }
 
 dependencies {
diff --git a/app/lint.xml b/app/lint.xml
new file mode 100644
index 0000000..04c2a8e
--- /dev/null
+++ b/app/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="InvalidPackage" severity="warning" />
+    <issue id="MissingPrefix" severity="warning" />
+    <issue id="MissingPrefix" severity="warning" />
+    <issue id="MissingRegistered" severity="warning" />
+    <issue id="MenuTitle" severity="warning" />
+</lint>
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 3b0e4e9..a855c06 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -18,6 +18,7 @@
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.BATTERY_STATS" />
     <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
     <uses-permission android:name="android.permission.WAKE_LOCK" />
     <uses-permission android:name="android.permission." />
 
@@ -142,6 +143,11 @@
                 android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED"
                 android:resource="@xml/device_filter" />
         </activity>
+        <receiver android:name=".UtilityModels.NetworkChangeReceiver" >
+            <intent-filter>
+                <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
+            </intent-filter>
+        </receiver>
 
         <service
             android:name=".Services.DexShareCollectionService"
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java b/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
index e17f39c..ca38ecf 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/BluetoothScan.java
@@ -23,10 +23,12 @@
 
 import com.activeandroid.query.Select;
 import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
+import com.eveningoutpost.dexdrip.Services.BluetoothReader;
 import com.eveningoutpost.dexdrip.Services.DexCollectionService;
 import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 
 import java.util.ArrayList;
+import java.util.Set;
 
 @TargetApi(android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)
 public class BluetoothScan extends ListActivity implements NavigationDrawerFragment.NavigationDrawerCallbacks {
@@ -78,6 +80,14 @@ protected void onCreate(Bundle savedInstanceState) {
         mLeDeviceListAdapter = new LeDeviceListAdapter();
         setListAdapter(mLeDeviceListAdapter);
 
+        Set<BluetoothDevice> pairedDevices = bluetooth_adapter.getBondedDevices();
+        if (pairedDevices.size() > 0) {
+            // Loop through paired devices
+            for (BluetoothDevice device : pairedDevices) {
+                // Add the name and address to an array adapter to show in a ListView
+                mLeDeviceListAdapter.addDevice(device);
+            }
+        }
     }
 
     @Override
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/DexdripPacket.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/DexdripPacket.java
new file mode 100644
index 0000000..946d4d6
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/DexdripPacket.java
@@ -0,0 +1,8 @@
+package com.eveningoutpost.dexdrip.Models;
+
+/**
+ * Created by Radu Iliescu on 25.02.2015.
+ */
+public class DexdripPacket {
+    public static final int PACKET_DATA = 1;
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
index 31af819..9604d73 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
@@ -7,6 +7,7 @@
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
+import com.eveningoutpost.dexdrip.utils.PacketUtil;
 
 import java.util.Date;
 import java.util.UUID;
@@ -78,6 +79,38 @@ public static TransmitterData create(int raw_data ,int sensor_battery_level, lon
         return transmitterData;
     }
 
+    public static TransmitterData createFromBinary(byte data[]) {
+        /* this is the C structure packed in data
+           - needs to be in sync with wixel-DexDrip/libraries/include/dexdrip_packet.h
+        struct dexdrip_data_packet {
+            uint32 raw;
+            int16  dexdrip_battery;
+            uint8  dexcom_battery;
+            uint8  padding;
+        };
+        length 8
+        */
+
+        if (data.length != 8) {
+            /* incompatible ABI with wixel */
+            return null;
+        }
+
+        int wixel_battery;
+        TransmitterData transmitterData = new TransmitterData();
+
+        transmitterData.raw_data = PacketUtil.uint32FromBuffer(data, 0);
+        wixel_battery = PacketUtil.int16FromBuffer(data, 4);
+        transmitterData.sensor_battery_level = PacketUtil.uint8FromBuffer(data, 6);
+        transmitterData.timestamp = new Date().getTime();
+        transmitterData.uuid = UUID.randomUUID().toString();
+        Log.d(TAG, "binary transmitter data raw " + transmitterData.raw_data +
+                " sensor battery " + transmitterData.sensor_battery_level +
+                " wixel battery " + wixel_battery);
+        transmitterData.save();
+        return transmitterData;
+    }
+
     public static TransmitterData last() {
         return new Select()
                 .from(TransmitterData.class)
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/BluetoothReader.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/BluetoothReader.java
new file mode 100644
index 0000000..5c96d21
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/BluetoothReader.java
@@ -0,0 +1,178 @@
+package com.eveningoutpost.dexdrip.Services;
+
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSocket;
+import android.content.Context;
+import android.util.Log;
+
+import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.Models.DexdripPacket;
+import com.eveningoutpost.dexdrip.Models.TransmitterData;
+import com.eveningoutpost.dexdrip.Sensor;
+import com.eveningoutpost.dexdrip.UtilityModels.HC05Attributes;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.UUID;
+
+/**
+ * Created by Radu Iliescu on 1/24/2015.
+ *
+ * Bluetooth (nonBLE) reader service
+ */
+public class BluetoothReader extends Thread {
+    private final static String TAG = BluetoothReader.class.getName();
+    private final static int minReadSize = 8;
+
+    private static BluetoothReader singleton = null;
+    private Context mContext;
+
+    public synchronized static BluetoothReader startBluetoothReader(BluetoothDevice device, Context context) {
+        if (singleton == null) {
+            singleton = new BluetoothReader();
+        }
+
+        singleton.mDevice = device;
+        singleton.mContext = context;
+        singleton.restart();
+
+        return singleton;
+    }
+
+    private BluetoothDevice mDevice;
+    private BluetoothSocket mSocket;
+
+    private UUID uuid = UUID.fromString(HC05Attributes.UUIDString);
+    private boolean isRunning = false;
+
+    private void restart() {
+        if (isRunning) {
+            bluetooth_stop();
+        } else {
+            this.start();
+        }
+    }
+
+    private void saveTransmitterData(TransmitterData transmitterData) {
+        Sensor sensor = Sensor.currentSensor();
+        if (sensor != null) {
+            BgReading.create(transmitterData.raw_data, mContext, new Date().getTime());
+            sensor.latest_battery_level = transmitterData.sensor_battery_level;
+            sensor.save();
+        } else {
+            Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
+        }
+    }
+
+    /* data format "len raw dex_battery wixelbattery"
+     * where len in the length of string "raw dex_battery wixel_battery"
+     */
+    private void readDataFromStream(InputStream stream) throws IOException {
+        byte[] buffer = new byte[100];
+        int totalRead = 0;
+        int readSize;
+        String str;
+        Arrays.fill(buffer, (byte)0);
+        /* read the len -> first number until " " */
+        do {
+            totalRead += stream.read(buffer, totalRead, 1);
+            str = new String(buffer, 0, totalRead);
+        } while (!str.contains(" "));
+
+        readSize = Integer.parseInt(str.substring(0, totalRead - 1));
+        totalRead = 0;
+        buffer = new byte[readSize];
+
+        while (totalRead < readSize) {
+            totalRead += stream.read(buffer, totalRead, readSize - totalRead);
+        }
+        str = new String(buffer, "UTF-8");
+        Log.d(TAG, "received data size: "  + readSize + " data: " + str);
+
+        TransmitterData transmitterData = TransmitterData.create(buffer, totalRead, new Date().getTime());
+        if (transmitterData != null) {
+            saveTransmitterData(transmitterData);
+        }
+    }
+
+    private void readBinaryData(InputStream stream) throws IOException {
+        byte packet_header[] = new byte[2];
+        int total_read = 0;
+        byte len;
+        while (total_read < 2) {
+            total_read += stream.read(packet_header, total_read, 2 - total_read);
+        }
+        Log.d(TAG, "got new packet - type " + packet_header[0] + " len " + packet_header[1]);
+        len = packet_header[1];
+        total_read = 0;
+
+        byte payload[] = new byte[packet_header[1]];
+        while (total_read < len) {
+            total_read += stream.read(payload, total_read, len - total_read);
+        }
+
+        if (packet_header[0] == DexdripPacket.PACKET_DATA) {
+            TransmitterData transmitterData = TransmitterData.createFromBinary(payload);
+            if (transmitterData != null)
+                saveTransmitterData(transmitterData);
+            else
+                throw new IOException("Incompatible wixel API");
+        } else {
+            /* packet unknown - something got seriously wrong reset bluetooth connection */
+            throw new IOException("Unexpected packet");
+        }
+    }
+
+    public void run() {
+        InputStream stream = null;
+        boolean exception = true;
+        isRunning = true;
+
+        while (isRunning && !interrupted()) {
+            try {
+                if (exception) {
+                    bluetooth_stop();
+                    connect();
+                    stream = mSocket.getInputStream();
+                }
+
+                exception = false;
+                readBinaryData(stream);
+                //readDataFromStream(stream);
+            } catch (IOException e) {
+                Log.i(TAG, "bluetooth exception " + e);
+                exception = true;
+            }
+
+            try {
+                sleep(5000);
+            } catch (InterruptedException e) {}
+        }
+        Log.i(TAG, "Bluetooth reader exited");
+        isRunning = false;
+    }
+
+    private void bluetooth_stop() {
+        try {
+            if (mSocket != null)
+                mSocket.close();
+            mSocket = null;
+        } catch ( IOException e) { }
+    }
+
+    private void connect() throws IOException {
+        BluetoothSocket tmp = null;
+
+        if (mDevice == null) {
+            Log.e(TAG, "Can't connect no device selected");
+            throw new IOException("No bluetooth device");
+        }
+        // Get a BluetoothSocket to connect with the given BluetoothDevice
+        mSocket = mDevice.createRfcommSocketToServiceRecord(uuid);
+        mSocket.connect();
+
+        Log.d(TAG, "connected to bluetooth device");
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 5760e08..529874b 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -41,6 +41,7 @@
 import com.activeandroid.query.Select;
 import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
 import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.Models.DexdripPacket;
 import com.eveningoutpost.dexdrip.Sensor;
 import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 import com.eveningoutpost.dexdrip.UtilityModels.ForegroundServiceStarter;
@@ -76,6 +77,17 @@
     private static final int STATE_CONNECTING = BluetoothProfile.STATE_CONNECTING;
     private static final int STATE_CONNECTED = BluetoothProfile.STATE_CONNECTED;
 
+    private static final int PSTATE_NEW_PACKET = 0;
+    private static final int PSTATE_PRIOR_READ_LEN = 1;
+    private static final int PSTATE_INREAD = 2;
+
+    private int mPacketState = PSTATE_NEW_PACKET;
+    private byte mPacket[];
+    private byte mPacketType;
+    private byte mPacketLen;
+    private byte mPacketReadBytes;
+    private long mLastReadTimestamp;
+
     public final static String ACTION_DATA_AVAILABLE = "com.example.bluetooth.le.ACTION_DATA_AVAILABLE";
     public final static UUID xDripDataService = UUID.fromString(HM10Attributes.HM_10_SERVICE);
     public final static UUID xDripDataCharacteristic = UUID.fromString(HM10Attributes.HM_RX_TX);
@@ -261,6 +273,14 @@ public boolean connect(final String address) {
             setRetryTimer();
             return false;
         }
+        if ((device != null) && (device.getType() != BluetoothDevice.DEVICE_TYPE_LE)) {
+            /* Non BLE device - start bluetooth reader thread;
+               Keep state machine with on CONNECTING state
+             */
+            Log.i(TAG, "non BLE device - start bluetooth reader");
+            BluetoothReader.startBluetoothReader(device, mContext);
+            return true;
+        }
         Log.w(TAG, "Trying to create a new connection.");
         mBluetoothGatt = device.connectGatt(getApplicationContext(), true, mGattCallback);
         mConnectionState = STATE_CONNECTING;
@@ -297,10 +317,87 @@ public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
             if (sensor != null) {
                 sensor.latest_battery_level = transmitterData.sensor_battery_level;
                 sensor.save();
+    public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
+        int bufferReadPos = 0;
+        int i = 0;
+        Log.w(TAG, "received some data! " + len);
+        Long timestamp = new Date().getTime();
+        if (timestamp - mLastReadTimestamp > 2000)  {
+            //if there was no read notification for over 2s means we had a malformed short packet;
+            //save the new timestamp and reset state machine
+            mPacketState = PSTATE_NEW_PACKET;
+            mLastReadTimestamp = timestamp;
+        }
+
+        if (mPacketState == PSTATE_NEW_PACKET) {
+            //beginning of a new packet - get type len and as much as available from packet
+            if (len > bufferReadPos) {
+                mPacketType = buffer[bufferReadPos];
+                Log.d(TAG, "read packet type " + mPacketType);
+                if (mPacketType != DexdripPacket.PACKET_DATA) {
+                    Log.e(TAG, "unknown or malformed packet received");
+                    return;
+                }
+
+                //goto to next state
+                mPacketState = PSTATE_PRIOR_READ_LEN;
+                bufferReadPos++;
+             }
+        }
+
+        if (mPacketState == PSTATE_PRIOR_READ_LEN) {
+            //read the packet length
+            if (len > bufferReadPos) {
+                mPacketLen = buffer[bufferReadPos];
+                Log.d(TAG, "packet len " + mPacketLen);
+                if (mPacketLen > 20) {
+                    mPacketState = PSTATE_NEW_PACKET;
+                    Log.e(TAG, "malformed packet received");
+                    return;
+                }
+                mPacketState = PSTATE_INREAD;
+                mPacket = new byte[mPacketLen];
+                mPacketReadBytes = 0;
+                bufferReadPos++;
+            }
+        }
+
+        if (mPacketState == PSTATE_INREAD) {
+            //read the packet
+            for (i = bufferReadPos; (mPacketReadBytes < mPacketLen) && (i<len); i++, mPacketReadBytes++)
+                mPacket[mPacketReadBytes] = buffer[i];
+            Log.d(TAG, "read " + mPacket);
+        }
+
+        if (mPacketState != PSTATE_INREAD)
+            //haven't make it to read state - need at least one more notification in order to have the full packet
+            return;
+
+        if (mPacketReadBytes != mPacketLen)
+            //read just part of the packet - return and read the next part in following notification
+            return;
+
+        if (i < len) {
+            //had a longer packet than what was expected
+            mPacketState = PSTATE_NEW_PACKET;
+            Log.e(TAG, "received malformed packet");
+            return;
+        }
 
-                BgReading.create(transmitterData.raw_data, this, timestamp);
-            } else {
-                Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
+        //we have the full packet create transmitter data and reset state machine
+        mPacketState = PSTATE_NEW_PACKET;
+        if (mPacketType == DexdripPacket.PACKET_DATA) {
+            TransmitterData transmitterData = TransmitterData.createFromBinary(mPacket);
+            if (transmitterData != null) {
+                Sensor sensor = Sensor.currentSensor();
+                if (sensor != null) {
+                    sensor.latest_battery_level = transmitterData.sensor_battery_level;
+                    sensor.save();
+
+                    BgReading bgReading = BgReading.create(transmitterData.raw_data, this, timestamp);
+                } else {
+                    Log.w(TAG, "No Active Sensor, Data only stored in Transmitter Data");
+                }
             }
         }
         wakeLock.release();
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HC05Attributes.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HC05Attributes.java
new file mode 100644
index 0000000..f1eb2d0
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/HC05Attributes.java
@@ -0,0 +1,8 @@
+package com.eveningoutpost.dexdrip.UtilityModels;
+
+/**
+ * Created by Radu Iliescu on 1/24/2015.
+ */
+public class HC05Attributes {
+    public static String UUIDString = "00001101-0000-1000-8000-00805F9B34FB";
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NetworkChangeReceiver.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NetworkChangeReceiver.java
new file mode 100644
index 0000000..f48e5d4
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NetworkChangeReceiver.java
@@ -0,0 +1,23 @@
+package com.eveningoutpost.dexdrip.UtilityModels;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.util.Log;
+
+/**
+ * Created by Radu Iliescu on 2/4/2015.
+ */
+public class NetworkChangeReceiver extends BroadcastReceiver {
+    private static final String TAG = NetworkChangeReceiver.class.getSimpleName();
+
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        final ConnectivityManager connMgr = (ConnectivityManager) context
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        Log.d(TAG, "Network change event");
+        if (connMgr.getActiveNetworkInfo() != null)
+            NightscoutMongoClient.resetMongoConnection();
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutMongoClient.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutMongoClient.java
new file mode 100644
index 0000000..a0eeb19
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutMongoClient.java
@@ -0,0 +1,50 @@
+package com.eveningoutpost.dexdrip.UtilityModels;
+
+import android.util.Log;
+
+import com.mongodb.DB;
+import com.mongodb.MongoClient;
+import com.mongodb.MongoClientURI;
+
+import java.net.UnknownHostException;
+
+/**
+ * Created by radu iliescu on 2/1/2015.
+ */
+public class NightscoutMongoClient {
+    private static final String TAG = NightscoutMongoClient.class.getSimpleName();
+    private String dbURI;
+    private MongoClient client;
+    private DB db;
+    private static NightscoutMongoClient singleton = null;
+
+    NightscoutMongoClient(String URI) throws UnknownHostException {
+        dbURI = URI;
+        MongoClientURI uri = new MongoClientURI(dbURI.trim());
+        client = new MongoClient(uri);
+        db = client.getDB(uri.getDatabase());
+    }
+
+    public synchronized static DB nightscoutGetDB(String URI) throws UnknownHostException{
+        if (singleton == null) {
+            singleton = new NightscoutMongoClient(URI);
+        }
+
+        if (!singleton.dbURI.equalsIgnoreCase(URI)) {
+            singleton.client.close();
+            singleton = new NightscoutMongoClient(URI);
+        }
+
+        return singleton.db;
+    }
+
+    /* Call this on exception cases so that next nightscoutGetDB
+     call would try again connecting and creating the DB */
+    public static void resetMongoConnection() {
+        Log.i(TAG, "reset connection to mongo");
+        if (singleton == null)
+            return;
+        singleton.client.close();
+        singleton.dbURI = "";
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
index 234a1ed..5109c1c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
@@ -354,13 +354,8 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
 
             if (dbURI != null && collectionName != null) {
                 try {
-
-                    // connect to db
-                    MongoClientURI uri = new MongoClientURI(dbURI.trim());
-                    MongoClient client = new MongoClient(uri);
-
                     // get db
-                    DB db = client.getDB(uri.getDatabase());
+                    DB db = NightscoutMongoClient.nightscoutGetDB(dbURI);
 
                     // get collection
                     DBCollection dexcomData = db.getCollection(collectionName.trim());
@@ -419,12 +414,11 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
                     devicestatus.put("created_at", new Date());
                     dsCollection.insert(devicestatus, WriteConcern.UNACKNOWLEDGED);
 
-                    client.close();
-
                     return true;
 
                 } catch (Exception e) {
-                    Log.e(TAG, "Unable to upload data to mongo");
+                    NightscoutMongoClient.resetMongoConnection();
+                    Log.e(TAG, "Unable to upload data to mongo" + e);
                 }
             }
             return false;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/utils/PacketUtil.java b/app/src/main/java/com/eveningoutpost/dexdrip/utils/PacketUtil.java
new file mode 100644
index 0000000..26f4db6
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/utils/PacketUtil.java
@@ -0,0 +1,52 @@
+package com.eveningoutpost.dexdrip.utils;
+
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+import java.nio.ShortBuffer;
+
+/**
+ * Created by Radu Iliescu on 26.02.2015.
+ */
+public class PacketUtil {
+    public static int int32FromBuffer(byte data[], int offset) {
+        ByteBuffer bb = ByteBuffer.wrap(data, offset, 4);
+        IntBuffer sb = bb.asIntBuffer();
+        return sb.get();
+    }
+
+    public static int uint32FromBuffer(byte data[], int offset) {
+        int ret = int32FromBuffer(data, offset);
+
+        if (ret < 0) {
+            ret += 1 << 32;
+        }
+
+        return ret;
+    }
+
+    public static int int16FromBuffer(byte data[], int offset) {
+        ByteBuffer bb = ByteBuffer.wrap(data, offset, 2);
+        ShortBuffer sb = bb.asShortBuffer();
+        return sb.get();
+    }
+
+    public static int uint16FromBuffer(byte data[], int offset) {
+        int ret = int16FromBuffer(data, offset);
+
+        if (ret < 0) {
+            ret += 1 << 16;
+        }
+
+        return ret;
+    }
+
+    public static int uint8FromBuffer(byte data[], int offset) {
+        int ret = data[offset];
+
+        if (ret < 0) {
+            ret += 1 << 8;
+        }
+        return ret;
+    }
+}

diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
index 0569470..b0c74be 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
@@ -106,8 +106,6 @@ public static AlertType get_highest_active_alert(Context context, double bg) {
             return null;
         }
 
-        checkIfMissedReadingAlert(context);
-
         if (bg <= 14) { // Special dexcom codes should not set off low alarms
             return null;
         }
@@ -135,12 +133,6 @@ public static AlertType get_highest_active_alert(Context context, double bg) {
         return at;
     }
 
-    public static void checkIfMissedReadingAlert(Context context){
-        context.startService(new Intent(context, MissedReadingService.class));
-    }
-
-
-
     // bg_minute is the estimatin of the bg change rate
     private static AlertType get_highest_active_alert_helper(double bg, SharedPreferences prefs) {
         // Chcek the low alerts
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/SnoozeActivity.java b/app/src/main/java/com/eveningoutpost/dexdrip/SnoozeActivity.java
index 843e8e6..d892bff 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/SnoozeActivity.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/SnoozeActivity.java
@@ -4,6 +4,7 @@
 import java.util.Date;
 
 import android.app.Dialog;
+import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.Bundle;
@@ -22,6 +23,7 @@
 import com.eveningoutpost.dexdrip.Services.MissedReadingService;
 import com.eveningoutpost.dexdrip.UtilityModels.AlertPlayer;
 import com.eveningoutpost.dexdrip.UtilityModels.BgGraphBuilder;
+import com.eveningoutpost.dexdrip.UtilityModels.Notifications;
 import com.eveningoutpost.dexdrip.utils.ActivityWithMenu;
 
 
@@ -177,11 +179,9 @@ private void setOnClickListenerOnClearDisabledButton(Button button, String alert
         button.setOnClickListener(new View.OnClickListener() {
             public void onClick(View v) {
                 prefs.edit().putLong(theAlert, 0).apply();
-                if (theAlert.equalsIgnoreCase("alerts_disabled_until")) {
-                    //this is needed to make sure that the missedreading alert will be rechecked, it might have to be raised
-                    //and if not (ie no missed readings for long enough) then the alarm should be reset because it might have to recheck the missedreading status sooner
-                    getApplicationContext().startService(new Intent(getApplicationContext(), MissedReadingService.class));
-                }
+                //this is needed to make sure that the missedreading alert will be rechecked, it might have to be raised
+                //and if not (ie no missed readings for long enough) then the alarm should be reset because it might have to recheck the missedreading status sooner
+                recheckAlerts();
                 //also make sure the text in the Activity is changed
                 displayStatus();
                 showDisableEnableButtons();
@@ -252,6 +252,7 @@ public void onClick(View v) {
                         //also make sure the text in the Activity is changed
                         displayStatus();
                         showDisableEnableButtons();
+                        recheckAlerts();
                     }
                 });
                 b2.setOnClickListener(new View.OnClickListener() {
@@ -267,6 +268,12 @@ public void onClick(View v) {
         });
 
     }
+    
+    public void recheckAlerts() {
+      Context context = getApplicationContext();
+      context.startService(new Intent(context, Notifications.class));
+      context.startService(new Intent(context, MissedReadingService.class));
+    }
 
     public void showDisableEnableButtons() {
         if(prefs.getLong("alerts_disabled_until", 0) > new Date().getTime()){
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
index d83925e..b45a2ad 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
@@ -34,6 +34,8 @@
 import com.eveningoutpost.dexdrip.Models.Calibration;
 import com.eveningoutpost.dexdrip.Models.CalibrationRequest;
 import com.eveningoutpost.dexdrip.Models.UserNotification;
+import com.eveningoutpost.dexdrip.Services.MissedReadingService;
+
 import com.eveningoutpost.dexdrip.R;
 import com.eveningoutpost.dexdrip.Sensor;
 
@@ -97,9 +99,11 @@ protected void onHandleIntent(Intent intent) {
         PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "NotificationsIntent");
         wl.acquire();
         Log.d("Notifications", "Running Notifications Intent Service");
-        ReadPerfs(getApplicationContext());
-        notificationSetter(getApplicationContext());
-        ArmTimer(getApplicationContext());
+        Context context =getApplicationContext(); 
+        ReadPerfs(context);
+        notificationSetter(context);
+        ArmTimer(context);
+        context.startService(new Intent(context, MissedReadingService.class));
         wl.release();
     }
 
@@ -237,8 +241,7 @@ boolean trendingToAlertEnd(Context context, Boolean newAlert, AlertType Alert) {
  * *****************************************************************************************************************
  */
 
-    // only function that is really called from outside...
-    public void notificationSetter(Context context) {
+    private void notificationSetter(Context context) {
         ReadPerfs(context);
         BgGraphBuilder bgGraphBuilder = new BgGraphBuilder(context);
         if (bg_ongoing && (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)) {
@@ -295,29 +298,73 @@ public void notificationSetter(Context context) {
         }
     }
 
+    private long calcuatleArmTime(Context ctx, long now) {
+
+      Long wakeTime = Long.MAX_VALUE; // This is the absalute time, not time from now.
+      ActiveBgAlert activeBgAlert = ActiveBgAlert.getOnly();
+      if (activeBgAlert != null) {
+          AlertType alert = AlertType.get_alert(activeBgAlert.alert_uuid);
+          if (alert != null) {
+              wakeTime = activeBgAlert.next_alert_at ;
+              Log.d(TAG , "ArmTimer waking at: "+ new Date(wakeTime) +" in " +  (wakeTime - now)/60000d + " minutes");
+          }
+      }
+      
+      // check snooze ending values
+      long alerts_disabled_until = prefs.getLong("alerts_disabled_until", 0);
+      if (alerts_disabled_until != 0) {
+        wakeTime = Math.min(wakeTime, alerts_disabled_until);
+      }
+      long high_alerts_disabled_until = prefs.getLong("high_alerts_disabled_until", 0);
+      if (high_alerts_disabled_until != 0) {
+        wakeTime = Math.min(wakeTime, high_alerts_disabled_until);
+      }
+
+      long low_alerts_disabled_until = prefs.getLong("low_alerts_disabled_until", 0);
+      if (low_alerts_disabled_until != 0) {
+        wakeTime = Math.min(wakeTime, low_alerts_disabled_until);
+      }
+      
+      // All this requires listeners on snooze changes...
+
+      // check when the first alert should be fired. take care of that ???
+      
+      Log.d("Notifications" , "calcuatleArmTime returning: "+ new Date(wakeTime) +" in " +  (wakeTime - now)/60000d + " minutes");
+      return wakeTime;
+    }
+    
     private void ArmTimer(Context ctx) {
-        Log.d(TAG, "ArmTimer called");
-        ActiveBgAlert activeBgAlert = ActiveBgAlert.getOnly();
-        if (activeBgAlert != null) {
-            AlertType alert = AlertType.get_alert(activeBgAlert.alert_uuid);
-            if (alert != null) {
-                Calendar calendar = Calendar.getInstance();
-                AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-                // sleep longer if the alert is snoozed.
-                long wakeTime = activeBgAlert.next_alert_at;
-                Log.d(TAG , "ArmTimer waking at: "+ new Date(wakeTime) +" in " +  (wakeTime - calendar.getTimeInMillis())/60000d + " minutes");
-                if (wakeIntent != null)
-                    alarm.cancel(wakeIntent);
-                wakeIntent = PendingIntent.getService(this, 0, new Intent(this, this.getClass()), 0);
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-                    alarm.setAlarmClock(new AlarmManager.AlarmClockInfo(wakeTime, wakeIntent), wakeIntent);
-                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-                    alarm.setExact(AlarmManager.RTC_WAKEUP, wakeTime, wakeIntent);
-                } else
-                    alarm.set(AlarmManager.RTC_WAKEUP, wakeTime, wakeIntent);
-            }
+        Calendar calendar = Calendar.getInstance();
+        final long now = calendar.getTimeInMillis();
+        Log.d("Notifications", "ArmTimer called");
+
+        long wakeTime = calcuatleArmTime(ctx, now);
+        if(wakeTime == Long.MAX_VALUE) {
+          Log.d("Notifications" , "ArmTimer timer will not br armed");
+          return;
         }
-    }
+        
+        if(wakeTime < now ) {
+          Log.e("Notifications" , "ArmTimer recieved a negative time, will fire in 6 minutes");
+          wakeTime = now + 6 * 60000;
+        }
+        
+        AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+
+        
+        Log.d("Notifications" , "ArmTimer waking at: "+ new Date(wakeTime ) +" in " +
+            (wakeTime - now) /60000d + " minutes");
+        if (wakeIntent != null)
+            alarm.cancel(wakeIntent);
+        wakeIntent = PendingIntent.getService(this, 0, new Intent(this, this.getClass()), 0);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            alarm.setAlarmClock(new AlarmManager.AlarmClockInfo(wakeTime, wakeIntent), wakeIntent);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            alarm.setExact(AlarmManager.RTC_WAKEUP, wakeTime, wakeIntent);
+        } else {
+            alarm.set(AlarmManager.RTC_WAKEUP, wakeTime, wakeIntent);
+        }
+    }   
 
     private Bitmap createWearBitmap(long start, long end) {
         return new BgSparklineBuilder(mContext)

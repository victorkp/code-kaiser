diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 112b35e..705a228 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -5,8 +5,9 @@
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
 import android.provider.BaseColumns;
-import com.eveningoutpost.dexdrip.Models.UserError.Log;
+import android.util.Pair;
 
+import com.eveningoutpost.dexdrip.Models.UserError.Log;
 import com.activeandroid.Model;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
@@ -14,6 +15,7 @@
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.EGVRecord;
 import com.eveningoutpost.dexdrip.ImportedLibraries.dexcom.records.SensorRecord;
 import com.eveningoutpost.dexdrip.ShareModels.ShareUploadableBg;
+import com.eveningoutpost.dexdrip.UtilityModels.BgGraphBuilder;
 import com.eveningoutpost.dexdrip.UtilityModels.BgSendQueue;
 import com.eveningoutpost.dexdrip.UtilityModels.Constants;
 import com.eveningoutpost.dexdrip.UtilityModels.Notifications;
@@ -174,19 +176,22 @@ public static double activePrediction() {
         return 0;
     }
 
+    public static Pair<Double, Boolean> calculateSlope(BgReading current, BgReading last) {
+        
+        if (current.timestamp == last.timestamp || 
+            current.timestamp - last.timestamp > BgGraphBuilder.MAX_SLOPE_MINUTES * 60 * 1000) {
+            return Pair.create(0d, true);
 
-    public static double calculateSlope(BgReading current, BgReading last) {
-        if (current.timestamp == last.timestamp || current.calculated_value == last.calculated_value) {
-            return 0;
-        } else {
-            return (last.calculated_value - current.calculated_value) / (last.timestamp - current.timestamp);
         }
+        double slope =  (last.calculated_value - current.calculated_value) / (last.timestamp - current.timestamp);
+        return Pair.create(slope, false);
     }
 
     public static double currentSlope(){
         List<BgReading> last_2 = BgReading.latest(2);
         if (last_2.size() == 2) {
-            return calculateSlope(last_2.get(0), last_2.get(1));
+            Pair<Double, Boolean> slopePair = calculateSlope(last_2.get(0), last_2.get(1));
+            return slopePair.first;
         } else{
             return 0d;
         }
@@ -240,16 +245,10 @@ public static void create(EGVRecord egvRecord, long addativeOffset, Context cont
                 bgReading.raw_calculated = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
             }
             Log.i(TAG, "create: NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
-            bgReading.calculated_value_slope = bgReading.slopefromName(egvRecord.getTrend().friendlyTrendName());
+            Pair<Double, Boolean> slopePair = BgReading.slopefromName(egvRecord.getTrend().friendlyTrendName());
+            bgReading.calculated_value_slope = slopePair.first;
+            bgReading.hide_slope = slopePair.second;
             bgReading.noise = egvRecord.noiseValue();
-            String friendlyName = egvRecord.getTrend().friendlyTrendName();
-            if(friendlyName.compareTo("NONE") == 0 ||
-                    friendlyName.compareTo("NOT_COMPUTABLE") == 0 ||
-                    friendlyName.compareTo("NOT COMPUTABLE") == 0 ||
-                    friendlyName.compareTo("OUT OF RANGE")   == 0 ||
-                    friendlyName.compareTo("OUT_OF_RANGE") == 0) {
-                bgReading.hide_slope = true;
-            }
             bgReading.save();
             bgReading.find_new_curve();
             bgReading.find_new_raw_curve();
@@ -386,44 +385,35 @@ public static void create(Context context, double raw_data, double age_adjusted_
         Calibration calibration = Calibration.last();
         if (calibration == null) {
             Log.d(TAG, "create: No calibration yet");
-            bgReading.sensor = sensor;
-            bgReading.sensor_uuid = sensor.uuid;
-            bgReading.raw_data = (raw_data / 1000);
-            bgReading.age_adjusted_raw_value = age_adjusted_raw_value;
-            bgReading.filtered_data = (filtered_data / 1000);
-            bgReading.timestamp = timestamp;
-            bgReading.uuid = UUID.randomUUID().toString();
-            bgReading.calculated_value = calculated_bg;
-            bgReading.calculated_value_slope = calculated_current_slope;
-            bgReading.hide_slope = hide_slope;
-
-            bgReading.save();
-            bgReading.perform_calculations();
         } else {
             Log.d(TAG,"Calibrations, so doing everything bgReading = " + bgReading);
-            bgReading.sensor = sensor;
-            bgReading.sensor_uuid = sensor.uuid;
             bgReading.calibration = calibration;
             bgReading.calibration_uuid = calibration.uuid;
-            bgReading.raw_data = (raw_data/1000);
-            bgReading.age_adjusted_raw_value = age_adjusted_raw_value;
-            bgReading.filtered_data = (filtered_data/1000);
-            bgReading.timestamp = timestamp;
-            bgReading.uuid = UUID.randomUUID().toString();
-            bgReading.calculated_value = calculated_bg;
-            bgReading.calculated_value_slope = calculated_current_slope;
-            bgReading.hide_slope = hide_slope;
+        }
+        
+        bgReading.sensor = sensor;
+        bgReading.sensor_uuid = sensor.uuid;
+        bgReading.raw_data = (raw_data/1000);
+        bgReading.age_adjusted_raw_value = age_adjusted_raw_value;
+        bgReading.filtered_data = (filtered_data/1000);
+        bgReading.timestamp = timestamp;
+        bgReading.uuid = UUID.randomUUID().toString();
+        bgReading.calculated_value = calculated_bg;
+        bgReading.calculated_value_slope = calculated_current_slope;
+        bgReading.hide_slope = hide_slope;
+
+        if (bgReading.calculated_value < 10) {
+            bgReading.calculated_value = 9;
+            bgReading.hide_slope = true;
+        } else {
+            bgReading.calculated_value = Math.min(400, Math.max(39, bgReading.calculated_value));
+        }
+        Log.i(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
 
-            if (bgReading.calculated_value < 10) {
-                bgReading.calculated_value = 9;
-                bgReading.hide_slope = true;
-            } else {
-                bgReading.calculated_value = Math.min(400, Math.max(39, bgReading.calculated_value));
-            }
-            Log.i(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
 
-            bgReading.save();
-        }
+
+        bgReading.save();
+
         BgSendQueue.handleNewBgReading(bgReading, "create", context);
 
         Log.i("BG GSON: ",bgReading.toS());
@@ -480,8 +470,10 @@ public String slopeName() {
         return arrow;
     }
 
-    public double slopefromName(String slope_name) {
+    public static  Pair<Double, Boolean> slopefromName(String slope_name) {
+
         double slope_by_minute = 0;
+        boolean hide = false;
         if (slope_name.compareTo("DoubleDown") == 0) {
             slope_by_minute = -3.5;
         } else if (slope_name.compareTo("SingleDown") == 0) {
@@ -502,8 +494,11 @@ public double slopefromName(String slope_name) {
                    slope_name.compareTo("OUT OF RANGE")   == 0 ||
                    slope_name.compareTo("NONE") == 0) {
             slope_by_minute = 0;
+            hide = true;
         }
-        return slope_by_minute /60000;
+
+        slope_by_minute /= 60000;
+        return Pair.create(slope_by_minute, hide);
     }
 
     public static BgReading last() {
@@ -643,15 +638,18 @@ public void find_slope() {
 
         assert last_2.get(0)==this : "Invariant condition not fulfilled: calculating slope and current reading wasn't saved before";
 
+        hide_slope = true;
         if (last_2.size() == 2) {
-            calculated_value_slope = calculateSlope(this, last_2.get(1));
-            save();
+            Pair<Double, Boolean> slopePair = calculateSlope(this, last_2.get(1));
+            calculated_value_slope = slopePair.first;
+            hide_slope = slopePair.second;
         } else if (last_2.size() == 1) {
             calculated_value_slope = 0;
-            save();
         } else {
             Log.w(TAG, "NO BG? COULDNT FIND SLOPE!");
+            calculated_value_slope = 0;
         }
+        save();
     }
 
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/Sensor.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/Sensor.java
index 40ec967..713c563 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/Sensor.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/Sensor.java
@@ -40,10 +40,10 @@
   @Column(name = "sensor_location")
   public String sensor_location;
 
-    public static Sensor create(long started_at) {
+    public static Sensor create(long started_at, String uuid) {
         Sensor sensor = new Sensor();
         sensor.started_at = started_at;
-        sensor.uuid = UUID.randomUUID().toString();
+        sensor.uuid = uuid;
 
         sensor.save();
         SensorSendQueue.addToQueue(sensor);
@@ -126,6 +126,14 @@ public static Sensor getByUuid(String xDrip_sensor_uuid) {
                 .executeSingle();
     }
     
+    public static Sensor last() {
+        Sensor sensor = new Select()
+                .from(Sensor.class)
+                .orderBy("_ID desc")
+                .limit(1)
+                .executeSingle();
+        return sensor;
+    }
 
     public static void updateBatteryLevel(Sensor sensor, int sensorBatteryLevel) {
         if(sensorBatteryLevel < 120) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java b/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
index dd9f1f4..8dd664e 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/NavigationDrawerFragment.java
@@ -25,6 +25,8 @@
 
 import java.util.List;
 
+import com.eveningoutpost.dexdrip.Services.XDripViewer;
+
 public class NavigationDrawerFragment extends Fragment {
     private static final String STATE_SELECTED_POSITION = "selected_navigation_drawer_position";
     private static final String PREF_USER_LEARNED_DRAWER = "navigation_drawer_learned";
@@ -245,7 +247,11 @@ private void showGlobalContextActionBar() {
         ActionBar actionBar = getActionBar();
         actionBar.setDisplayShowTitleEnabled(true);
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
-        actionBar.setTitle(R.string.app_name);
+        String app_name = actionBar.getThemedContext().getString(R.string.app_name);
+        if(XDripViewer.isNightScoutMode(actionBar.getThemedContext())) {
+            app_name = app_name + " nightscout";
+        }
+        actionBar.setTitle(app_name);
     }
 
     private ActionBar getActionBar() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/NsRestApiReader.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/NsRestApiReader.java
index 647ff40..1007c97 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/NsRestApiReader.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/NsRestApiReader.java
@@ -27,10 +27,13 @@
 	    double xDrip_filtered; // filtered_data;
 	    Long date; // timestamp
 	    double sgv; // calculated_bg
-	    double unfiltered; // xdrip raw data
+	    double unfiltered; // raw data
+	    double filtered; // filtered data
 	    double xDrip_calculated_value;
 	    double xDrip_calculated_current_slope;
 	    boolean xDrip_hide_slope;
+	    String device;
+	    String direction;
 	}
 
 	class NightscoutMbg {
@@ -43,6 +46,7 @@
 	    double xDrip_sensor_confidence;
 	    long xDrip_raw_timestamp;
 	    String xDrip_sensor_uuid;
+	    String device;
 	}
 	
    class NightscoutSensor {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/XDripViewer.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/XDripViewer.java
index 4efa48b..c892234 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/XDripViewer.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/XDripViewer.java
@@ -1,5 +1,6 @@
 package com.eveningoutpost.dexdrip.Services;
 
+import java.util.Date;
 import java.util.List;
 import java.util.ListIterator;
 
@@ -9,6 +10,7 @@
 import android.os.AsyncTask;
 import android.os.PowerManager;
 import android.preference.PreferenceManager;
+import android.util.Pair;
 
 import com.eveningoutpost.dexdrip.Models.BgReading;
 import com.eveningoutpost.dexdrip.Models.Calibration;
@@ -25,7 +27,11 @@
 //need synchronization
 
 public class XDripViewer extends AsyncTaskBase {
-    
+
+    static Sensor sensor_exists = null; // Will hold reference to any existing sensor, to avoid looking in DB
+    static Boolean isNightScoutMode = null;
+    public final static String NIGHTSCOUT_SENSOR_UUID = "c5f1999c-4ec5-449e-adad-3980b172b921";
+
     private final static String TAG = XDripViewer.class.getName();
     
     XDripViewer(Context ctx) {
@@ -107,6 +113,9 @@ private void readCalData(String baseUrl, String key) {
                 Log.e(TAG, "not inserting calibratoin, since order is wrong. ");
                 continue;
             }
+            
+            verifyViewerNightscoutMode(mContext, nightscoutMbg);
+            
             Calibration.createUpdate(nightscoutMbg.xDrip_sensor_uuid, nightscoutMbg.mbg, nightscoutMbg.date, nightscoutMbg.xDrip_intercept, nightscoutMbg.xDrip_slope, nightscoutMbg.xDrip_estimate_raw_at_time_of_calibration,
                     nightscoutMbg.xDrip_slope_confidence , nightscoutMbg.xDrip_sensor_confidence, nightscoutMbg.xDrip_raw_timestamp);
             lastInserted = nightscoutMbg.date;
@@ -145,11 +154,14 @@ private void readBgData(String baseUrl, String key) {
               Log.e(TAG, "not inserting packet, since order is wrong. ");
               continue;
             }
+            
+            verifyViewerNightscoutMode(mContext, nightscoutBg);
+            
             TransmitterData.create((int)nightscoutBg.xDrip_raw, 100 /* ??????? */, nightscoutBg.date);
             BgReading.create(mContext, 
                     nightscoutBg.xDrip_raw != 0 ? nightscoutBg.xDrip_raw * 1000 : nightscoutBg.unfiltered,
                     nightscoutBg.xDrip_age_adjusted_raw_value,
-                    nightscoutBg.xDrip_raw != 0 ? nightscoutBg.xDrip_filtered * 1000 : nightscoutBg.unfiltered,
+                    nightscoutBg.xDrip_raw != 0 ? nightscoutBg.xDrip_filtered * 1000 : nightscoutBg.filtered,
                     nightscoutBg.date, 
                     nightscoutBg.xDrip_calculated_value != 0 ? nightscoutBg.xDrip_calculated_value : nightscoutBg.sgv,
                     nightscoutBg.xDrip_calculated_current_slope,
@@ -178,6 +190,84 @@ public static boolean isxDripViewerConfigured(Context ctx) {
         }
         return true;
     }
+    
+    // This function checkes if we are looking at a nightscout site that is being uploaded by dexcom.
+    // In this case, we will not see sensors, and we need to create one.
+    // We identify such a mod by the fact that there are no sensors, and by the fact that on this bg,
+    // we see device == dexcom
+    // We make sure that all decisions will be cached.
+    
+    public static boolean isNightScoutMode(Context context) {
+        if (isNightScoutMode != null) {
+            Log.e(TAG, "IsNightScoutMode returning " + isNightScoutMode); //???
+            return isNightScoutMode;
+        }
+        if(!isxDripViewerMode(context)) {
+            return false;
+        }
+        Sensor sensor = Sensor.last();
+        if(sensor == null) {
+            return false;
+        }
+        isNightScoutMode = new Boolean( sensor.uuid.equals(NIGHTSCOUT_SENSOR_UUID));
+        Log.e(TAG, "IsNightScoutMode = " + isNightScoutMode);
+        return isNightScoutMode;
+    }
+    
+    private static void verifyViewerNightscoutMode(Context context, NightscoutBg nightscoutBg) {
+        verifyViewerNightscoutModeSensor(nightscoutBg.device);
+        if(!isNightScoutMode(context)) {
+            return;
+        }
+        // There are some fields that we might be missing, fix that
+        if(nightscoutBg.unfiltered == 0 ) {
+            nightscoutBg.unfiltered = nightscoutBg.sgv;
+        }
+        if(nightscoutBg.filtered == 0 ) {
+            nightscoutBg.filtered = nightscoutBg.sgv;
+        }
+        
+        Pair<Double, Boolean> slopePair = BgReading.slopefromName(nightscoutBg.direction);
+
+        nightscoutBg.xDrip_calculated_current_slope = slopePair.first;
+        nightscoutBg.xDrip_hide_slope = slopePair.second;
+    }
+    
+    private static void verifyViewerNightscoutMode(Context context,  NightscoutMbg nightscoutMbg ) {
+        verifyViewerNightscoutModeSensor(nightscoutMbg.device);
+        if(!isNightScoutMode(context)) {
+            return;
+        }
+        // There are some fields that we might be missing, fix that
+        nightscoutMbg.xDrip_sensor_uuid = NIGHTSCOUT_SENSOR_UUID;
+            
+    }
+   
+    
+    private static void verifyViewerNightscoutModeSensor(String device) {
+        if(sensor_exists != null) {
+            // We already have a cached sensor, no need to continue.
+            return;
+        }
+        sensor_exists = Sensor.last();
+        if(sensor_exists != null) {
+            // We already have a sensor, no need to continue.
+            return;
+        }
+        
+        if(device == null) {
+            return;
+        }
+        if(!device.equals("dexcom")) {
+            return;
+        }
+        // No sensor exists, uploader is dexcom, let's create one.
+        Log.e(TAG, "verifyViewerNightscoutModeSensor creating nightscout sensor");
+        Sensor.create(new Date().getTime(), NIGHTSCOUT_SENSOR_UUID);
+        isNightScoutMode = new Boolean(true);
+    }
+    
+    
 /*
  * curl examples
  * curl -X GET --header "Accept: application/json api-secret: 6aaafe81264eb79d079caa91bbf25dba379ff6e2" "https://snirdar.azurewebsites.net/api/v1/entries/cal?count=122" -k
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java b/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
index e4bf640..97dfe39 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/StartNewSensor.java
@@ -19,6 +19,8 @@
 
 import java.util.Calendar;
 
+import java.util.Date;
+import java.util.UUID;
 
 public class StartNewSensor extends ActivityWithMenu {
     public static String menu_name = "Start Sensor";
@@ -97,7 +99,7 @@ public void onClick(View v) {
               tp.getCurrentHour(), tp.getCurrentMinute(), 0);
               long startTime = calendar.getTime().getTime();
 
-              Sensor.create(startTime);
+              Sensor sensor = Sensor.create(startTime, UUID.randomUUID().toString());
               Log.d("NEW SENSOR", "Sensor started at " + startTime);
 
               Toast.makeText(getApplicationContext(), "NEW SENSOR STARTED", Toast.LENGTH_LONG).show();
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
index 80da44b..3f65813 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgGraphBuilder.java
@@ -38,6 +38,7 @@
  */
 public class BgGraphBuilder {
     public static final int FUZZER = (1000 * 30 * 5);
+    public static final int MAX_SLOPE_MINUTES = 21;
     public long  end_time;
     public long  start_time;
     public Context context;
@@ -387,7 +388,7 @@ public String unitized_string(double value) {
     public String unitizedDeltaString(boolean showUnit, boolean highGranularity) {
 
         List<BgReading> last2 = BgReading.latest(2);
-        if(last2.size() < 2 || last2.get(0).timestamp - last2.get(1).timestamp > 20 * 60 * 1000){
+        if(last2.size() < 2 || last2.get(0).timestamp - last2.get(1).timestamp > MAX_SLOPE_MINUTES * 60 * 1000){
             // don't show delta if there are not enough values or the values are more than 20 mintes apart
             return "???";
         }

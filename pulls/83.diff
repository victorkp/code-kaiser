diff --git a/app/app.iml b/app/app.iml
index bcf3a3e..bcf8557 100644
--- a/app/app.iml
+++ b/app/app.iml
@@ -93,9 +93,9 @@
     <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />
     <orderEntry type="library" exported="" name="crashlytics-2.2.3" level="project" />
     <orderEntry type="library" exported="" name="answers-1.1.2" level="project" />
+    <orderEntry type="library" exported="" name="rxjava-1.0.0" level="project" />
     <orderEntry type="library" exported="" name="retrofit-1.9.0" level="project" />
     <orderEntry type="library" exported="" name="acra-4.5.0" level="project" />
-    <orderEntry type="library" exported="" name="rxjava-1.0.0" level="project" />
     <orderEntry type="library" exported="" name="support-annotations-22.1.1" level="project" />
     <orderEntry type="library" exported="" name="beta-1.1.2" level="project" />
     <orderEntry type="library" exported="" name="appcompat-v7-22.1.1" level="project" />
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 30ecc6f..a743aa3 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -323,8 +323,12 @@ public static BgReading create(double raw_data, double filtered_data, Context co
                     }
                     bgReading.calculated_value = ((calibration.slope * bgReading.age_adjusted_raw_value) + calibration.intercept);
                 }
-
-                bgReading.calculated_value = Math.min(400, Math.max(40, bgReading.calculated_value));
+                if (bgReading.calculated_value < 10) {
+                    bgReading.calculated_value = 9;
+                    bgReading.hide_slope = true;
+                } else {
+                    bgReading.calculated_value = Math.min(400, Math.max(40, bgReading.calculated_value));
+                }
                 Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
 
                 bgReading.save();
@@ -490,6 +494,12 @@ public static BgReading lastNoSenssor() {
                 .orderBy("timestamp desc")
                 .execute();
     }
+    public static BgReading findByUuid(String uuid) {
+        return new Select()
+                .from(BgReading.class)
+                .where("uuid = ?", uuid)
+                .executeSingle();
+    }
 
     public static double estimated_bg(double timestamp) {
         timestamp = timestamp + BESTOFFSET;
@@ -674,11 +684,11 @@ public String toS() {
         return gson.toJson(this);
     }
 
-    public String noiseValue() {
+    public int noiseValue() {
         if(noise == null || noise.compareTo("") == 0) {
-            return "1";
+            return 1;
         } else {
-            return String.valueOf(noise);
+            return Integer.valueOf(noise);
         }
     }
 
@@ -783,7 +793,7 @@ private static boolean checkForDropRiseAllert(float MaxSpeed, boolean drop) {
             return false;
         }
         float time3 = (latest.get(0).timestamp - latest.get(3).timestamp) / 60000;
-        double bg_diff3 = latest.get(3).calculated_value - latest.get(0).calculated_value;;
+        double bg_diff3 = latest.get(3).calculated_value - latest.get(0).calculated_value;
         if (!drop) {
             bg_diff3 *= (-1);
         }
@@ -874,10 +884,7 @@ public static boolean trendingToAlertEnd(Context context, boolean above) {
     // Should that be combined with noiseValue?
     private Boolean Unclear() {
         Log.e(TAG_ALERT, "Unclear filtered_data=" + filtered_data + " raw_data=" + raw_data);
-        if (raw_data > filtered_data * 1.3 || raw_data < filtered_data * 0.7) {
-            return true;
-        }
-        return false;
+        return raw_data > filtered_data * 1.3 || raw_data < filtered_data * 0.7;
     }
 
     /*
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
index b35acd4..5d44bb9 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/TransmitterData.java
@@ -55,13 +55,12 @@ public static TransmitterData create(byte[] buffer, int len, Long timestamp) {
             for (int i = 0; i < len; ++i) { data_string.append((char) buffer[i]); }
             String[] data = data_string.toString().split("\\s+");
 
-            randomDelay(100, 2000);
+            randomDelay(100, 1000);
             TransmitterData lastTransmitterData = TransmitterData.last();
             if (lastTransmitterData != null && lastTransmitterData.raw_data == Integer.parseInt(data[0]) && Math.abs(lastTransmitterData.timestamp - timestamp) < (10000)) { //Stop allowing duplicate data, its bad!
                 return null;
             }
             if (data.length > 1) { transmitterData.sensor_battery_level = Integer.parseInt(data[1]); }
-            if (Integer.parseInt(data[0]) < 1000) { return null; }
             transmitterData.raw_data = Integer.parseInt(data[0]);
             transmitterData.filtered_data = Integer.parseInt(data[0]);
         }
@@ -72,7 +71,7 @@ public static TransmitterData create(byte[] buffer, int len, Long timestamp) {
     }
 
     public static TransmitterData create(int raw_data ,int sensor_battery_level, long timestamp) {
-        randomDelay(100, 2000);
+        randomDelay(100, 1000);
         TransmitterData lastTransmitterData = TransmitterData.last();
         if (lastTransmitterData != null && lastTransmitterData.raw_data == raw_data && Math.abs(lastTransmitterData.timestamp - new Date().getTime()) < (10000)) { //Stop allowing duplicate data, its bad!
             return null;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index aa96e5a..b43fa05 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -270,7 +270,7 @@ public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteris
             PowerManager powerManager = (PowerManager) mContext.getSystemService(mContext.POWER_SERVICE);
             PowerManager.WakeLock wakeLock1 = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                     "DexCollectionService");
-            wakeLock1.acquire(8000);
+            wakeLock1.acquire();
             try {
                 Log.w(TAG, "onCharacteristicChanged entered");
                 final byte[] data = characteristic.getValue();
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
index 77740ad..9ad5214 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
@@ -265,73 +265,69 @@ public void attemptRead() {
         PowerManager powerManager = (PowerManager) getApplicationContext().getSystemService(getApplicationContext().POWER_SERVICE);
         PowerManager.WakeLock wakeLock1 = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                 "ReadingShareData");
-        wakeLock1.acquire(40000);
-        try {
+        wakeLock1.acquire(15000);
             Log.d(TAG, "Attempting to read data");
             final Action1<Long> systemTimeListener = new Action1<Long>() {
                 @Override
                 public void call(Long s) {
-                    if (s != null) {
-                        Log.d(TAG, "Made the full round trip, got " + s + " as the system time");
-                        final long addativeSystemTimeOffset = new Date().getTime() - s;
-
-                        final Action1<Long> dislpayTimeListener = new Action1<Long>() {
-                            @Override
-                            public void call(Long s) {
-                                if (s != null) {
-                                    Log.d(TAG, "Made the full round trip, got " + s + " as the display time offset");
-                                    final long addativeDisplayTimeOffset = addativeSystemTimeOffset - (s * 1000);
-
-                                    Log.d(TAG, "Making " + addativeDisplayTimeOffset + " the the total time offset");
-
-                                    final Action1<EGVRecord[]> evgRecordListener = new Action1<EGVRecord[]>() {
-                                        @Override
-                                        public void call(EGVRecord[] egvRecords) {
-                                            if (egvRecords != null) {
-                                                Log.d(TAG, "Made the full round trip, got " + egvRecords.length + " EVG Records");
-                                                BgReading.create(egvRecords, addativeSystemTimeOffset, getApplicationContext());
-                                                if (shouldDisconnect) {
-                                                    stopSelf();
-                                                } else {
-                                                    setRetryTimer();
-                                                }
+                if (s != null) {
+                    Log.d(TAG, "Made the full round trip, got " + s + " as the system time");
+                    final long addativeSystemTimeOffset = new Date().getTime() - s;
+
+                    final Action1<Long> dislpayTimeListener = new Action1<Long>() {
+                        @Override
+                        public void call(Long s) {
+                            if (s != null) {
+                                Log.d(TAG, "Made the full round trip, got " + s + " as the display time offset");
+                                final long addativeDisplayTimeOffset = addativeSystemTimeOffset - (s * 1000);
+
+                                Log.d(TAG, "Making " + addativeDisplayTimeOffset + " the the total time offset");
+
+                                final Action1<EGVRecord[]> evgRecordListener = new Action1<EGVRecord[]>() {
+                                    @Override
+                                    public void call(EGVRecord[] egvRecords) {
+                                        if (egvRecords != null) {
+                                            Log.d(TAG, "Made the full round trip, got " + egvRecords.length + " EVG Records");
+                                            BgReading.create(egvRecords, addativeSystemTimeOffset, getApplicationContext());
+                                            if (shouldDisconnect) {
+                                                stopSelf();
+                                            } else {
+                                                setRetryTimer();
                                             }
                                         }
-                                    };
-
-                                    final Action1<SensorRecord[]> sensorRecordListener = new Action1<SensorRecord[]>() {
-                                        @Override
-                                        public void call(SensorRecord[] sensorRecords) {
-                                            if (sensorRecords != null) {
-                                                Log.d(TAG, "Made the full round trip, got " + sensorRecords.length + " Sensor Records");
-                                                BgReading.create(sensorRecords, addativeSystemTimeOffset, getApplicationContext());
-                                                readData.getRecentEGVs(evgRecordListener);
-                                            }
+                                    }
+                                };
+
+                                final Action1<SensorRecord[]> sensorRecordListener = new Action1<SensorRecord[]>() {
+                                    @Override
+                                    public void call(SensorRecord[] sensorRecords) {
+                                        if (sensorRecords != null) {
+                                            Log.d(TAG, "Made the full round trip, got " + sensorRecords.length + " Sensor Records");
+                                            BgReading.create(sensorRecords, addativeSystemTimeOffset, getApplicationContext());
+                                            readData.getRecentEGVs(evgRecordListener);
                                         }
-                                    };
-
-                                    final Action1<CalRecord[]> calRecordListener = new Action1<CalRecord[]>() {
-                                        @Override
-                                        public void call(CalRecord[] calRecords) {
-                                            if (calRecords != null) {
-                                                Log.d(TAG, "Made the full round trip, got " + calRecords.length + " Cal Records");
-                                                Calibration.create(calRecords, addativeDisplayTimeOffset, getApplicationContext());
-                                                readData.getRecentSensorRecords(sensorRecordListener);
-                                            }
+                                    }
+                                };
+
+                                final Action1<CalRecord[]> calRecordListener = new Action1<CalRecord[]>() {
+                                    @Override
+                                    public void call(CalRecord[] calRecords) {
+                                        if (calRecords != null) {
+                                            Log.d(TAG, "Made the full round trip, got " + calRecords.length + " Cal Records");
+                                            Calibration.create(calRecords, addativeDisplayTimeOffset, getApplicationContext());
+                                            readData.getRecentSensorRecords(sensorRecordListener);
                                         }
-                                    };
-                                    readData.getRecentCalRecords(calRecordListener);
-                                }
+                                    }
+                                };
+                                readData.getRecentCalRecords(calRecordListener);
                             }
-                        };
-                        readData.readDisplayTimeOffset(dislpayTimeListener);
-                    }
+                        }
+                    };
+                    readData.readDisplayTimeOffset(dislpayTimeListener);
                 }
-            };
-            readData.readSystemTime(systemTimeListener);
-        } finally {
-            wakeLock1.release();
-        }
+            }
+        };
+        readData.readSystemTime(systemTimeListener);
     }
 
     public boolean connect(final String address) {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java
index 1c6d5cb..9e4139d 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/DexcomShareInterface.java
@@ -1,5 +1,7 @@
 package com.eveningoutpost.dexdrip.ShareModels;
 
+import com.eveningoutpost.dexdrip.ShareModels.UserAgentInfo.UserAgent;
+
 import java.util.Map;
 
 import retrofit.Callback;
@@ -12,9 +14,6 @@
  * Created by stephenblack on 3/16/15.
  */
 public interface DexcomShareInterface {
-    @POST("/Publisher/ReadPublisherLatestGlucoseValues")
-    ShareGlucose[] getShareBg(@QueryMap Map<String, String> options);
-
     @POST("/General/LoginPublisherAccountByName")
     void getSessionId(@Body ShareAuthenticationBody body, Callback<Response> callback);
     //Since this seems to respond with a string we need a callback that will parse the response body
@@ -25,9 +24,55 @@
     // needs ?sessionId={YourSessionId}
     // returns true or false
 
+    @POST("/Publisher/StartRemoteMonitoringSession")
+    void StartRemoteMonitoringSession(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&serialNumber={YourdexcomSerialNumber}
+    // returns status code
+
     @POST("/Publisher/PostReceiverEgvRecords")
     void uploadBGRecords(@QueryMap Map<String, String> options, @Body ShareUploadPayload payload, Callback<Response> callback);
     // needs ?sessionId={YourSessionId}
     // body ShareUploadPayload
-    // status code
+    // returns status code
+
+    @POST("/General/AuthenticatePublisherAccount")
+    void authenticatePublisherAccount(@Body ShareAuthenticationBody body, @QueryMap Map<String, String> options, Callback<Response> callback);
+    // maybe needs ?sessionId={YourSessionId}&serialNumber={YourdexcomSerialNumber}
+    // body ShareUploadPayload
+    // returns status code
+
+    @POST("/Publisher/CheckMonitoredReceiverAssignmentStatus")
+    void checkMonitorAssignment(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&serialNumber={YourdexcomSerialNumber}
+    // returns `AssignedToYou` or `NotAssigned`
+
+    @POST("/Publisher/ReplacePublisherAccountMonitoredReceiver")
+    void updateMonitorAssignment(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&serialNumber={YourdexcomSerialNumber}
+    // returns status code?
+
+
+    @POST("/Publisher/UpdatePublisherAccountRuntimeInfo")
+    void updatePublisherAccountInfo(@Body UserAgent body, Callback<Response> callback);
+    //Since this seems to respond with a string we need a callback that will parse the response body
+    //new String(((TypedByteArray) response.getBody()).getBytes());
+
+
+
+    //Follower Related
+    @POST("/Publisher/DoesContactExistByName")
+    void doesContactExist(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&contactName={newcontactName}
+    // returns true or false
+
+    @POST("/Publisher/CreateContact")
+    void createContact(@QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&contactName={newcontactName}&emailAddress={FollowerEmail}
+    // returns a contact id
+
+    @POST("/Publisher/CreateSubscriptionInvitation")
+    void createInvitationForContact(@Body InvitationPayload body, @QueryMap Map<String, String> options, Callback<Response> callback);
+    // needs ?sessionId={YourSessionId}&contactId={ContactId}
+    // returns a contact id
+
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/FollowerInvite.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/FollowerInvite.java
new file mode 100644
index 0000000..1f65e71
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/FollowerInvite.java
@@ -0,0 +1,146 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+import android.provider.BaseColumns;
+import android.util.Log;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
+import com.google.gson.GsonBuilder;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import retrofit.Callback;
+import retrofit.RestAdapter;
+import retrofit.RetrofitError;
+import retrofit.android.AndroidLog;
+import retrofit.client.Response;
+import retrofit.converter.GsonConverter;
+import retrofit.mime.TypedByteArray;
+
+/**
+ * Created by stephenblack on 7/17/15.
+ */
+
+@Table(name = "FollowerInvites", id = BaseColumns._ID)
+public class FollowerInvite extends Model {
+    private String sessionId;
+    private String contactId;
+
+    @Column(name = "email")
+    public String email;
+
+    @Column(name = "follower_name")
+    public String followerName;
+
+    @Column(name = "display_name")
+    public String displayName;
+
+    @Column(name = "invited")
+    public boolean invited;
+
+    public static FollowerInvite nextFollowerInvite() {
+        return new Select().from(FollowerInvite.class)
+                .where("invited = ?", false)
+                .orderBy("_ID desc")
+                .executeSingle();
+    }
+
+    public void startSendingInvite(String sessionId) {
+        this.sessionId = sessionId;
+        new ShareRest().emptyBodyInterface().doesContactExist(queryCheckContactExists(), new Callback() {
+            @Override
+            public void success(Object o, Response response) {
+                if (new String(((TypedByteArray) response.getBody()).getBytes()).toLowerCase().contains("true")) {
+                    Log.d("ShareFollower", "contact already exists");
+                    delete();
+                } else {
+                    createContact();
+                }
+            }
+
+            @Override
+            public void failure(RetrofitError retrofitError) {
+                Log.e("RETROFIT ERROR: ", "Trouble Checking if contact exists", retrofitError);
+            }
+        });
+    }
+
+    private void createContact() {
+        new ShareRest().emptyBodyInterface().createContact(queryCreateContact(), new Callback() {
+            @Override
+            public void success(Object o, Response response) {
+                Log.d("ShareFollower", "contact created!");
+                contactId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
+                sendInviteToContact();
+            }
+
+            @Override
+            public void failure(RetrofitError retrofitError) {
+                Log.e("RETROFIT ERROR", "Creating new Contact", retrofitError);
+            }
+        });
+    }
+
+    private void sendInviteToContact() {
+        jsonBodyInterface().createInvitationForContact(invitationPayload(), querySendInvite(), new Callback() {
+            @Override
+            public void success(Object o, Response response) {
+                Log.d("ShareFollower", "contact Invite sent!");
+                delete();
+            }
+
+            @Override
+            public void failure(RetrofitError retrofitError) {
+                Log.e("RETROFIT ERROR", "Sending invite", retrofitError);
+            }
+        });
+    }
+
+    private InvitationPayload invitationPayload() {
+        return new InvitationPayload(displayName);
+    }
+
+    public Map<String, String> queryCheckContactExists() {
+        Map<String, String> map = new HashMap<>();
+        map.put("sessionID", sessionId);
+        map.put("contactName", followerName);
+        return map;
+    }
+
+    public Map<String, String> queryCreateContact() {
+        Map<String, String> map = new HashMap<>();
+        map.put("sessionID", sessionId);
+        map.put("contactName", followerName);
+        map.put("emailAddress", email);
+        return map;
+    }
+
+    public Map<String, String> querySendInvite() {
+        Map<String, String> map = new HashMap<>();
+        map.put("sessionID", sessionId);
+        map.put("contactId", contactId);
+        return map;
+    }
+
+
+    private RestAdapter.Builder authoirizeAdapterBuilder() {
+        RestAdapter.Builder adapterBuilder = new RestAdapter.Builder();
+        adapterBuilder
+                .setClient(new ShareRest().getOkClient())
+                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("FollowerInvite"))
+                .setEndpoint("https://share1.dexcom.com/ShareWebServices/Services")
+                .setRequestInterceptor(ShareRest.authorizationRequestInterceptor)
+                .setConverter(new GsonConverter(new GsonBuilder().create()));
+        return adapterBuilder;
+    }
+
+    public DexcomShareInterface jsonBodyInterface() {
+        RestAdapter adapter = authoirizeAdapterBuilder().build();
+        DexcomShareInterface dexcomShareInterface =
+                adapter.create(DexcomShareInterface.class);
+        return dexcomShareInterface;
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/InvitationPayload.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/InvitationPayload.java
new file mode 100644
index 0000000..c106049
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/InvitationPayload.java
@@ -0,0 +1,57 @@
+package com.eveningoutpost.dexdrip.ShareModels;
+
+/**
+ * Created by stephenblack on 7/17/15.
+ */
+public class InvitationPayload {
+    public InvitationPayload(String displayName) {
+        this.DisplayName = displayName;
+    }
+    public AlertSettings AlertSettings;
+    public int Permissions = 1;
+    public String DisplayName;
+
+    public class AlertSettings {
+        public HighAlert HighAlert;
+        public LowAlert LowAlert;
+        public FixedLowAlert FixedLowAlert;
+        public NoDataAlert NoDataAlert;
+
+        public class HighAlert {
+            public int MinValue = 200;
+            public String AlarmDelay = "PT1H";
+            public int AlertType = 1;
+            public boolean IsEnabled = false;
+            public String RealarmDelay = "PT2H";
+            public String Sound = "High.wav";
+            public int MaxValue = 401;
+        }
+        public class LowAlert {
+            public int MinValue = 39;
+            public String AlarmDelay = "PT30M";
+            public int AlertType = 2;
+            public boolean IsEnabled = false;
+            public String RealarmDelay = "PT2H";
+            public String Sound = "Low.wav";
+            public int MaxValue = 70;
+        }
+        public class FixedLowAlert {
+            public int MinValue = 39;
+            public String AlarmDelay = "PT0M";
+            public int AlertType = 3;
+            public boolean IsEnabled = false;
+            public String RealarmDelay = "PT30M";
+            public String Sound = "UrgentLow.wav";
+            public int MaxValue = 55;
+        }
+        public class NoDataAlert {
+            public int MinValue = 39;
+            public String AlarmDelay = "PT1H";
+            public int AlertType = 4;
+            public boolean IsEnabled = false;
+            public String RealarmDelay = "PT0M";
+            public String Sound = "NoData.wav";
+            public int MaxValue = 401;
+        }
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java
index 10e1f27..108bdb1 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/ShareRest.java
@@ -1,18 +1,21 @@
 package com.eveningoutpost.dexdrip.ShareModels;
 
+import android.app.Service;
 import android.content.Context;
+import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.AsyncTask;
+import android.os.IBinder;
 import android.preference.PreferenceManager;
 import android.util.Log;
 
 import com.eveningoutpost.dexdrip.Models.BgReading;
+import com.eveningoutpost.dexdrip.ShareModels.UserAgentInfo.UserAgent;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.squareup.okhttp.OkHttpClient;
 
 import java.security.cert.CertificateException;
-import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -36,91 +39,228 @@
 /**
  * Created by stephenblack on 12/26/14.
  */
-public class ShareRest {
+public class ShareRest extends Service {
+    private final static String TAG = ShareRest.class.getSimpleName();
     private Context mContext;
     private String login;
     private String password;
+    private String receiverSn;
+    private String sessionId = null;
     private SharedPreferences prefs;
+    private boolean retrying = false;
+    private BgReading bg = null;
     OkClient client;
 
     public static Gson gson = new GsonBuilder()
             .excludeFieldsWithoutExposeAnnotation()
             .create();
 
-    public ShareRest(Context context) {
+    @Override
+    public IBinder onBind(Intent intent) {
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    @Override
+    public void onCreate() {
+        Log.d(TAG, "Creating service");
         client = getOkClient();
-        mContext = context;
-        prefs = PreferenceManager.getDefaultSharedPreferences(context);
+        mContext = getApplicationContext();
+        prefs = PreferenceManager.getDefaultSharedPreferences(mContext);
         login = prefs.getString("dexcom_account_name", "");
         password = prefs.getString("dexcom_account_password", "");
-    }
+        receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
+     }
 
-    public boolean getBgData() {
-        if (prefs.getBoolean("share_poll", false) && login.compareTo("") != 0 && password.compareTo("") != 0) {
-            return loginAndGetData();
+    @Override
+    public int onStartCommand (Intent intent,int flags, int startId) {
+        retrying = false;
+        bg = null;
+        login = prefs.getString("dexcom_account_name", "");
+        password = prefs.getString("dexcom_account_password", "");
+        receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
+        Log.d(TAG, "Starting service");
+        if (prefs.getBoolean("share_upload", false) && login.compareTo("") != 0 && password.compareTo("") != 0 && receiverSn.compareTo("SM00000000") != 0) {
+            if(intent != null ) {
+                String uuid = intent.getStringExtra("BgUuid");
+
+                Log.d(TAG, "UUID: " + uuid);
+                bg = BgReading.findByUuid(uuid);
+                if(uuid != null && !uuid.contentEquals("")) {
+                    if(sessionId != null && !sessionId.contentEquals("")) {
+                        Log.d(TAG, "New BG reading found and session exists");
+                        continueUpload();
+                    } else {
+                        Log.d(TAG, "New BG reading found but session does not exist");
+                        getValidSessionId();
+                    }
+                }
+            }
         } else {
-            return false;
+            stopSelf();
         }
+        return START_NOT_STICKY;
     }
-    public boolean sendBgData(BgReading bg) {
-        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mContext);
-        String receiverSn = preferences.getString("share_key", "SM00000000").toUpperCase();
-        if (prefs.getBoolean("share_upload", false) && login.compareTo("") != 0 && password.compareTo("") != 0 && receiverSn.compareTo("SM00000000") != 0) {
-            return loginAndSendData(bg);
+
+    public void getValidSessionId() {
+        if (sessionId != null && !sessionId.equalsIgnoreCase("")) {
+            try {
+                Log.d(TAG, "Session ID not null, checking if active");
+                emptyBodyInterface().checkSessionActive(querySessionMap(sessionId), new Callback() {
+                    @Override
+                    public void success(Object o, Response response) {
+                        Log.d(TAG, "Success!! got a response checking if session is active");
+                        if (response.getBody() != null) {
+                            if(new String(((TypedByteArray) response.getBody()).getBytes()).toLowerCase().contains("true")) {
+                                Log.d(TAG, "Session is active :-)");
+                                continueUpload();
+                            } else {
+                                Log.d(TAG, "Session is apparently not active :-(");
+                                Log.d(TAG, new String(((TypedByteArray) response.getBody()).getBytes()));
+                                StartRemoteMonitoringSession();
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void failure(RetrofitError retrofitError) {
+                        sessionId = null;
+                        Log.e("RETROFIT ERROR: ", "" + retrofitError.toString());
+                        getValidSessionId();
+                    }
+                });
+            } catch (Exception e) {
+                Log.e("REST CALL ERROR: ", "BOOOO");
+            }
         } else {
-            return false;
+            try {
+                Log.d(TAG, "Session ID is null, Getting a new one");
+                jsonBodyInterface().getSessionId(new ShareAuthenticationBody(password, login), new Callback() {
+                    @Override
+                    public void success(Object o, Response response) {
+                        Log.d(TAG, "Success!! got a response on auth.");
+                        Log.e("RETROFIT ERROR: ", "Auth succesfull");
+                        sessionId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
+                        sendUserAgentData();
+                    }
+
+                    @Override
+                    public void failure(RetrofitError retrofitError) {
+                        sessionId = null;
+                        Log.e("RETROFIT ERROR: ", "" + retrofitError.toString());
+                        Log.e("RETROFIT ERROR: ", "Unable to auth");
+                    }
+                });
+            } catch (Exception e) {
+                Log.e("REST CALL ERROR: ", "BOOOO");
+            }
         }
     }
 
-    private boolean loginAndGetData() {
+    public void sendUserAgentData() {
         try {
-            dexcomShareAuthorizeInterface().getSessionId(new ShareAuthenticationBody(password, login), new Callback() {
+            jsonBodyInterface().updatePublisherAccountInfo(new UserAgent(sessionId), new Callback() {
                 @Override
                 public void success(Object o, Response response) {
-                    Log.d("ShareRest", "Success!! got a response on auth.");
-                    String returnedSessionId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
-
-                    getBgData(returnedSessionId);
+                    Log.d(TAG, "User Agent Data Updated!!");
+                    checkAndSetRecieverAssignment();
                 }
 
                 @Override
                 public void failure(RetrofitError retrofitError) {
                     Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
+                    Log.e("RETROFIT ERROR: ", "Error updating user agent data");
+
                 }
             });
-            return true;
-        } catch (Exception e) {
+        }
+        catch (RetrofitError e) { Log.d("Retrofit Error: ", "BOOOO"); }
+        catch (Exception ex) { Log.d("Unrecognized Error: ", "BOOOO"); }
+    }
+
+    public void StartRemoteMonitoringSession() {
+        if (sessionId != null && !sessionId.equalsIgnoreCase("")) {
+            try {
+                jsonBodyInterface().authenticatePublisherAccount(new ShareAuthenticationBody(password, login), queryActivateSessionMap(), new Callback() {
+                    @Override
+                    public void success(Object o, Response response) {
+                        Log.d(TAG, "Success!! Authenticated Publisher account!!!");
+
+                        try {
+                            emptyBodyInterface().StartRemoteMonitoringSession(queryActivateSessionMap(), new Callback() {
+                                @Override
+                                public void success(Object o, Response response) {
+                                    Log.d(TAG, "Success!! Our remote monitoring session is up!");
+                                    if (response.getBody() != null) {
+                                        continueUpload();
+                                    }
+                                }
+
+                                @Override
+                                public void failure(RetrofitError retrofitError) {
+                                    sessionId = null;
+                                    Log.e("RETROFIT ERROR: ", "Unable to start a remote monitoring session");
+                                }
+                            });
+                        } catch (Exception e) {
+                            Log.e("REST CALL ERROR: ", "BOOOO");
+                        }
+                    }
+
+                    @Override
+                    public void failure(RetrofitError retrofitError) {
+                        sessionId = null;
+                        Log.e("RETROFIT ERROR: ", "Unable to authenticate publisher account");
+                    }
+                });
+            } catch (Exception e) {
                 Log.e("REST CALL ERROR: ", "BOOOO");
-                    return false;
+            }
+
+
         }
     }
 
-    private boolean loginAndSendData(final BgReading bg) {
-        try {
-            dexcomShareAuthorizeInterface().getSessionId(new ShareAuthenticationBody(password, login), new Callback() {
-                @Override
-                public void success(Object o, Response response) {
-                    Log.d("ShareRest", "Success!! got a response on auth.");
-                    String returnedSessionId = new String(((TypedByteArray) response.getBody()).getBytes()).replace("\"", "");
+    public void checkAndSetRecieverAssignment() {
+        emptyBodyInterface().checkMonitorAssignment(queryActivateSessionMap(), new Callback() {
+            @Override
+            public void success(Object o, Response response) {
+                Log.d(TAG, "Success!! Our remote monitoring session is up!");
+                if (response.getBody() != null) {
+                    if (!(new String(((TypedByteArray) response.getBody()).getBytes()).contains("AssignedToYou"))) {
+
+                        Log.e("Receiver trouble: ", "That receiver is not assigned to your account, trying to re-assign");
+                        emptyBodyInterface().updateMonitorAssignment(queryActivateSessionMap(), new Callback() {
+                            @Override
+                            public void success(Object o, Response response) {
+                                getValidSessionId();
+
+                            }
+                            @Override
+                            public void failure(RetrofitError retrofitError) {
+                                Log.e("RETROFIT ERROR: ", "Unable to set yourself as the publisher for that receiver");
+                            }
+                        });
+                    } else {
+                        getValidSessionId();
 
-                    sendBgData(returnedSessionId, bg);
+                    }
                 }
+            }
 
-                @Override
-                public void failure(RetrofitError retrofitError) {
-                    Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
-                }
-            });
-            return true;
-        } catch (Exception e) {
-            Log.e("REST CALL ERROR: ", "BOOOO");
-            return false;
-        }
+            @Override
+            public void failure(RetrofitError retrofitError) {
+                sessionId = null;
+                Log.e("RETROFIT ERROR: ", "Unable to check receiver ownership");
+            }
+        });
     }
 
-    private void getBgData(String sessionId) {
-        DataFetcher dataFetcher = new DataFetcher(mContext, sessionId);
-        dataFetcher.execute((Void) null);
+    public void continueUpload() {
+        if(bg != null) {
+            sendBgData(sessionId, bg);
+        } else {
+            Log.d(TAG, "No BG, cannot continue");
+        }
     }
 
     private void sendBgData(String sessionId, BgReading bg) {
@@ -128,28 +268,14 @@ private void sendBgData(String sessionId, BgReading bg) {
         dataSender.execute((Void) null);
     }
 
-    private DexcomShareInterface dexcomShareAuthorizeInterface() {
+    public DexcomShareInterface jsonBodyInterface() {
         RestAdapter adapter = authoirizeAdapterBuilder().build();
         DexcomShareInterface dexcomShareInterface =
                 adapter.create(DexcomShareInterface.class);
         return dexcomShareInterface;
     }
 
-    private DexcomShareInterface dexcomShareGetBgInterface() {
-        RestAdapter adapter = getBgAdapterBuilder().build();
-        DexcomShareInterface dexcomShareInterface =
-                adapter.create(DexcomShareInterface.class);
-        return dexcomShareInterface;
-    }
-
-    private DexcomShareInterface dexcomShareSendBgInterface() {
-        RestAdapter adapter = authoirizeAdapterBuilder().build();
-        DexcomShareInterface dexcomShareInterface =
-                adapter.create(DexcomShareInterface.class);
-        return dexcomShareInterface;
-    }
-
-    private DexcomShareInterface checkSessionActive() {
+    public DexcomShareInterface emptyBodyInterface() {
         RestAdapter adapter = getBgAdapterBuilder().build();
         DexcomShareInterface checkSessionActive =
                 adapter.create(DexcomShareInterface.class);
@@ -160,7 +286,7 @@ private DexcomShareInterface checkSessionActive() {
         RestAdapter.Builder adapterBuilder = new RestAdapter.Builder();
         adapterBuilder
                 .setClient(client)
-                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("SHAREREST"))
+                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog(TAG))
                 .setEndpoint("https://share1.dexcom.com/ShareWebServices/Services")
                 .setRequestInterceptor(authorizationRequestInterceptor)
                 .setConverter(new GsonConverter(new GsonBuilder()
@@ -173,7 +299,7 @@ private DexcomShareInterface checkSessionActive() {
         RestAdapter.Builder adapterBuilder = new RestAdapter.Builder();
         adapterBuilder
                 .setClient(client)
-                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("SHAREREST"))
+                .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog(TAG))
                 .setEndpoint("https://share1.dexcom.com/ShareWebServices/Services")
                 .setRequestInterceptor(getBgRequestInterceptor)
                 .setConverter(new GsonConverter(new GsonBuilder()
@@ -182,7 +308,7 @@ private DexcomShareInterface checkSessionActive() {
         return adapterBuilder;
     }
 
-    RequestInterceptor authorizationRequestInterceptor = new RequestInterceptor() {
+    static RequestInterceptor authorizationRequestInterceptor = new RequestInterceptor() {
         @Override
         public void intercept(RequestInterceptor.RequestFacade request) {
             request.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
@@ -201,7 +327,6 @@ public void intercept(RequestInterceptor.RequestFacade request) {
     };
 
     public OkHttpClient getOkHttpClient() {
-
         try {
             final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                 @Override
@@ -240,7 +365,6 @@ public boolean verify(String hostname, SSLSession session) {
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
-
     }
 
     public OkClient getOkClient (){
@@ -249,47 +373,6 @@ public OkClient getOkClient (){
         return _client;
     }
 
-    public Map<String, String> queryParamMap(String sessionId) {
-        Map map = new HashMap<String, String>();
-        map.put("sessionID", sessionId);
-        map.put("minutes", String.valueOf(minutesCount()));
-        map.put("maxCount", String.valueOf(requestCount()));
-        return map;
-
-    }
-
-    public class DataFetcher extends AsyncTask<Void, Void, Boolean> {
-        Context mContext;
-        String mSessionId;
-        DataFetcher(Context context, String sessionId) {
-            mContext = context;
-            mSessionId = sessionId;
-        }
-
-        @Override
-        protected Boolean doInBackground(Void... params) {
-            try {
-                try {
-                    final ShareGlucose[] shareGlucoses = dexcomShareGetBgInterface().getShareBg(queryParamMap(mSessionId));
-                    Log.d("REST Success: ", "YAY!");
-                    if(shareGlucoses != null && shareGlucoses.length > 0) {
-                        for (ShareGlucose shareGlucose : shareGlucoses) {
-                            shareGlucose.processShareData(mContext);
-                        }
-                    return true;
-                    }
-                    return false;
-                } catch (Exception e) {
-                    Log.d("REST CALL ERROR: ", "BOOOO");
-                    return false;
-                }
-            }
-            catch (RetrofitError e) { Log.d("Retrofit Error: ", "BOOOO"); }
-            catch (Exception ex) { Log.d("Unrecognized Error: ", "BOOOO"); }
-            return false;
-        }
-    }
-
     public class DataSender extends AsyncTask<Void, Void, Boolean> {
         Context mContext;
         String mSessionId;
@@ -305,15 +388,24 @@ protected Boolean doInBackground(Void... params) {
             try {
                 SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mContext);
                 String receiverSn = preferences.getString("share_key", "SM00000000").toUpperCase();
-                dexcomShareSendBgInterface().uploadBGRecords(querySessionMap(mSessionId), new ShareUploadPayload(receiverSn, mBg), new Callback() {
+                jsonBodyInterface().uploadBGRecords(querySessionMap(mSessionId), new ShareUploadPayload(receiverSn, mBg), new Callback() {
                     @Override
                     public void success(Object o, Response response) {
-                        Log.d("ShareRest", "Success!! Uploaded!!");
+                        Log.d(TAG, "Success!! Uploaded!!");
+                        bg = null;
                     }
 
                     @Override
                     public void failure(RetrofitError retrofitError) {
                         Log.e("RETROFIT ERROR: ", ""+retrofitError.toString());
+                        if((retrofitError.toString().contains("EvgPost is only allowed when monitoring session is active") && retrying == false) ||
+                                (retrofitError.toString().contains("SessionNotValid")  && retrying == false)) {
+                            sessionId = null;
+                            retrying = true;
+                            getValidSessionId();
+                        } else {
+                            bg = null;
+                        }
                     }
                 });
             }
@@ -322,30 +414,17 @@ public void failure(RetrofitError retrofitError) {
             return false;
         }
     }
-    public int requestCount() {
-        BgReading bg = BgReading.last();
-        if(bg != null) {
-            return 20;
-        } else if (bg.timestamp < new Date().getTime()) {
-            return Math.min((int) Math.ceil(((new Date().getTime() - bg.timestamp) / (5 * 1000 * 60))), 10);
-        } else {
-            return 1;
-        }
-    }
-
-    public int minutesCount() {
-        BgReading bg = BgReading.last();
-        if(bg != null && bg.timestamp < new Date().getTime()) {
-            return Math.min((int) Math.ceil(((new Date().getTime() - bg.timestamp) / (1000 * 60))), 1440);
-        } else {
-            return 1440;
-        }
-    }
 
     public Map<String, String> querySessionMap(String sessionId) {
         Map map = new HashMap<String, String>();
         map.put("sessionID", sessionId);
         return map;
+    }
 
+    public Map<String, String> queryActivateSessionMap() {
+        Map map = new HashMap<String, String>();
+        map.put("sessionID", sessionId);
+        map.put("serialNumber", receiverSn);
+        return map;
     }
 }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/RuntimeInfo.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/RuntimeInfo.java
new file mode 100644
index 0000000..441b977
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/RuntimeInfo.java
@@ -0,0 +1,30 @@
+package com.eveningoutpost.dexdrip.ShareModels.UserAgentInfo;
+
+import com.google.gson.annotations.Expose;
+
+/**
+ * Created by stephenblack on 6/29/15.
+ */
+public class RuntimeInfo {
+
+    @Expose
+    public String DeviceManufacturer = "Apple";
+
+    @Expose
+    public String DeviceModel = "iPhone5,2";
+
+    @Expose
+    public String DeviceOsVersion = "7.0.2";
+
+    @Expose
+    public String AppVersion = "3.0.2.11";
+
+    @Expose
+    public String AppName = "DexcomShare";
+
+    @Expose
+    public String AppNumber = "SW10569";
+
+    @Expose
+    public String DeviceOsName ="iPhone OS";
+ }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/UserAgent.java b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/UserAgent.java
new file mode 100644
index 0000000..1e45d89
--- /dev/null
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/ShareModels/UserAgentInfo/UserAgent.java
@@ -0,0 +1,20 @@
+package com.eveningoutpost.dexdrip.ShareModels.UserAgentInfo;
+
+import com.eveningoutpost.dexdrip.ShareModels.UserAgentInfo.RuntimeInfo;
+import com.google.gson.annotations.Expose;
+
+/**
+ * Created by stephenblack on 6/29/15.
+ */
+public class UserAgent {
+    @Expose
+    public String sessionId;
+
+    @Expose
+    public RuntimeInfo runtimeInfo;
+
+    public UserAgent(String aSessionId) {
+        this.runtimeInfo = new RuntimeInfo();
+        this.sessionId = aSessionId;
+    }
+}
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
index 0bbd8f9..40be699 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/BgSendQueue.java
@@ -71,11 +71,10 @@ public static BgSendQueue nextBgJob() {
     }
 
     public static void addToQueue(BgReading bgReading, String operation_type, Context context) {
-        PowerManager powerManager = (PowerManager) context.getSystemService(context.POWER_SERVICE);
+        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
         PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                 "sendQueue");
         wakeLock.acquire();
-
         try {
             BgSendQueue bgSendQueue = new BgSendQueue();
             bgSendQueue.operation_type = operation_type;
@@ -126,9 +125,10 @@ public static void addToQueue(BgReading bgReading, String operation_type, Contex
             }
 
             if (prefs.getBoolean("share_upload", false)) {
-                ShareRest shareRest = new ShareRest(context);
                 Log.w("ShareRest", "About to call ShareRest!!");
-                shareRest.sendBgData(bgReading);
+                Intent shareIntent = new Intent(context, ShareRest.class);
+                shareIntent.putExtra("BgUuid", bgReading.uuid);
+                context.startService(shareIntent);
             }
             context.startService(new Intent(context, SyncService.class));
         } finally {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
index f04463b..0b2490c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/NightscoutUploader.java
@@ -279,7 +279,7 @@ private void populateV1APIBGEntry(JSONObject json, BgReading record) throws Exce
             json.put("filtered", record.filtered_data * 1000);
             json.put("unfiltered", record.usedRaw() * 1000);
             json.put("rssi", 100);
-            json.put("noise", Integer.valueOf(record.noiseValue()));
+            json.put("noise", record.noiseValue());
         }
 
         private void populateLegacyAPIEntry(JSONObject json, BgReading record) throws Exception {
@@ -365,68 +365,75 @@ private boolean doMongoUpload(SharedPreferences prefs, List<BgReading> glucoseDa
 
                     // get collection
                     DBCollection dexcomData = db.getCollection(collectionName.trim());
-                    Log.i(TAG, "The number of EGV records being sent to MongoDB is " + glucoseDataSets.size());
-                    for (BgReading record : glucoseDataSets) {
-                        // make db object
-                        BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
-                        testData.put("date", record.timestamp);
-                        testData.put("dateString", format.format(record.timestamp));
-                        testData.put("sgv", Math.round(record.calculated_value));
-                        testData.put("direction", record.slopeName());
-                        testData.put("type", "sgv");
-                        testData.put("filtered", record.filtered_data * 1000);
-                        testData.put("unfiltered", record.usedRaw() * 1000 );
-                        testData.put("rssi", 100);
-                        testData.put("noise", Integer.valueOf(record.noiseValue()));
-                        dexcomData.update(testData, testData, true, false, WriteConcern.UNACKNOWLEDGED);
-                    }
 
-                    Log.i(TAG, "The number of MBG records being sent to MongoDB is " + meterRecords.size());
-                    for (Calibration meterRecord : meterRecords) {
-                        // make db object
-                        BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
-                        testData.put("type", "mbg");
-                        testData.put("date", meterRecord.timestamp);
-                        testData.put("dateString", format.format(meterRecord.timestamp));
-                        testData.put("mbg", meterRecord.bg);
-                        dexcomData.update(testData, testData, true, false, WriteConcern.UNACKNOWLEDGED);
-                    }
+                    try {
+                        Log.i(TAG, "The number of EGV records being sent to MongoDB is " + glucoseDataSets.size());
+                        for (BgReading record : glucoseDataSets) {
+                            // make db object
+                            BasicDBObject testData = new BasicDBObject();
+                            testData.put("device", "xDrip-" + prefs.getString("dex_collection_method", "BluetoothWixel"));
+                            testData.put("date", record.timestamp);
+                            testData.put("dateString", format.format(record.timestamp));
+                            testData.put("sgv", Math.round(record.calculated_value));
+                            testData.put("direction", record.slopeName());
+                            testData.put("type", "sgv");
+                            testData.put("filtered", record.filtered_data * 1000);
+                            testData.put("unfiltered", record.usedRaw() * 1000);
+                            testData.put("rssi", 100);
+                            testData.put("noise", record.noiseValue());
+                            dexcomData.insert(testData, WriteConcern.UNACKNOWLEDGED);
+                        }
 
-                    for (Calibration calRecord : calRecords) {
-                        // make db object
-                        BasicDBObject testData = new BasicDBObject();
-                        testData.put("device", "xDrip-"+prefs.getString("dex_collection_method", "BluetoothWixel"));
-                        testData.put("date", calRecord.timestamp);
-                        testData.put("dateString", format.format(calRecord.timestamp));
-                        if(calRecord.check_in) {
-                            testData.put("slope", (long) (calRecord.first_slope));
-                            testData.put("intercept", (long) ((calRecord.first_intercept)));
-                            testData.put("scale", calRecord.first_scale);
-                        } else {
-                            testData.put("slope", (long) (calRecord.slope * 1000));
-                            testData.put("intercept", (long) ((calRecord.intercept * -1000) / (calRecord.slope * 1000)));
-                            testData.put("scale", 1);
+                        Log.i(TAG, "The number of MBG records being sent to MongoDB is " + meterRecords.size());
+                        for (Calibration meterRecord : meterRecords) {
+                            // make db object
+                            BasicDBObject testData = new BasicDBObject();
+                            testData.put("device", "xDrip-" + prefs.getString("dex_collection_method", "BluetoothWixel"));
+                            testData.put("type", "mbg");
+                            testData.put("date", meterRecord.timestamp);
+                            testData.put("dateString", format.format(meterRecord.timestamp));
+                            testData.put("mbg", meterRecord.bg);
+                            dexcomData.insert(testData, WriteConcern.UNACKNOWLEDGED);
+                        }
+
+                        for (Calibration calRecord : calRecords) {
+                            // make db object
+                            BasicDBObject testData = new BasicDBObject();
+                            testData.put("device", "xDrip-" + prefs.getString("dex_collection_method", "BluetoothWixel"));
+                            testData.put("date", calRecord.timestamp);
+                            testData.put("dateString", format.format(calRecord.timestamp));
+                            if (calRecord.check_in) {
+                                testData.put("slope", (long) (calRecord.first_slope));
+                                testData.put("intercept", (long) ((calRecord.first_intercept)));
+                                testData.put("scale", calRecord.first_scale);
+                            } else {
+                                testData.put("slope", (long) (calRecord.slope * 1000));
+                                testData.put("intercept", (long) ((calRecord.intercept * -1000) / (calRecord.slope * 1000)));
+                                testData.put("scale", 1);
+                            }
+                            testData.put("type", "cal");
+                            dexcomData.insert(testData, WriteConcern.UNACKNOWLEDGED);
                         }
-                        testData.put("type", "cal");
-                        dexcomData.update(testData, testData, true, false, WriteConcern.UNACKNOWLEDGED);
-                    }
 
-                    // TODO: quick port from original code, revisit before release
-                    DBCollection dsCollection = db.getCollection(dsCollectionName);
-                    BasicDBObject devicestatus = new BasicDBObject();
-                    devicestatus.put("uploaderBattery", getBatteryLevel());
-                    devicestatus.put("created_at", new Date());
-                    dsCollection.insert(devicestatus, WriteConcern.UNACKNOWLEDGED);
+                        // TODO: quick port from original code, revisit before release
+                        DBCollection dsCollection = db.getCollection(dsCollectionName);
+                        BasicDBObject devicestatus = new BasicDBObject();
+                        devicestatus.put("uploaderBattery", getBatteryLevel());
+                        devicestatus.put("created_at", new Date());
+                        dsCollection.insert(devicestatus, WriteConcern.UNACKNOWLEDGED);
 
-                    client.close();
+                        client.close();
 
-                    return true;
+                        return true;
 
+                    } catch (Exception e) {
+                        Log.e(TAG, "Unable to upload data to mongo " + e.getMessage());
+                        Log.e(TAG, "Unable to upload data to mongo", e.getCause());
+                    } finally {
+                        if(client != null) { client.close(); }
+                    }
                 } catch (Exception e) {
                     Log.e(TAG, "Unable to upload data to mongo " + e.getMessage());
-                    Log.e(TAG, "Unable to upload data to mongo", e.getCause());
                 }
             }
             return false;
diff --git a/app/src/main/res/xml/pref_data_sync.xml b/app/src/main/res/xml/pref_data_sync.xml
index c3cf485..83d38b7 100644
--- a/app/src/main/res/xml/pref_data_sync.xml
+++ b/app/src/main/res/xml/pref_data_sync.xml
@@ -90,6 +90,12 @@
                 android:inputType="textPassword"
                 android:summary="Your password for Dexcom's Website"
                 android:defaultValue=""/>
+            <EditTextPreference
+                android:dependency="share_upload"
+                android:title="10 Character Dexcom Receiver Serial Number"
+                android:key="share_key"
+                android:shouldDisableView="true"
+                android:defaultValue="SM00000000"/>
         </PreferenceScreen>
 
     </PreferenceCategory>

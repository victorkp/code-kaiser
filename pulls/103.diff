diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
index 60eeb07..8bc4545 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Home.java
@@ -1,9 +1,5 @@
 package com.eveningoutpost.dexdrip;
 
-import android.app.Activity;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -15,7 +11,6 @@
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
-import android.support.v4.app.NotificationCompat;
 import android.support.v4.widget.DrawerLayout;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -23,18 +18,14 @@
 import android.widget.TextView;
 import android.widget.Toast;
 
-import com.eveningoutpost.dexdrip.UtilityModels.Constants;
 import com.eveningoutpost.dexdrip.Models.ActiveBluetoothDevice;
-import com.eveningoutpost.dexdrip.Models.AlertType;
 import com.eveningoutpost.dexdrip.Models.BgReading;
 import com.eveningoutpost.dexdrip.Models.Calibration;
-import com.eveningoutpost.dexdrip.Services.DexCollectionService;
 import com.eveningoutpost.dexdrip.Services.WixelReader;
 import com.eveningoutpost.dexdrip.UtilityModels.BgGraphBuilder;
 import com.eveningoutpost.dexdrip.UtilityModels.CollectionServiceStarter;
 import com.eveningoutpost.dexdrip.UtilityModels.IdempotentMigrations;
 import com.eveningoutpost.dexdrip.UtilityModels.Intents;
-import com.eveningoutpost.dexdrip.UtilityModels.Notifications;
 import com.eveningoutpost.dexdrip.utils.ActivityWithMenu;
 import com.eveningoutpost.dexdrip.utils.DatabaseUtil;
 
@@ -57,26 +48,25 @@
 
 public class Home extends ActivityWithMenu {
     public static String menu_name = "xDrip";
-    public float left;
-    public float right;
-    public float top;
-    public float bottom;
-    public boolean updateStuff;
-    public boolean updatingPreviewViewport = false;
-    public boolean updatingChartViewport = false;
-    public BgGraphBuilder bgGraphBuilder;
-    SharedPreferences prefs;
-    Viewport tempViewport = new Viewport();
-    Viewport holdViewport = new Viewport();
-    boolean isBTWixel;
-    boolean isDexbridgeWixel;
-    boolean isBTShare;
-    boolean isWifiWixel;
-    BroadcastReceiver _broadcastReceiver;
-    BroadcastReceiver newDataReceiver;
+    private boolean updateStuff;
+    private boolean updatingPreviewViewport = false;
+    private boolean updatingChartViewport = false;
+    private BgGraphBuilder bgGraphBuilder;
+    private SharedPreferences prefs;
+    private Viewport tempViewport = new Viewport();
+    private Viewport holdViewport = new Viewport();
+    private boolean isBTWixel;
+    private boolean isDexbridgeWixel;
+    private boolean isBTShare;
+    private boolean isWifiWixel;
+    private BroadcastReceiver _broadcastReceiver;
+    private BroadcastReceiver newDataReceiver;
     private NavigationDrawerFragment mNavigationDrawerFragment;
-    private LineChartView chart;
-    private PreviewLineChartView previewChart;
+    private LineChartView            chart;
+    private PreviewLineChartView     previewChart;
+    private TextView                 dexbridgeBattery;
+    private TextView                 currentBgValueText;
+    private TextView                 notificationText;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -91,6 +81,10 @@ protected void onCreate(Bundle savedInstanceState) {
         checkEula();
         new IdempotentMigrations(getApplicationContext()).performAll();
         setContentView(R.layout.activity_home);
+
+        this.dexbridgeBattery = (TextView) findViewById(R.id.textBridgeBattery);
+        this.currentBgValueText = (TextView) findViewById(R.id.currentBgValueRealTime);
+        this.notificationText = (TextView) findViewById(R.id.notices);
     }
 
     @Override
@@ -182,91 +176,13 @@ public void updateCurrentBgInfo() {
         isBTShare = CollectionServiceStarter.isBTShare(getApplicationContext());
         isWifiWixel = CollectionServiceStarter.isWifiWixel(getApplicationContext());
         if (isBTShare) {
-            if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
-                notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
-            } else {
-                String receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
-                if (receiverSn.compareTo("SM00000000") == 0 || receiverSn.length() == 0) {
-                    notificationText.setText("Please set your Dex Receiver Serial Number in App Settings");
-                } else {
-                    if (receiverSn.length() < 10) {
-                        notificationText.setText("Double Check Dex Receiver Serial Number, should be 10 characters, don't forget the letters");
-                    } else {
-                        if (ActiveBluetoothDevice.first() == null) {
-                            notificationText.setText("Now pair with your Dexcom Share");
-                        } else {
-                            if (!Sensor.isActive()) {
-                                notificationText.setText("Now choose start your sensor in your settings");
-                            } else {
-                                displayCurrentInfo();
-                            }
-                        }
-                    }
-                }
-            }
+            updateCurrentBgInfoForBtShare(notificationText);
         }
         if (isBTWixel || isDexbridgeWixel) {
-            if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
-                notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
-            } else {
-                if (ActiveBluetoothDevice.first() == null) {
-                    notificationText.setText("First pair with your BT device!");
-                } else {
-                    if (Sensor.isActive() && (Sensor.currentSensor().started_at + (60000 * 60 * 2)) < new Date().getTime()) {
-                        if (BgReading.latest(2).size() > 1) {
-                            List<Calibration> calibrations = Calibration.latest(2);
-                            if (calibrations.size() > 1) {
-                                if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
-                                    notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
-                                }
-                                displayCurrentInfo();
-                            } else {
-                                notificationText.setText("Please enter two calibrations to get started!");
-                            }
-                        } else {
-                            if (BgReading.latestUnCalculated(2).size() < 2) {
-                                notificationText.setText("Please wait, need 2 readings from transmitter first.");
-                            } else {
-                                List<Calibration> calibrations = Calibration.latest(2);
-                                if (calibrations.size() < 2) {
-                                    notificationText.setText("Please enter two calibrations to get started!");
-                                }
-                            }
-                        }
-                    } else if (Sensor.isActive() && ((Sensor.currentSensor().started_at + (60000 * 60 * 2))) >= new Date().getTime()) {
-                        double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - (new Date().getTime())) / (60000);
-                        notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
-                    } else {
-                        notificationText.setText("Now start your sensor");
-                    }
-                }
-            }
+            updateCurrentBgInfoForBtBasedWixel(notificationText);
         }
         if (isWifiWixel) {
-            if (!WixelReader.IsConfigured(getApplicationContext())) {
-                notificationText.setText("First configure your wifi wixel reader ip addresses");
-            } else {
-                if (Sensor.isActive() && (Sensor.currentSensor().started_at + (60000 * 60 * 2)) < new Date().getTime()) {
-                    if (BgReading.latest(2).size() > 1) {
-                        List<Calibration> calibrations = Calibration.latest(2);
-                        if (calibrations.size() > 1) {
-                            if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
-                                notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
-                            }
-                            displayCurrentInfo();
-                        } else {
-                            notificationText.setText("Please enter two calibrations to get started!");
-                        }
-                    } else {
-                        notificationText.setText("Please wait, need 2 readings from transmitter first.");
-                    }
-                } else if (Sensor.isActive() && ((Sensor.currentSensor().started_at + (60000 * 60 * 2))) >= new Date().getTime()) {
-                    double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - (new Date().getTime())) / (60000);
-                    notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
-                } else {
-                    notificationText.setText("Now start your sensor");
-                }
-            }
+            updateCurrentBgInfoForWifiWixel(notificationText);
         }
         if (prefs.getLong("alerts_disabled_until", 0) > new Date().getTime()) {
             notificationText.append("\n ALERTS CURRENTLY DISABLED");
@@ -275,6 +191,119 @@ public void updateCurrentBgInfo() {
         mNavigationDrawerFragment.setUp(R.id.navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), menu_name, this);
     }
 
+    private void updateCurrentBgInfoForWifiWixel(TextView notificationText) {
+        if (!WixelReader.IsConfigured(getApplicationContext())) {
+            notificationText.setText("First configure your wifi wixel reader ip addresses");
+            return;
+        }
+
+        final boolean sensorIsActive = Sensor.isActive();
+        if(!sensorIsActive) {
+            notificationText.setText("Now start your sensor");
+            return;
+        }
+
+        final long now = System.currentTimeMillis();
+        if (Sensor.currentSensor().started_at + 60000 * 60 * 2 >= now) {
+            double waitTime = ((Sensor.currentSensor().started_at + (60000 * 60 * 2)) - now) / (60000);
+            notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
+            return;
+        }
+
+        if (BgReading.latest(2).size() < 2) {
+            notificationText.setText("Please wait, need 2 readings from transmitter first.");
+            return;
+        }
+
+        List<Calibration> calibrations = Calibration.latest(2);
+        if(calibrations.size() < 2) {
+            notificationText.setText("Please enter two calibrations to get started!");
+            return;
+        }
+
+        if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
+            notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
+        }
+        displayCurrentInfo();
+
+    }
+
+    private void updateCurrentBgInfoForBtBasedWixel(TextView notificationText) {
+        if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
+            notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
+            return;
+        }
+
+        if (ActiveBluetoothDevice.first() == null) {
+            notificationText.setText("First pair with your BT device!");
+            return;
+        }
+
+        final boolean isSensorActive = Sensor.isActive();
+        if(!isSensorActive){
+            notificationText.setText("Now start your sensor");
+            return;
+        }
+
+        final long now = System.currentTimeMillis();
+        if (Sensor.currentSensor().started_at + 60000 * 60 * 2 >= now) {
+            double waitTime = (Sensor.currentSensor().started_at + 60000 * 60 * 2 - now) / 60000.0;
+            notificationText.setText("Please wait while sensor warms up! (" + String.format("%.2f", waitTime) + " minutes)");
+            return;
+        }
+
+        if (BgReading.latest(2).size() > 1) {
+            List<Calibration> calibrations = Calibration.latest(2);
+            if (calibrations.size() > 1) {
+                if (calibrations.get(0).possible_bad != null && calibrations.get(0).possible_bad == true && calibrations.get(1).possible_bad != null && calibrations.get(1).possible_bad != true) {
+                    notificationText.setText("Possible bad calibration slope, please have a glass of water, wash hands, then recalibrate in a few!");
+                }
+                displayCurrentInfo();
+            } else {
+                notificationText.setText("Please enter two calibrations to get started!");
+            }
+        } else {
+            if (BgReading.latestUnCalculated(2).size() < 2) {
+                notificationText.setText("Please wait, need 2 readings from transmitter first.");
+            } else {
+                List<Calibration> calibrations = Calibration.latest(2);
+                if (calibrations.size() < 2) {
+                    notificationText.setText("Please enter two calibrations to get started!");
+                }
+            }
+        }
+    }
+
+    private void updateCurrentBgInfoForBtShare(TextView notificationText) {
+        if ((android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2)) {
+            notificationText.setText("Unfortunately your android version does not support Bluetooth Low Energy");
+            return;
+        }
+
+        String receiverSn = prefs.getString("share_key", "SM00000000").toUpperCase();
+        if (receiverSn.compareTo("SM00000000") == 0 || receiverSn.length() == 0) {
+            notificationText.setText("Please set your Dex Receiver Serial Number in App Settings");
+            return;
+        }
+
+        if (receiverSn.length() < 10) {
+            notificationText.setText("Double Check Dex Receiver Serial Number, should be 10 characters, don't forget the letters");
+            return;
+        }
+
+        if (ActiveBluetoothDevice.first() == null) {
+            notificationText.setText("Now pair with your Dexcom Share");
+            return;
+        }
+
+        if (!Sensor.isActive()) {
+            notificationText.setText("Now choose start your sensor in your settings");
+            return;
+        }
+
+        displayCurrentInfo();
+    }
+
     public void displayCurrentInfo() {
         DecimalFormat df = new DecimalFormat("#");
         df.setMaximumFractionDigits(0);
@@ -282,7 +311,6 @@ public void displayCurrentInfo() {
         boolean isDexbridge = CollectionServiceStarter.isDexbridgeWixel(getApplicationContext());
         int bridgeBattery = prefs.getInt("bridge_battery", 0);
 
-        final TextView dexbridgeBattery = (TextView) findViewById(R.id.textBridgeBattery);
         if (isDexbridge) {
             if (bridgeBattery == 0) {
                 dexbridgeBattery.setText("Waiting for packet");
@@ -296,64 +324,67 @@ public void displayCurrentInfo() {
         } else {
             dexbridgeBattery.setVisibility(View.INVISIBLE);
         }
-        final TextView currentBgValueText = (TextView) findViewById(R.id.currentBgValueRealTime);
-        final TextView notificationText = (TextView) findViewById(R.id.notices);
+
         if ((currentBgValueText.getPaintFlags() & Paint.STRIKE_THRU_TEXT_FLAG) > 0) {
             currentBgValueText.setPaintFlags(currentBgValueText.getPaintFlags() & (~Paint.STRIKE_THRU_TEXT_FLAG));
             dexbridgeBattery.setPaintFlags(dexbridgeBattery.getPaintFlags() & (~Paint.STRIKE_THRU_TEXT_FLAG));
         }
-        BgReading lastBgreading = BgReading.lastNoSenssor();
+        BgReading lastBgReading = BgReading.lastNoSenssor();
         boolean predictive = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getBoolean("predictive_bg", false);
         if (isBTShare) {
             predictive = false;
         }
-        if (lastBgreading != null) {
-            double estimate = 0;
-            if ((new Date().getTime()) - (60000 * 11) - lastBgreading.timestamp > 0) {
-                notificationText.setText("Signal Missed");
-                if (!predictive) {
-                    estimate = lastBgreading.calculated_value;
-                } else {
-                    estimate = BgReading.estimated_bg(lastBgreading.timestamp + (6000 * 7));
-                }
-                currentBgValueText.setText(bgGraphBuilder.unitized_string(estimate));
-                currentBgValueText.setPaintFlags(currentBgValueText.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
-                dexbridgeBattery.setPaintFlags(dexbridgeBattery.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
+        if (lastBgReading != null) {
+            displayCurrentInfoFromReading(lastBgReading, predictive);
+        }
+        setupCharts();
+    }
+
+    private void displayCurrentInfoFromReading(BgReading lastBgReading, boolean predictive) {
+        double estimate = 0;
+        if ((new Date().getTime()) - (60000 * 11) - lastBgReading.timestamp > 0) {
+            notificationText.setText("Signal Missed");
+            if (!predictive) {
+                estimate = lastBgReading.calculated_value;
             } else {
-                if (notificationText.getText().length()==0){
-                    notificationText.setTextColor(Color.WHITE);
-                }
-                if (!predictive) {
-                    estimate = lastBgreading.calculated_value;
-                    String stringEstimate = bgGraphBuilder.unitized_string(estimate);
-                    String slope_arrow = BgReading.slopeArrow((lastBgreading.calculated_value_slope * 60000));
-                    if (lastBgreading.hide_slope) {
-                        slope_arrow = "";
-                    }
-                    currentBgValueText.setText(stringEstimate + " " + slope_arrow);
-                } else {
-                    estimate = BgReading.activePrediction();
-                    String stringEstimate = bgGraphBuilder.unitized_string(estimate);
-                    currentBgValueText.setText(stringEstimate + " " + BgReading.slopeArrow());
-                }
+                estimate = BgReading.estimated_bg(lastBgReading.timestamp + (6000 * 7));
             }
-            int minutes = (int)(System.currentTimeMillis() - lastBgreading.timestamp) / (60 * 1000);
-            notificationText.append("\n" + minutes + ((minutes==1)?" Minute ago":" Minutes ago"));
-            List<BgReading> bgReadingList = BgReading.latest(2);
-            if(bgReadingList != null && bgReadingList.size() == 2) {
-                // same logic as in xDripWidget (refactor that to BGReadings to avoid redundancy / later inconsistencies)?
-                notificationText.append("\n"
-                        + bgGraphBuilder.unitizedDeltaString(lastBgreading.calculated_value - bgReadingList.get(1).calculated_value));
+            currentBgValueText.setText(bgGraphBuilder.unitized_string(estimate));
+            currentBgValueText.setPaintFlags(currentBgValueText.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
+            dexbridgeBattery.setPaintFlags(dexbridgeBattery.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
+        } else {
+            if (notificationText.getText().length()==0){
+                notificationText.setTextColor(Color.WHITE);
             }
-            if(bgGraphBuilder.unitized(estimate) <= bgGraphBuilder.lowMark) {
-                currentBgValueText.setTextColor(Color.parseColor("#C30909"));
-            } else if (bgGraphBuilder.unitized(estimate) >= bgGraphBuilder.highMark) {
-                currentBgValueText.setTextColor(Color.parseColor("#FFBB33"));
+            if (!predictive) {
+                estimate = lastBgReading.calculated_value;
+                String stringEstimate = bgGraphBuilder.unitized_string(estimate);
+                String slope_arrow = BgReading.slopeArrow((lastBgReading.calculated_value_slope * 60000));
+                if (lastBgReading.hide_slope) {
+                    slope_arrow = "";
+                }
+                currentBgValueText.setText(stringEstimate + " " + slope_arrow);
             } else {
-                currentBgValueText.setTextColor(Color.WHITE);
+                estimate = BgReading.activePrediction();
+                String stringEstimate = bgGraphBuilder.unitized_string(estimate);
+                currentBgValueText.setText(stringEstimate + " " + BgReading.slopeArrow());
             }
         }
-        setupCharts();
+        int minutes = (int)(System.currentTimeMillis() - lastBgReading.timestamp) / (60 * 1000);
+        notificationText.append("\n" + minutes + ((minutes==1)?" Minute ago":" Minutes ago"));
+        List<BgReading> bgReadingList = BgReading.latest(2);
+        if(bgReadingList != null && bgReadingList.size() == 2) {
+            // same logic as in xDripWidget (refactor that to BGReadings to avoid redundancy / later inconsistencies)?
+            notificationText.append("\n"
+                    + bgGraphBuilder.unitizedDeltaString(lastBgReading.calculated_value - bgReadingList.get(1).calculated_value));
+        }
+        if(bgGraphBuilder.unitized(estimate) <= bgGraphBuilder.lowMark) {
+            currentBgValueText.setTextColor(Color.parseColor("#C30909"));
+        } else if (bgGraphBuilder.unitized(estimate) >= bgGraphBuilder.highMark) {
+            currentBgValueText.setTextColor(Color.parseColor("#FFBB33"));
+        } else {
+            currentBgValueText.setTextColor(Color.WHITE);
+        }
     }
 
     @Override
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 326f0c3..cb68715 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -275,68 +275,73 @@ public static boolean is_new(SensorRecord sensorRecord, long addativeOffset) {
     public static BgReading create(double raw_data, double filtered_data, Context context, Long timestamp) {
         BgReading bgReading = new BgReading();
         Sensor sensor = Sensor.currentSensor();
-        if (sensor != null) {
-            Calibration calibration = Calibration.last();
-            if (calibration == null) {
-                Log.d(TAG,"create: No calibration yet");
-                bgReading.sensor = sensor;
-                bgReading.sensor_uuid = sensor.uuid;
-                bgReading.raw_data = (raw_data / 1000);
-                bgReading.filtered_data = (filtered_data / 1000);
-                bgReading.timestamp = timestamp;
-                bgReading.uuid = UUID.randomUUID().toString();
-                bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
-                bgReading.synced = false;
-                bgReading.calibration_flag = false;
-
-                bgReading.calculateAgeAdjustedRawValue();
+        if (sensor == null) {
+            Log.w("BG GSON: ",bgReading.toS());
 
-                bgReading.save();
-                bgReading.perform_calculations();
-            } else {
-                Log.d(TAG,"Calibrations, so doing everything");
-                bgReading.sensor = sensor;
-                bgReading.sensor_uuid = sensor.uuid;
-                bgReading.calibration = calibration;
-                bgReading.calibration_uuid = calibration.uuid;
-                bgReading.raw_data = (raw_data/1000);
-                bgReading.filtered_data = (filtered_data/1000);
-                bgReading.timestamp = timestamp;
-                bgReading.uuid = UUID.randomUUID().toString();
-                bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
-                bgReading.synced = false;
+            return bgReading;
+        }
 
-                bgReading.calculateAgeAdjustedRawValue();
+        Calibration calibration = Calibration.last();
+        if (calibration == null) {
+            Log.d(TAG, "create: No calibration yet");
+            bgReading.sensor = sensor;
+            bgReading.sensor_uuid = sensor.uuid;
+            bgReading.raw_data = (raw_data / 1000);
+            bgReading.filtered_data = (filtered_data / 1000);
+            bgReading.timestamp = timestamp;
+            bgReading.uuid = UUID.randomUUID().toString();
+            bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
+            bgReading.synced = false;
+            bgReading.calibration_flag = false;
+
+            bgReading.calculateAgeAdjustedRawValue();
 
-                if(calibration.check_in) {
-                    double firstAdjSlope = calibration.first_slope + (calibration.first_decay * (Math.ceil(new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
-                    double calSlope = (calibration.first_scale / firstAdjSlope)*1000;
-                    double calIntercept = ((calibration.first_scale * calibration.first_intercept) / firstAdjSlope)*-1;
-                    bgReading.calculated_value = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
+            bgReading.save();
+            bgReading.perform_calculations();
+        } else {
+            Log.d(TAG,"Calibrations, so doing everything");
+            bgReading.sensor = sensor;
+            bgReading.sensor_uuid = sensor.uuid;
+            bgReading.calibration = calibration;
+            bgReading.calibration_uuid = calibration.uuid;
+            bgReading.raw_data = (raw_data/1000);
+            bgReading.filtered_data = (filtered_data/1000);
+            bgReading.timestamp = timestamp;
+            bgReading.uuid = UUID.randomUUID().toString();
+            bgReading.time_since_sensor_started = bgReading.timestamp - sensor.started_at;
+            bgReading.synced = false;
+
+            bgReading.calculateAgeAdjustedRawValue();
+
+            if(calibration.check_in) {
+                double firstAdjSlope = calibration.first_slope + (calibration.first_decay * (Math.ceil(new Date().getTime() - calibration.timestamp)/(1000 * 60 * 10)));
+                double calSlope = (calibration.first_scale / firstAdjSlope)*1000;
+                double calIntercept = ((calibration.first_scale * calibration.first_intercept) / firstAdjSlope)*-1;
+                bgReading.calculated_value = (((calSlope * bgReading.raw_data) + calIntercept) - 5);
 
-                } else {
-                    BgReading lastBgReading = BgReading.last();
-                    if (lastBgReading != null && lastBgReading.calibration != null) {
-                        if (lastBgReading.calibration_flag == true && ((lastBgReading.timestamp + (60000 * 20)) > bgReading.timestamp) && ((lastBgReading.calibration.timestamp + (60000 * 20)) > bgReading.timestamp)) {
-                            lastBgReading.calibration.rawValueOverride(BgReading.weightedAverageRaw(lastBgReading.timestamp, bgReading.timestamp, lastBgReading.calibration.timestamp, lastBgReading.age_adjusted_raw_value, bgReading.age_adjusted_raw_value), context);
-                        }
+            } else {
+                BgReading lastBgReading = BgReading.last();
+                if (lastBgReading != null && lastBgReading.calibration != null) {
+                    if (lastBgReading.calibration_flag == true && ((lastBgReading.timestamp + (60000 * 20)) > bgReading.timestamp) && ((lastBgReading.calibration.timestamp + (60000 * 20)) > bgReading.timestamp)) {
+                        lastBgReading.calibration.rawValueOverride(BgReading.weightedAverageRaw(lastBgReading.timestamp, bgReading.timestamp, lastBgReading.calibration.timestamp, lastBgReading.age_adjusted_raw_value, bgReading.age_adjusted_raw_value), context);
                     }
-                    bgReading.calculated_value = ((calibration.slope * bgReading.age_adjusted_raw_value) + calibration.intercept);
                 }
-                if (bgReading.calculated_value < 10) {
-                    bgReading.calculated_value = 9;
-                    bgReading.hide_slope = true;
-                } else {
-                    bgReading.calculated_value = Math.min(400, Math.max(39, bgReading.calculated_value));
-                }
-                Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
-
-                bgReading.save();
-                bgReading.perform_calculations();
-                context.startService(new Intent(context, Notifications.class));
-                BgSendQueue.addToQueue(bgReading, "create", context);
+                bgReading.calculated_value = ((calibration.slope * bgReading.age_adjusted_raw_value) + calibration.intercept);
             }
+            if (bgReading.calculated_value < 10) {
+                bgReading.calculated_value = 9;
+                bgReading.hide_slope = true;
+            } else {
+                bgReading.calculated_value = Math.min(400, Math.max(39, bgReading.calculated_value));
+            }
+            Log.w(TAG, "NEW VALUE CALCULATED AT: " + bgReading.calculated_value);
+
+            bgReading.save();
+            bgReading.perform_calculations();
+            context.startService(new Intent(context, Notifications.class));
+            BgSendQueue.addToQueue(bgReading, "create", context);
         }
+
         Log.w("BG GSON: ",bgReading.toS());
 
         return bgReading;
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 82d67d5..98651a0 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -433,25 +433,28 @@ public void setSerialDataToTransmitterRawData(byte[] buffer, int len) {
                     ackMessage.put(1, (byte) 0xF0);
                     sendBtMessage(ackMessage);
                     Log.v(TAG, "setSerialDataToTransmitterRawData: Creating TransmitterData at " + timestamp);
-                    ProcessNewTransmitterData(TransmitterData.create(buffer, len, timestamp), timestamp);
+                    processNewTransmitterData(TransmitterData.create(buffer, len, timestamp), timestamp);
                 }
             }
         } else {
-            ProcessNewTransmitterData(TransmitterData.create(buffer, len, timestamp), timestamp);
+            processNewTransmitterData(TransmitterData.create(buffer, len, timestamp), timestamp);
         }
     }
 
-    private void ProcessNewTransmitterData(TransmitterData transmitterData, long timestamp) {
-        if (transmitterData != null) {
-            Sensor sensor = Sensor.currentSensor();
-            if (sensor != null) {
-                sensor.latest_battery_level = transmitterData.sensor_battery_level;
-                sensor.save();
+    private void processNewTransmitterData(TransmitterData transmitterData, long timestamp) {
+        if (transmitterData == null) {
+            return;
+        }
 
-                BgReading.create(transmitterData.raw_data, transmitterData.filtered_data, this, timestamp);
-            } else {
-                Log.w(TAG, "setSerialDataToTransmitterRawData: No Active Sensor, Data only stored in Transmitter Data");
-            }
+        Sensor sensor = Sensor.currentSensor();
+        if (sensor == null) {
+            Log.w(TAG, "setSerialDataToTransmitterRawData: No Active Sensor, Data only stored in Transmitter Data");
+            return;
         }
+
+        sensor.latest_battery_level = transmitterData.sensor_battery_level;
+        sensor.save();
+
+        BgReading.create(transmitterData.raw_data, transmitterData.filtered_data, this, timestamp);
     }
 }

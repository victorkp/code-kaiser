diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index bc5dc08..d5231e2 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -32,7 +32,7 @@
             android:value="DexDrip.db" />
         <meta-data
             android:name="AA_DB_VERSION"
-            android:value="32" />
+            android:value="33" />
 
         <provider
             android:name="com.activeandroid.content.ContentProvider"
diff --git a/app/src/main/assets/migrations/33.sql b/app/src/main/assets/migrations/33.sql
new file mode 100644
index 0000000..f25023e
--- /dev/null
+++ b/app/src/main/assets/migrations/33.sql
@@ -0,0 +1 @@
+ALTER TABLE ActiveBgAlert ADD COLUMN alert_started_at INTEGER DEFAULT 0;
\ No newline at end of file
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBgAlert.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBgAlert.java
index b929db1..5832ddd 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBgAlert.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/ActiveBgAlert.java
@@ -24,7 +24,7 @@
     @Column(name = "alert_uuid")
     public String alert_uuid;
 
-    @Column(name = "is_snoozed") //??? Do we need this
+    @Column(name = "is_snoozed") 
     public boolean is_snoozed;
 
     @Column(name = "last_alerted_at") // Do we need this
@@ -33,6 +33,12 @@
     @Column(name = "next_alert_at")
     public Long next_alert_at;
 
+    // This is needed in order to have ascending alerts
+    // we set the real value of it when is_snoozed is being turned to false
+    @Column(name = "alert_started_at")
+    public Long alert_started_at;
+
+    
     public boolean ready_to_alarm() {
         if(new Date().getTime() > next_alert_at) {
             return true;
@@ -42,6 +48,7 @@ public boolean ready_to_alarm() {
 
     public void snooze(int minutes) {
         next_alert_at = new Date().getTime() + minutes * 60000;
+        is_snoozed = true;
         save();
     }
     
@@ -54,8 +61,10 @@ public String toString() {
         String next_alert_at = "next_alert_at: " + DateFormat.getDateTimeInstance(
                 DateFormat.LONG, DateFormat.LONG).format(new Date(this.next_alert_at)); 
 
-        return alert_uuid + " " + is_snoozed + " " + last_alerted_at + " "+ next_alert_at;
-        
+        String alert_started_at = "alert_started_at: " + DateFormat.getDateTimeInstance(
+                DateFormat.LONG, DateFormat.LONG).format(new Date(this.alert_started_at)); 
+
+        return alert_uuid + " " + is_snoozed + " " + last_alerted_at + " "+ next_alert_at + " " + alert_started_at;
         
     }
     
@@ -109,6 +118,7 @@ public static void Create(String alert_uuid, boolean is_snoozed, Long next_alert
         aba.is_snoozed = is_snoozed;
         aba.last_alerted_at = 0L;
         aba.next_alert_at = next_alert_at;
+        aba.alert_started_at = new Date().getTime();
         aba.save();
     }
     
@@ -131,7 +141,19 @@ public static void ClearIfSnoozeFinished() {
         }
     }
     
+    // This function is called from ClockTick, when we play
+    // If we were snoozed, we update the snooze to false, and update the start time.
+    // return the time in minutes from the time playing the alert has started
+    public int getUpdatePlayTime() {
+        if(is_snoozed) {
+            is_snoozed = false;
+            alert_started_at = new Date().getTime();
+            save();
+        }
+        Long timeSeconds =  (new Date().getTime() - alert_started_at) / 1000;
+        return (int)Math.round(timeSeconds / 60.0);
+    }
     
-        
+
 }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
index 79e0400..eb442cb 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/AlertType.java
@@ -125,7 +125,7 @@ public static AlertType get_highest_active_alert(Context context, double bg) {
             Log.w("NOTIFICATIONS", "Readings have been unclear for too long!!");
             Notifications.bgUnclearAlert(context);
         }
-        if (UnclearTime > 0) {
+        if ((UnclearTime > 0 ) && bg_unclear_readings_alerts) {
             Log.e(TAG_ALERT, "We are in an clear state, but not for too long. Alerts are disabled");
             return null;
         }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
index 217e5c1..e6563de 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Models/BgReading.java
@@ -651,7 +651,11 @@ public void find_new_raw_curve() {
             BgReading latest_entry = BgReading.lastNoSenssor();
             ra = 0;
             rb = 0;
-            rc = latest_entry.age_adjusted_raw_value;
+            if (latest_entry != null) {
+                rc = latest_entry.age_adjusted_raw_value;
+            } else {
+                rc = 105;
+            }
 
             save();
         }
@@ -678,6 +682,70 @@ public String noiseValue() {
             return String.valueOf(noise);
         }
     }
+    
+    /*
+     * This function comes to check weather we are in a case that we have an allert but since things are
+     * getting better we should not do anything. (This is only in the case that the alert was snoozed before.)
+     * This means that if this is a low alert, and we have two readings in the last 15 minutes, and
+     * either we have gone in 10 in the last two readings, or we have gone in 3 in the last reading, we
+     * don't play the alert again, but rather wait for the alert to finish.
+     *  I'll start with having the same values for the high alerts.
+    */ 
+    
+    public static boolean trendingToAlertEnd(Context context, boolean above) {
+        // TODO: check if we are not in an UnclerTime.
+        Log.e(TAG_ALERT, "trendingToAlertEnd called");
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+
+        Boolean bg_unclear_readings_alerts = prefs.getBoolean("bg_unclear_readings_alerts", false);
+        if(bg_unclear_readings_alerts) {
+            Long UnclearTimeSetting = Long.parseLong(prefs.getString("bg_unclear_readings_minutes", "90")) * 60000;
+            Long unclearTime = getUnclearTime(UnclearTimeSetting);
+            if (unclearTime > 0) {
+                Log.e(TAG_ALERT, "trendingToAlertEnd we are in an clear time, returning false");
+                return false;
+            }
+        }
+        
+        
+        List<BgReading> latest = BgReading.latest(3);
+        if (latest == null || latest.size() < 2) {
+            // for less than 3 readings, we can't tell what the situation
+            // 
+            Log.e(TAG_ALERT, "trendingToAlertEnd we don't have 3 readings, returning false");
+            return false;
+        }
+        // So, we have at least three values...
+        for(BgReading bgReading : latest) {
+            Log.e(TAG_ALERT, "trendingToAlertEnd - reading: time = " + bgReading.timestamp + " calculated_value " + bgReading.calculated_value);
+        }
+        
+        // now let's talk that they are relevant. the last reading should be from the last 5 minutes, 
+        // two more readings should be from the last 15 minutes. we will allow 21 minutes for the last
+        // 3 to allow one packet to be missed.
+        if (new Date().getTime() - latest.get(2).timestamp > 21 * 60 * 1000) {
+            Log.e(TAG_ALERT, "trendingToAlertEnd we don't have enough points from the last 15 minutes, returning false");
+            return false;
+        }
+        if(above == false) {
+            // This is a low alert, we should be going up
+            if((latest.get(0).calculated_value - latest.get(1).calculated_value > 4) ||
+               (latest.get(0).calculated_value - latest.get(2).calculated_value > 10)) {
+                Log.e(TAG_ALERT, "trendingToAlertEnd returning true for low alert");
+                return true;
+            }
+        } else {
+            // This is a high alert we should be heading down
+            if((latest.get(1).calculated_value - latest.get(0).calculated_value > 4) ||
+               (latest.get(2).calculated_value - latest.get(0).calculated_value > 10)) {
+                Log.e(TAG_ALERT, "trendingToAlertEnd returning true for high alert");
+                return true;
+            }
+        }
+        Log.e(TAG_ALERT, "trendingToAlertEnd returning false, not in the right direction (or not fast enough)");
+        return false;
+        
+    }
 
     // Should that be combined with noiseValue?
     private Boolean Unclear() {
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
index d2c9477..79afdb3 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/NavDrawerBuilder.java
@@ -86,6 +86,10 @@ public NavDrawerBuilder(Context aContext) {
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
             options.add("System Status");
         }
+        boolean bg_alerts = prefs.getBoolean("bg_alerts_from_main_menu", false);
+        if (bg_alerts) {
+            options.add("BG level alerts");
+        }
         options.add("Snooze Alerts");
         options.add("Settings");
 //        options.add("Fake Numbers");
@@ -143,6 +147,10 @@ public NavDrawerBuilder(Context aContext) {
         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
             options.add(new Intent(context, SystemStatus.class));
         }
+        boolean bg_alerts = prefs.getBoolean("bg_alerts_from_main_menu", false);
+        if (bg_alerts) {
+            options.add(new Intent(context, AlertList.class));
+        }
         options.add(new Intent(context, SnoozeActivity.class));
         options.add(new Intent(context, Preferences.class));
 //        options.add(new Intent(context, FakeNumbers.class));
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
index 4573b7c..120922f 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexCollectionService.java
@@ -154,7 +154,11 @@ public void setRetryTimer() {
             Log.d(TAG, "setRetryTimer: Restarting in: " + (retry_in/1000)  + " seconds");
             Calendar calendar = Calendar.getInstance();
             AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            if (Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
+                alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            } else {
+                alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            }
         }
     }
 
@@ -164,7 +168,11 @@ public void setFailoverTimer() {
             Log.d(TAG, "setFailoverTimer: Fallover Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
             Calendar calendar = Calendar.getInstance();
             AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            if (Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
+                alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            } else {
+                alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexCollectionService.class), 0));
+            }
         } else {
             stopSelf();
         }
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
index fdcd278..62decc0 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/Services/DexShareCollectionService.java
@@ -181,7 +181,11 @@ public void setRetryTimer() {
             Log.d(TAG, "Restarting in: " + (retry_in / (60 * 1000)) + " minutes");
             Calendar calendar = Calendar.getInstance();
             AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
-            alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexShareCollectionService.class), 0));
+            if (Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
+                alarm.setExact(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexShareCollectionService.class), 0));
+            } else {
+                alarm.set(alarm.RTC_WAKEUP, calendar.getTimeInMillis() + retry_in, PendingIntent.getService(this, 0, new Intent(this, DexShareCollectionService.class), 0));
+            }
         }
     }
 
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/AlertPlayer.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/AlertPlayer.java
index 3a4402f..8ffa0dd 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/AlertPlayer.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/AlertPlayer.java
@@ -6,10 +6,12 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.media.AudioAttributes;
 import android.media.AudioManager;
 import android.media.MediaPlayer;
 import android.net.Uri;
+import android.preference.PreferenceManager;
 import android.support.v4.app.NotificationCompat;
 import android.util.Log;
 
@@ -26,7 +28,10 @@
     private final static String TAG = AlertPlayer.class.getSimpleName();
     private MediaPlayer mediaPlayer;
     int volumeBeforeAlert;
+    int volumeForThisAlert;
     Context context;
+    final static int  MAX_VIBRATING = 2;
+    final static int  MAX_ASCENDING = 5; 
 
 
     public static AlertPlayer getPlayer() {
@@ -43,7 +48,7 @@ public synchronized  void startAlert(Context ctx, AlertType newAlert, String bgV
       Log.e(TAG, "start called, Threadid " + Thread.currentThread().getId());
       stopAlert(ctx, true, false);
       ActiveBgAlert.Create(newAlert.uuid, false, new Date().getTime() + newAlert.minutes_between * 60000 );
-      Vibrate(ctx, newAlert, bgValue, newAlert.override_silent_mode, newAlert.mp3_file);
+      Vibrate(ctx, newAlert, bgValue, newAlert.override_silent_mode, newAlert.mp3_file, 0);
     }
 
     public synchronized void stopAlert(Context ctx, boolean ClearData, boolean clearIfSnoozeFinished) {
@@ -63,26 +68,6 @@ public synchronized void stopAlert(Context ctx, boolean ClearData, boolean clear
         }
     }
 
-    // True means play the file false means only vibrate.
-    private boolean ShouldPlayFile(Context ctx, AlertType alert) {
-        if(alert.override_silent_mode) {
-            // no meter what mode it is we override it
-            return true;
-        }
-        AudioManager am = (AudioManager)ctx.getSystemService(Context.AUDIO_SERVICE);
-
-        switch (am.getRingerMode()) {
-            case AudioManager.RINGER_MODE_SILENT:
-                // fall through
-            case AudioManager.RINGER_MODE_VIBRATE:
-                return false;
-            case AudioManager.RINGER_MODE_NORMAL:
-                return true;
-        }
-        // unknown mode, not sure let's play just in any case.
-        return true;
-    }
-
     public synchronized  void Snooze(Context ctx, int repeatTime) {
         Log.e(TAG, "Snooze called repeatTime = "+ repeatTime);
         stopAlert(ctx, false, false);
@@ -107,8 +92,12 @@ public synchronized  void PreSnooze(Context ctx, String uuid, int repeatTime) {
     }
 
  // Check the state and alrarm if needed
-    public void ClockTick(Context ctx, String bgValue)
+    public void ClockTick(Context ctx, boolean trendingToAlertEnd, String bgValue)
     {
+        if (trendingToAlertEnd) {
+            Log.e(TAG,"ClockTick: This alert is trending to it's end will not do anything");
+            return;
+        }
         ActiveBgAlert activeBgAlert = ActiveBgAlert.getOnly();
         if (activeBgAlert  == null) {
             // Nothing to do ...
@@ -116,6 +105,8 @@ public void ClockTick(Context ctx, String bgValue)
         }
         if(activeBgAlert.ready_to_alarm()) {
             stopAlert(ctx, false, false);
+            
+            int timeFromStartPlaying = activeBgAlert.getUpdatePlayTime();
             AlertType alert = AlertType.get_alert(activeBgAlert.alert_uuid);
             if (alert == null) {
                 Log.w(TAG, "ClockTick: The alert was already deleted... will not play");
@@ -123,12 +114,12 @@ public void ClockTick(Context ctx, String bgValue)
                 return;
             }
             Log.e(TAG,"ClockTick: Playing the alert again");
-            Vibrate(ctx, alert, bgValue, alert.override_silent_mode, alert.mp3_file);
+            Vibrate(ctx, alert, bgValue, alert.override_silent_mode, alert.mp3_file, timeFromStartPlaying);
         }
 
     }
 
-    private void PlayFile(Context ctx, String FileName) {
+    private void PlayFile(Context ctx, String FileName, float VolumeFrac) {
         Log.e(TAG, "PlayFile: called FileName = " + FileName);
         if(mediaPlayer != null) {
             Log.e(TAG, "ERROR, PlayFile:going to leak a mediaplayer !!!");
@@ -141,11 +132,11 @@ private void PlayFile(Context ctx, String FileName) {
             mediaPlayer = MediaPlayer.create(ctx, R.raw.default_alert);
         }
         if(mediaPlayer != null) {
-
             AudioManager manager = (AudioManager) ctx.getSystemService(Context.AUDIO_SERVICE);
             int maxVolume = manager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
             volumeBeforeAlert = manager.getStreamVolume(AudioManager.STREAM_MUSIC);
-            manager.setStreamVolume(AudioManager.STREAM_MUSIC, maxVolume, 0);
+            volumeForThisAlert = (int)(maxVolume * VolumeFrac);
+            manager.setStreamVolume(AudioManager.STREAM_MUSIC, volumeForThisAlert, 0);
             context = ctx;
 
             mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
@@ -154,8 +145,7 @@ public void onCompletion(MediaPlayer mp) {
                     Log.e(TAG, "PlayFile: onCompletion called (finished playing) ");
                     AudioManager manager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
                     int currentVolume = manager.getStreamVolume(AudioManager.STREAM_MUSIC);
-                    int maxVolume = manager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
-                    if(maxVolume == currentVolume) {
+                    if(volumeForThisAlert == currentVolume) {
                         // If the user has changed the volume, don't change it again.
                         manager.setStreamVolume(AudioManager.STREAM_MUSIC, volumeBeforeAlert, 0);
                     }
@@ -178,8 +168,16 @@ private PendingIntent snoozeIntent(Context ctx){
         return PendingIntent.getService(ctx, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
 
     }
-    private void Vibrate(Context ctx, AlertType alert, String bgValue, Boolean overrideSilent, String audioPath) {
+    private void Vibrate(Context ctx, AlertType alert, String bgValue, Boolean overrideSilent, String audioPath, int timeFromStartPlaying) {
+        Log.e(TAG, "Vibrate called timeFromStartPlaying = " + timeFromStartPlaying);
         Log.e("ALARM", "setting vibrate alarm");
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
+        boolean ascending_bg_alerts = prefs.getBoolean("ascending_bg_alerts", true);
+        if (!ascending_bg_alerts) {
+            // We start from the non ascending part...
+            timeFromStartPlaying = MAX_ASCENDING;
+        }
+
         String title = bgValue + " " + alert.name;
         String content = "BG LEVEL ALERT: " + bgValue;
         Intent intent = new Intent(ctx, SnoozeActivity.class);
@@ -190,10 +188,16 @@ private void Vibrate(Context ctx, AlertType alert, String bgValue, Boolean overr
             .setContentText(content)
             .setContentIntent(notificationIntent(ctx, intent))
             .setDeleteIntent(snoozeIntent(ctx));
-        if(overrideSilent) {
-            PlayFile(ctx, alert.mp3_file);
-        } else {
-            builder.setSound(Uri.parse(audioPath), AudioAttributes.USAGE_ALARM);
+        if (timeFromStartPlaying >= MAX_VIBRATING) {
+            // Before this, we only vibrate...
+            float volumeFrac = (float)(timeFromStartPlaying - MAX_VIBRATING) / (MAX_ASCENDING - MAX_VIBRATING);
+            volumeFrac = Math.max(volumeFrac, 1);
+            Log.e(TAG, "Vibrate volumeFrac = " + volumeFrac);
+            if(overrideSilent) {
+                PlayFile(ctx, alert.mp3_file, volumeFrac);
+            } else {
+                builder.setSound(Uri.parse(audioPath), AudioAttributes.USAGE_ALARM);
+            }
         }
         //NotificationCompat.Builder mBuilder = notificationBuilder(title, content, intent);
         builder.setVibrate(Notifications.vibratePattern);
diff --git a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
index a418626..b30a27c 100644
--- a/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
+++ b/app/src/main/java/com/eveningoutpost/dexdrip/UtilityModels/Notifications.java
@@ -38,6 +38,7 @@
 import com.eveningoutpost.dexdrip.Sensor;
 import com.eveningoutpost.dexdrip.Services.MissedReadingService;
 
+import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 
@@ -60,6 +61,7 @@
     public static int calibration_snooze;
     public static String calibration_notification_sound;
     public static boolean doMgdl;
+    public static boolean smart_snoozing;
     private final static String TAG = AlertPlayer.class.getSimpleName();
 
     Context mContext;
@@ -93,7 +95,7 @@ protected void onHandleIntent(Intent intent) {
         Log.d("Notifications", "Running Notifications Intent Service");
         ReadPerfs(getApplicationContext());
         notificationSetter(getApplicationContext());
-        periodicTimer(getApplicationContext());
+        ArmTimer(getApplicationContext(), callbackPeriod);
     }
 
     public void ReadPerfs(Context context) {
@@ -112,6 +114,7 @@ public void ReadPerfs(Context context) {
         calibration_override_silent = prefs.getBoolean("calibration_alerts_override_silent", false);
         calibration_notification_sound = prefs.getString("calibration_notification_sound", "content://settings/system/notification_sound");
         doMgdl = (prefs.getString("units", "mgdl").compareTo("mgdl") == 0);
+        smart_snoozing = prefs.getBoolean("smart_snoozing", true);
         bg_ongoing = prefs.getBoolean("run_service_in_foreground", false);
     }
 
@@ -160,7 +163,8 @@ public void FileBasedNotifications(Context context) {
             if (activeBgAlert.uuid.equals(newAlert.uuid)) {
                 // This is the same alert. Might need to play again...
                 Log.e(TAG, "FileBasedNotifications we have found an active alert, checking if we need to play it " + newAlert.name);
-                AlertPlayer.getPlayer().ClockTick(context, EditAlertActivity.UnitsConvert2Disp(doMgdl, bgReading.calculated_value));
+                boolean trendingToAlertEnd = trendingToAlertEnd(context, newAlert);
+                AlertPlayer.getPlayer().ClockTick(context, trendingToAlertEnd, EditAlertActivity.UnitsConvert2Disp(doMgdl, bgReading.calculated_value));
                 return;
             }
            // Currently the ui blocks having two alerts with the same alert value.
@@ -177,10 +181,11 @@ public void FileBasedNotifications(Context context) {
             boolean opositeDirection = AlertType.OpositeDirection(activeBgAlert, newAlert);
             AlertType  newHigherAlert = AlertType.HigherAlert(activeBgAlert, newAlert);
             if ((newHigherAlert == activeBgAlert) && (!opositeDirection)) {
-                // the existing alert is the higher, we should not do anything
-                Log.e(TAG, "FileBasedNotifications The existing alert has the same importance, doing nothing newHigherAlert = " + newHigherAlert.name +
+                // the existing alert is the higher, we should check if to play it
+                Log.e(TAG, "FileBasedNotifications The existing alert has the same importance, checking if to playit newHigherAlert = " + newHigherAlert.name +
                         "activeBgAlert = " + activeBgAlert.name);
-                AlertPlayer.getPlayer().ClockTick(context, EditAlertActivity.UnitsConvert2Disp(doMgdl, bgReading.calculated_value));
+                boolean trendingToAlertEnd = trendingToAlertEnd(context, newHigherAlert);
+                AlertPlayer.getPlayer().ClockTick(context, trendingToAlertEnd, EditAlertActivity.UnitsConvert2Disp(doMgdl, bgReading.calculated_value));
                 return;
             }
 
@@ -194,6 +199,14 @@ public void FileBasedNotifications(Context context) {
             AlertPlayer.getPlayer().stopAlert(context, true, false);
         }
     }
+    
+    boolean trendingToAlertEnd(Context context, AlertType Alert) {
+        if(!smart_snoozing) {
+        //  User does not want smart snoozing at all.
+            return false;
+        }
+        return BgReading.trendingToAlertEnd(context, Alert.above);
+    }
 /*
  * *****************************************************************************************************************
  */
@@ -240,23 +253,16 @@ public void notificationSetter(Context context) {
         }
     }
 
-    public void periodicTimer(Context context) {
-        // This is the timer function that will be called every minute. It is used in order to replay alerts,
-        // execute snoozes and alert if we are not recieving data for a long time.
-        Log.e(TAG, "PeriodicTimer called");
-        ArmTimer(context, callbackPeriod);
-    }
-
     private void  ArmTimer(Context context, int time) {
         Log.e(TAG, "ArmTimer called");
         if(ActiveBgAlert.getOnly() != null) {
-            Intent intent = new Intent(context, Notifications.class);
-            AlarmManager alarmMgr = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-            PendingIntent alarmIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
-
-            alarmMgr.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
-                    SystemClock.elapsedRealtime() +
-                            time, alarmIntent);
+            Calendar calendar = Calendar.getInstance();
+            AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
+            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
+                alarm.setExact(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis() + time, PendingIntent.getService(this, 0, new Intent(this, Notifications.class), 0));
+            } else {
+                alarm.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis() + time, PendingIntent.getService(this, 0, new Intent(this, Notifications.class), 0));
+            }
         }
     }
 
diff --git a/app/src/main/res/layout-xlarge/activity_home.xml b/app/src/main/res/layout-xlarge/activity_home.xml
index 6ddd9a4..298d8e1 100644
--- a/app/src/main/res/layout-xlarge/activity_home.xml
+++ b/app/src/main/res/layout-xlarge/activity_home.xml
@@ -59,6 +59,18 @@
                     android:paddingEnd="20dp"
                     android:textSize="100dp"
                     android:paddingTop="0dp" />
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textAppearance="?android:attr/textAppearanceSmall"
+                    android:text="100%"
+                    android:id="@+id/textBridgeBattery"
+                    android:textStyle="normal"
+                    android:textSize="12sp"
+                    android:inputType="none"
+                    android:layout_below="@+id/notices"
+                    android:layout_alignParentStart="true" />
             </RelativeLayout>
 
             <lecho.lib.hellocharts.view.PreviewLineChartView
diff --git a/app/src/main/res/xml/pref_notifications.xml b/app/src/main/res/xml/pref_notifications.xml
index f0b0060..5f8bc7f 100644
--- a/app/src/main/res/xml/pref_notifications.xml
+++ b/app/src/main/res/xml/pref_notifications.xml
@@ -11,7 +11,28 @@
                 />
         </Preference>
 
+        <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
+            android:title="Bg alerts settings"
+            android:key="bg_alerts_screen">
+            <CheckBoxPreference
+                android:key="smart_snoozing"
+                android:title="Smart snoozing"
+                android:summary="Keep snoozing if bg is heading in the right direction"
+                android:defaultValue="true" />
 
+            <CheckBoxPreference
+                android:key="bg_alerts_from_main_menu"
+                android:title="Create a shortcut from main navigation to bg leval screen"
+                android:defaultValue="false" />
+            
+            <CheckBoxPreference
+                android:key="ascending_bg_alerts"
+                android:title="ascending alerts"
+                android:summary="In case of bg alerts, the phone will vibrate twice and start with low volume alerts"
+                android:defaultValue="true" />
+            
+        </PreferenceScreen>
+        
 
         <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
             android:title="Calibration Alerts"
